<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>friends</title>
      <link href="/2022/06/25/friends/"/>
      <url>/2022/06/25/friends/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCache入门</title>
      <link href="/2022/06/24/SpringCache%E5%85%A5%E9%97%A8/"/>
      <url>/2022/06/24/SpringCache%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存的概念"><a class="markdownIt-Anchor" href="#缓存的概念">#</a> 缓存的概念</h2><p>我们可以将缓存定义为一种存储机制，它将数据保存在某个地方，并以一种更快的方式提供服务。</p><p>要理解缓存，我们先了解下基本概念</p><h3 id="缓存命中率"><a class="markdownIt-Anchor" href="#缓存命中率">#</a> 缓存命中率</h3><p>即从缓存中读取数据的次数与总读取次数的比率。 一般来讲，命中率越高也好。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">命中率 = 从缓存中读取的次数  / (总读取次数[从缓存中读取的次数+从慢速设备上读取的次数])</span><br></pre></td></tr></table></figure><p>复制</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Miss</span>率 = 没从缓存中读取的次数/ (总读取次数[从缓存中读取的次数+从慢速设备上读取的次数])</span><br></pre></td></tr></table></figure><p>复制</p><p>这是一个非常重要的监控指标，如果要做缓存，就一定要监控这个指标，来看缓存是否工作良好。</p><hr><h3 id="过期策略"><a class="markdownIt-Anchor" href="#过期策略">#</a> 过期策略</h3><p>即如果缓存满了，从缓存中移除数据的策略，常见的有 LFU 、LRU、FIFO</p><ul><li>FIFO (First in First Out) <strong>先进先出策略</strong>，即先放入缓存的数据先被移除</li><li>LRU (Least Recently Used) <strong>最久未使用策略</strong>， 即使用时间距离现在最久的那个数据被移除</li><li>LFU (Leaset Frequently Used) <strong>最近最少使用策略</strong>，即一定时间内使用次数（频率）最少的那个数据被移除</li><li>TTL（Time To Live）<strong>存活期</strong>，即从缓存中创建时间点开始至到期的一个时间段（不管在这个时间段内有没被访问过都将过期）</li><li>TTI （Time To Idle）<strong>空闲期</strong>，即一个数据多久没有被访问就从缓存中移除的时间。</li></ul><p>至此，我们基本了解了缓存的一些基本知识。 在 Java 中一般会对调用方法进行缓存控制，比如 findUserById (Sting id),<strong> 先从缓存中查找有没有符合查询条件的数据，如果没有，则执行改方法从数据库中查找该用户，然后添加到缓存中，下次调用时将从缓存中获取。</strong></p><p>从 Spring3.1 开始，提供了缓存注解，并且提供了 Cache 层的抽象。 此外，JSR-107 也从 Spring4.0 开始得到全面支持。</p><p>Spring 提供可一种可以在方法级别进行缓存的缓存抽象。 通过使用 AOP 对方法机型织入，如果已经为特定方法入参执行过该方法，那么不必执行实际方法就可以返回被缓存的结果。</p><p>为了启用 AOP 缓存功能，需要使用缓存注解对类中的相关方法进行标记，以便 Spring 为其生成具备缓存功能的代理类。 需要注意的是，Spring Cache 仅提供了一种抽象而未提供具体的实现。 我们以便会自己使用 AIP 来做一定程度的封装实现。</p><h2 id="通用缓存springcache"><a class="markdownIt-Anchor" href="#通用缓存springcache">#</a> 通用缓存 SpringCache</h2><p>Spring Cache 是 Spring 提供的通用缓存框架。它利用了 AOP，实现了基于注解的缓存功能，使开发者不用关心底层使用了什么缓存框架，只需要简单地加一个注解，就能实现缓存功能了。用户使用 Spring Cache，可以快速开发一个很不错的缓存功能。</p><h4 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析">#</a> 问题分析</h4><p><img src="/2022/06/24/SpringCache%E5%85%A5%E9%97%A8/1279412-20220113152236129-2034256100.png" alt="img"></p><p><img src="/2022/06/24/SpringCache%E5%85%A5%E9%97%A8/1279412-20220113152509989-1902173257.png" alt="img"></p><h3 id="spring-cache的好处"><a class="markdownIt-Anchor" href="#spring-cache的好处">#</a> Spring Cache 的好处</h3><ul><li>支持开箱即用（Out Of The Box），并提供基本的 Cache 抽象，方便切换各种底层 Cache</li><li>通过 Cache 注解即可实现缓存逻辑透明化，让开发者关注业务逻辑</li><li>当事务回滚时，缓存也会自动回滚</li><li>支持比较复杂的缓存逻辑</li><li>提供缓存编程的一致性抽象，方便代码维护。</li></ul><h3 id="spring-cache的缺点"><a class="markdownIt-Anchor" href="#spring-cache的缺点">#</a> Spring Cache 的缺点</h3><ul><li>Spring Cache 并不针对多进程的应用环境进行专门的处理。</li><li>另外 Spring Cache 抽象的操作中没有锁的概念，当多线程并发操作（更新或者删除）同一个缓存项时，有可能读取到过期的数据。</li></ul><h2 id="入门"><a class="markdownIt-Anchor" href="#入门">#</a> 入门</h2><h3 id="maven依赖"><a class="markdownIt-Anchor" href="#maven依赖">#</a> maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解配置"><a class="markdownIt-Anchor" href="#基于注解配置">#</a> 基于注解配置</h3><ul><li>@EnableCaching：开启缓存功能</li><li>@Cacheable 主要针对注解配置，能够根据方法的请求参数对其进行缓存</li><li>@CachePut：定义更新缓存，触发缓存更新</li><li>@CacheEvict：定义清除缓存，触发缓存清除</li><li>@Caching：组合定义多种缓存功能</li><li>@CacheConfig：定义公共设置，位于 class 之上</li></ul><h4 id="enablecaching"><a class="markdownIt-Anchor" href="#enablecaching">#</a> @EnableCaching</h4><p>该注解主要用于开启基于注解的缓存功能，使用方式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCacheManager</span>();</span><br><span class="line">        cacheManager.setCaches(Arrays.asList(<span class="keyword">new</span> <span class="title class_">ConcurrentMapCache</span>(<span class="string">&quot;default&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在 SpringBoot 中使用 SpringCache 可以由自动配置功能来完成 CacheManager 的注册，SpringBoot 会自动发现项目中拥有的缓存系统，而注册对应的缓存管理器，当然我们也可以手动指定。</p></blockquote><p>使用该注解和如下 XML 配置具有一样的效果：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.support.SimpleCacheManager&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">        &lt;property name=&quot;</span><span class="attr">caches</span>&quot;&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">                    &lt;property name=&quot;</span><span class="attr">name</span>&quot; <span class="attr">value</span>=<span class="string">&quot;default&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="cacheable"><a class="markdownIt-Anchor" href="#cacheable">#</a> @Cacheable</h4><p>该注解用于标注于方法之上用于标识该方法的返回结果需要被缓存起来，标注于类之上标识该类中所有方法均需要将结果缓存起来。</p><p>该注解标注的方法每次被调用前都会触发缓存校验，校验指定参数的缓存是否已存在（已发生过相同参数的调用），若存在，直接返回缓存结果，否则执行方法内容，最后将方法执行结果保存到缓存中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value = &quot;user&quot;,key = &quot;#userId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">queryById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">//从数据库查询</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line">    user.setId(userId);</span><br><span class="line">    user.setNickname(<span class="string">&quot;ceshi&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解属性中，<mark>value</mark> 是必需的，它指定了你的缓存存放在哪块命名空间</p><h4 id="cachevict"><a class="markdownIt-Anchor" href="#cachevict">#</a> @CachEvict</h4><p>该注解主要针对方法配置，能够根据一定的条件对缓存进行清空。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id修改</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;user&quot;,key = &quot;#userId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line">    user.setId(userId);</span><br><span class="line">    user.setNickname(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cacheput"><a class="markdownIt-Anchor" href="#cacheput">#</a> @CachePut</h4><p>该注解用于更新缓存，无论结果是否已经缓存，都会在方法执行结束插入缓存，相当于更新缓存。一般用于更新方法之上。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnimalRepository animalRepository;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;animalById&quot;, key = &quot;#animal.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Animal&gt; <span class="title function_">updateAnimal</span><span class="params">(<span class="keyword">final</span> Animal animal)</span>&#123;</span><br><span class="line">        Wrapper&lt;Animal&gt; animalWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        ((UpdateWrapper&lt;Animal&gt;) animalWrapper).eq(<span class="string">&quot;id&quot;</span>,animal.getId());</span><br><span class="line">        animalRepository.update(animal, animalWrapper);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="built_in">this</span>.getAnimalById(animal.getId()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="caching"><a class="markdownIt-Anchor" href="#caching">#</a> @Caching</h4><p>这个注解用于组个多个缓存操作，包括针对不用缓存名称的相同操作等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnimalRepository animalRepository;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">        evict = &#123;</span></span><br><span class="line"><span class="meta">            @CacheEvict(value = &quot;animalById&quot;, key = &quot;#id&quot;),</span></span><br><span class="line"><span class="meta">            @CacheEvict(value = &quot;animals&quot;, allEntries = true, beforeInvocation = true)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title function_">deleteAnimalById</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(animalRepository.deleteById(id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Cacheable(&quot;animals&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Page&lt;Animal&gt;&gt; <span class="title function_">getAnimalPage</span><span class="params">(<span class="keyword">final</span> Animal animal, <span class="keyword">final</span> <span class="type">int</span> pageId, <span class="keyword">final</span> <span class="type">int</span> pageSize)</span>&#123;</span><br><span class="line">        Page&lt;Animal&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line">        page.setCurrent(pageId);</span><br><span class="line">        page.setSize(pageSize);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok((Page&lt;Animal&gt;) animalRepository.selectPage(page,packWrapper(animal, WrapperType.QUERY)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cacheconfig"><a class="markdownIt-Anchor" href="#cacheconfig">#</a> @CacheConfig</h4><p>该注解标注于类之上，用于进行一些公共的缓存相关配置。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCache </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring如何解决循环依赖问题</title>
      <link href="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="先上解决方案"><a class="markdownIt-Anchor" href="#先上解决方案">#</a> 先上解决方案：</h2><p>@Lazy</p><p><strong>Spring 高频面试题：如何解决循环依赖问题！</strong></p><h2 id="循环依赖问题全景图"><a class="markdownIt-Anchor" href="#循环依赖问题全景图">#</a> <strong>循环依赖问题全景图</strong></h2><p><img src="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/1620.png" alt="img"></p><h2 id="什么是循环依赖问题"><a class="markdownIt-Anchor" href="#什么是循环依赖问题">#</a> <strong>什么是循环依赖问题？</strong></h2><blockquote><p>❝类与类之间的依赖关系形成了闭环，就会导致循环依赖问题的产生。 ❞</p><p>❝比如下图中 A 类依赖了 B 类，B 类依赖了 C 类，而最后 C 类又依赖了 A 类，这样就形成了循环依赖问题。 ❞</p></blockquote><p><img src="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/1620-16556419433531.png" alt="img"></p><h2 id="循环依赖问题案例分析"><a class="markdownIt-Anchor" href="#循环依赖问题案例分析">#</a> <strong>循环依赖问题案例分析</strong></h2><p>演示代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"> private <span class="title class_">ClassB</span> classB;</span><br><span class="line"></span><br><span class="line"> public <span class="title class_">ClassB</span> <span class="title function_">getClassB</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> classB;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public <span class="keyword">void</span> <span class="title function_">setClassB</span>(<span class="params">ClassB classB</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">classB</span> = classB;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"> private <span class="title class_">ClassA</span> classA;</span><br><span class="line"></span><br><span class="line"> public <span class="title class_">ClassA</span> <span class="title function_">getClassA</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> classA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public <span class="keyword">void</span> <span class="title function_">setClassA</span>(<span class="params">ClassA classA</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">classA</span> = classA;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><p>配置文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;classA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ioc.cd.ClassA&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;classB&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;classB&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;classB&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ioc.cd.ClassB&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;classA&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;classA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>复制</p><p>测试代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Test</span></span><br><span class="line">public <span class="keyword">void</span> <span class="title function_">test</span>() throws <span class="title class_">Exception</span> &#123;</span><br><span class="line"> <span class="comment">// 创建IoC容器，并进行初始化</span></span><br><span class="line"> <span class="title class_">String</span> resource = <span class="string">&quot;spring/spring-ioc-circular-dependency.xml&quot;</span>;</span><br><span class="line"> <span class="title class_">ApplicationContext</span> context = <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(resource);</span><br><span class="line"> <span class="comment">// 获取ClassA的实例（此时会发生循环依赖）</span></span><br><span class="line"> <span class="title class_">ClassA</span> classA = (<span class="title class_">ClassA</span>) context.<span class="title function_">getBean</span>(<span class="title class_">ClassA</span>.<span class="property">class</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><p>通过 Spring IOC 流程的源码分析循环依赖问题：</p><p><img src="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/1620-16556419433542.png" alt="img"></p><h2 id="以上案例有几种循环依赖问题"><a class="markdownIt-Anchor" href="#以上案例有几种循环依赖问题">#</a> <strong>以上案例有几种循环依赖问题？</strong></h2><p>循环依赖问题在 Spring 中主要有三种情况：</p><ul><li>通过构造方法进行依赖注入时产生的循环依赖问题。</li><li>通过 setter 方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</li><li>通过 setter 方法进行依赖注入且是在单例模式下产生的循环依赖问题。</li></ul><blockquote><p>❝注意：在 Spring 中，只有【第三种方式】的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。 ❞</p></blockquote><p>其实也很好解释:</p><ul><li>第一种构造方法注入的情况下，在 new 对象的时候就会堵塞住了，其实也就是” 先有鸡还是先有蛋 “的历史难题。</li><li>第二种 setter 方法 &amp;&amp; 多例的情况下，每一次 getBean () 时，都会产生一个新的 Bean，如此反复下去就会有无穷无尽的 Bean 产生了，最终就会导致 OOM 问题的出现。</li></ul><h2 id="如何解决循环依赖问题"><a class="markdownIt-Anchor" href="#如何解决循环依赖问题">#</a> <strong>如何解决循环依赖问题？</strong></h2><p>那 Spring 到底是如何解决的 setter 方法依赖注入引起的循环依赖问题呢？请看下图（其实主要是通过两个缓存来解决的）：</p><p><img src="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/1620-16556419433543.png" alt="img"></p><h2 id="spring三大缓存介绍"><a class="markdownIt-Anchor" href="#spring三大缓存介绍">#</a> <strong>Spring 三大缓存介绍</strong></h2><p>Spring 中有三个缓存，用于存储单例的 Bean 实例，这三个缓存是彼此互斥的，不会针对同一个 Bean 的实例同时存储。</p><blockquote><p>❝如果调用 getBean，则需要从三个缓存中依次获取指定的 Bean 实例。读取顺序依次是一级缓存–&gt; 二级缓存–&gt; 三级缓存 ❞</p></blockquote><p><img src="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/1620-16556419433544.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一级缓存：Map&lt;String, Object&gt; singletonObjects</span><br></pre></td></tr></table></figure><h3 id="第一级缓存的作用"><a class="markdownIt-Anchor" href="#第一级缓存的作用">#</a> <strong>第一级缓存的作用？</strong></h3><ul><li>用于存储单例模式下创建的 Bean 实例（已经创建完毕）。</li><li>该缓存是对外使用的，指的就是使用 Spring 框架的程序员。</li></ul><h3 id="存储什么数据"><a class="markdownIt-Anchor" href="#存储什么数据">#</a> <strong>存储什么数据？</strong></h3><ul><li>K：bean 的名称</li><li>V：bean 的实例对象（有代理对象则指的是代理对象，已经创建完毕）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第二级缓存：Map&lt;String, Object&gt; earlySingletonObjects</span><br></pre></td></tr></table></figure><h3 id="第二级缓存的作用"><a class="markdownIt-Anchor" href="#第二级缓存的作用">#</a> <strong>第二级缓存的作用？</strong></h3><ul><li>用于存储单例模式下创建的 Bean 实例（该 Bean 被提前暴露的引用，该 Bean 还在创建中）。</li><li>该缓存是对内使用的，指的就是 Spring 框架内部逻辑使用该缓存。</li><li>为了解决第一个 classA 引用最终如何替换为代理对象的问题（如果有代理对象）请爬楼参考演示案例</li></ul><h3 id="存储什么数据-2"><a class="markdownIt-Anchor" href="#存储什么数据-2">#</a> <strong>存储什么数据？</strong></h3><ul><li>K：bean 的名称</li><li>V：bean 的实例对象（有代理对象则指的是代理对象，该 Bean 还在创建中）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第三级缓存：Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</span><br></pre></td></tr></table></figure><h3 id="第三级缓存的作用"><a class="markdownIt-Anchor" href="#第三级缓存的作用">#</a> <strong>第三级缓存的作用？</strong></h3><p>通过 ObjectFactory 对象来存储单例模式下提前暴露的 Bean 实例的引用（正在创建中）。该缓存是对内使用的，指的就是 Spring 框架内部逻辑使用该缓存。此缓存是解决循环依赖最大的功臣</p><h3 id="存储什么数据-3"><a class="markdownIt-Anchor" href="#存储什么数据-3">#</a> <strong>存储什么数据？</strong></h3><ul><li>K：bean 的名称</li><li>V：ObjectFactory，该对象持有提前暴露的 bean 的引用</li></ul><p><img src="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/1620-16556419433545.png" alt="img"></p><blockquote><p>❝为什么第三级缓存要使用 ObjectFactory？需要提前产生代理对象。 ❞</p></blockquote><p><img src="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/1620-16556419433546.png" alt="img"></p><blockquote><p>❝什么时候将 Bean 的引用提前暴露给第三级缓存的 ObjectFactory 持有？时机就是在第一步实例化之后，第二步依赖注入之前，完成此操作。 ❞</p></blockquote><p><img src="/2022/06/19/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/1620-16556419433547.png" alt="img"></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> <strong>总结</strong></h3><p>以上就是 Spring 解决循环依赖的关键点！总结来说，就是要搞清楚以下几点：</p><ul><li>搞清楚 Spring 三级缓存的作用？</li><li>搞清楚第三级缓存中 ObjectFactory 的作用？</li><li>搞清楚为什么需要第二级缓存？</li><li>搞清楚什么时候使用三级缓存（添加和查询操作）？</li><li>搞清楚什么时候使用二级缓存（添加和查询操作）？</li><li>当目标对象产生代理对象时，Spring<a href="https://cloud.tencent.com/product/tke?from=10680"> 容器</a>中（第一级缓存）到底存储的是谁？</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatisplus公共字段自动填充</title>
      <link href="/2022/06/04/mybatisplus%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85/"/>
      <url>/2022/06/04/mybatisplus%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析">#</a> 需求分析</h2><p>在开发中，表结构中往往存在相同的字段（如 createUser，updateUser，createTime，updateTime 等）</p><p>每次接收到 http 请求后需要手动填充这些字段，非常非常麻烦</p><p>于是，使用 mybaitsPlus 中字段自动填充策略简化开发</p><h2 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法">#</a> 使用方法</h2><p><strong>1. 在实体类上加注解 @TableField</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">   <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">   <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">   <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">   <span class="keyword">private</span> Long updateUser;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 构建实现 MetaObjectHandler 的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元数据对象处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作时自动填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时自动填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他类中执行 update，insert 等方法前会先将数据交由这个类处理（可以理解为 AOP）</p><h3 id="如何将数据传递给自定义的处理器"><a class="markdownIt-Anchor" href="#如何将数据传递给自定义的处理器">#</a> 如何将数据传递给自定义的处理器</h3><p><mark>通过 ThreadLocal</mark></p><p>一个用户通过浏览器访问数据，使用的是一个线程</p><p><strong>什么是 ThreadLocal</strong></p><blockquote><p>它并不是一个 Thread，而是 Thread 的局部变量，当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供单独的<strong>变量副本</strong>，所以每个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal 为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p></blockquote><p><strong>ThreadLocal 常用方法</strong></p><ul><li>void set (T value) 设置当前线程局部变量的值</li><li>T get（） 返回当前线程所对应的线程局部变量的值</li></ul><p><strong>因此</strong></p><blockquote><p>我们可以在 LoginCheckFilter 的 doFilter 方法中获取当前登录用户 id, 并调用 ThreadLocal 的 set 方法来设置当前线程的线程局部变量的值 (用户 id), 然后在 MyMetaObjectHandler 的 updateFill 方法中调用 ThreadLocal 的 get 方法来获得当前线程所对应的线程局部变量的值 (用户 id)。</p></blockquote><h2 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤">#</a> 实现步骤</h2><ol><li>编写 BaseContext 工具类，基于 ThreadLocal 封装的工具类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 LoginCheckFilter 的 doFilter, 方法中调用 BaseContext 来设置当前登录用户的 id</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 判断登录状态，若已登录则放行</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long) request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (empId!=<span class="literal">null</span>)&#123;</span><br><span class="line">    log.info(<span class="string">&quot;用户已登录，用户id为：&#123;&#125;&quot;</span>,empId);</span><br><span class="line">    BaseContext.setCurrentId(empId);</span><br><span class="line">    filterChain.doFilter(request,response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 MyMetaObjectHandler 的方法中调用 BaseContext 获取登录用户的 id</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元数据对象处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作时自动填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>,LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createUser&quot;</span>,BaseContext.getCurrentId());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>,BaseContext.getCurrentId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时自动填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>,LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>,BaseContext.getCurrentId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatisPlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvc消息转换器</title>
      <link href="/2022/06/02/mvc%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
      <url>/2022/06/02/mvc%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h2><p>本文介绍 Spring MVC 中的一个极其重要的组件：HttpMessageConverter 消息转换器。</p><p>有一副非常著名的图，来形容 Spring MVC 对一个请求的处理：</p><p><img src="/2022/06/02/mvc%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=.png" alt="【小家Spring】Spring MVC容器的web九大组件之---HandlerAdapter源码详解---HttpMessageConverter 消息转换器详解_# 享学Spring MVC"></p><p>从图中可见 HttpMessageConverter 对 Spring MVC 的重要性。它对请求、响应都起到了非常关键的作用～</p><h2 id="瑞吉外卖项目中遇到的问题"><a class="markdownIt-Anchor" href="#瑞吉外卖项目中遇到的问题">#</a> 瑞吉外卖项目中遇到的问题</h2><p>修改员工信息时，前端需要向后端传入员工 id，这个 id 是超过 16 位的 long 型变量，而 js 在处理时会失去精度（对末尾几位四舍五入），导致传入后端的 id 与数据库表中的 id 字段不符，从而修改信息失败。</p><p>因此需要在后端配置 mvc 消息转换器，将前端传入的 Long 型字段转化为字符串</p><h2 id="为何需要消息转换器"><a class="markdownIt-Anchor" href="#为何需要消息转换器">#</a> 为何需要消息转换器</h2><p>==<strong>HttpMessageConverter</strong>== 是用来处理 request 和 response 里的数据的。.</p><p>请求和响应都有对应的 body，而这个 body 就是需要关注的主要数据。<br>请求体的表述一般就是一段字符串，当然也可以是二进制数据（比如上传～）。<br>响应体则是浏览器渲染页面的依据，对于一个普通 html 页面得响应，响应体就是这个 html 页面的源代码。</p><p>请求体和响应体都是需要配合 Content-Type 头部使用的，这个头部主要用于说明 body 中得字符串是什么格式的，比如：text，json，xml 等。对于请求报文，只有通过此头部，服务器才能知道怎么解析请求体中的字符串，对于响应报文，浏览器通过此头部才知道应该怎么渲染响应结果，是<strong>直接打印字符串还是根据代码渲染为一个网页</strong></p><p>对于<mark> HttpServletRequest 和 HttpServletResponse</mark>，可以分别调用<mark> getInputStream</mark> 和<mark> getOutputStream</mark> 来直接获取 body。但是<mark>获取到的仅仅只是一段字符串</mark></p><p>** 而对于 java 来说，处理一个对象肯定比处理一个字符串要方便得多，也好理解得多。** 所以根据 Content-Type 头部，将 body 字符串转换为 java 对象是常有的事。反过来，根据 Accept 头部，将 java 对象转换客户端期望格式的字符串也是必不可少的工作。这就是我们本文所讲述的消息转换器的工作～</p><p>消息转换器<strong>它能屏蔽你对底层转换的实现，分离你的关注点，让你专心操作 java 对象，其余的事情你就交给我 Spring MVC 吧～大大提高你的编码效率 (可议说比源生 Servlet 开发高级太多了)</strong></p><p>Spring 内置了很多<mark> HttpMessageConverter</mark>，比如<mark> MappingJackson2HttpMessageConverter</mark>，StringHttpMessageConverter，甚至还有<mark> FastJsonHttpMessageConverter</mark>（需导包和自己配置）</p><h2 id="基于jackson将对象转换为json"><a class="markdownIt-Anchor" href="#基于jackson将对象转换为json">#</a> 基于 Jackson 将对象转换为 json</h2><h3 id="1定义jsonobjectmapper类"><a class="markdownIt-Anchor" href="#1定义jsonobjectmapper类">#</a> 1，定义 JsonObjectMapper 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span></span><br><span class="line"><span class="comment"> * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span></span><br><span class="line"><span class="comment"> * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonObjectMapper</span> <span class="keyword">extends</span> <span class="title class_">ObjectMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;HH:mm:ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JacksonObjectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//收到未知属性时不报异常</span></span><br><span class="line">        <span class="built_in">this</span>.configure(FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化时，属性不存在的兼容处理</span></span><br><span class="line">        <span class="built_in">this</span>.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">simpleModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>()</span><br><span class="line">                .addDeserializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line"></span><br><span class="line">                .addSerializer(BigInteger.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(Long.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addSerializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addSerializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span></span><br><span class="line">        <span class="built_in">this</span>.registerModule(simpleModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-将转换器注册到mvc框架"><a class="markdownIt-Anchor" href="#2-将转换器注册到mvc框架">#</a> 2. 将转换器注册到 mvc 框架</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="comment">//创建消息转换器对象</span></span><br><span class="line">        <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">messageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        <span class="comment">//设置对象转换器，底层使用Jackson将Java对象转Json</span></span><br><span class="line">        messageConverter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">        <span class="comment">//将其加入到mvc框架的转换器集合中</span></span><br><span class="line">        converters.add(<span class="number">0</span>,messageConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决前后端交互long类型精度丢失问题"><a class="markdownIt-Anchor" href="#解决前后端交互long类型精度丢失问题">#</a> 解决前后端交互 Long 类型精度丢失问题</h2><p>一、现象与分析<br> 1.1. 现象<br>雪花算法得到的 ID 较长，传到前端后，精度丢失，导致更新、删除功能不可用</p><p>1.2. 分析<br>库中存的值：23754851322302474<br> 后端取的值：23754851322302474<br> 前端得到值：23754851322302470，数据被四舍五入了</p><p>二、解决方案</p><blockquote><p>将 Long 类型转成 String，再传给前端</p></blockquote><p>2.1. 方法一单个注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize(using= ToStringSerializer.class)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>2.2. 方法二统一配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一注解，解决前后端交互Long类型精度丢失的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ObjectMapper <span class="title function_">jacksonObjectMapper</span><span class="params">(Jackson2ObjectMapperBuilder builder)</span> &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> builder.createXmlMapper(<span class="literal">false</span>).build();</span><br><span class="line">        <span class="comment">//全局配置序列化返回json处理</span></span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">simpleModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>();</span><br><span class="line">        <span class="comment">//json Long ==&gt;String</span></span><br><span class="line">        simpleModule.addSerializer(Long.class, ToStringSerializer.instance);</span><br><span class="line">        objectMapper.registerModule(simpleModule);</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Springmvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中为什么不推荐使用字段注入</title>
      <link href="/2022/05/31/Spring%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/05/31/Spring%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用 Idea 中通过注解注入字段时是否遇见过这样一个提示：</p><p>Field injection is not recommended（不推荐使用字段注入）</p></blockquote><h2 id="一-什么是字段注入spring中依赖注入的方式有哪些"><a class="markdownIt-Anchor" href="#一-什么是字段注入spring中依赖注入的方式有哪些">#</a> 一。什么是字段注入，Spring 中依赖注入的方式有哪些？</h2><p>在 Spring 中依赖注入有三大类：字段注入、构造器注入、Setter 方法注入。</p><p>字段注入是将 Bean 作为字段注入到类中，也是最方便，用的最多的注入方式。</p><h2 id="二-官方为什么不推荐使用字段注入"><a class="markdownIt-Anchor" href="#二-官方为什么不推荐使用字段注入">#</a> 二。官方为什么不推荐使用字段注入</h2><h3 id="首先来看字段注入"><a class="markdownIt-Anchor" href="#首先来看字段注入">#</a> 首先来看字段注入</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestHandleController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    TestHandleService testHandleService;</span><br><span class="line"></span><br><span class="line">    public void helloTestService()&#123;</span><br><span class="line">        testHandleService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>字段注入的非常的简便，通过以上代码我们就可以轻松的使用 TestHandleService 类，但是如果变成下面这样呢：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TestHandleController testHandle = new TestHandleController();</span><br><span class="line">testHandle.helloTestService();</span><br></pre></td></tr></table></figure></blockquote><p>这样执行结果为空指针异常，这就是字段注入的第一个问题：** 对象的外部可见性，** 无法在容器外部实例化 TestHandleService（例如在测试类中无法注入该组件），类和容器的耦合度过高，无法脱离容器访问目标对象。</p><p>接下来看第二段代码：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestA()&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestB testB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestB()&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestA testA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这段代码在 idea 中不会报任何错误，但是当你启动项目时会发现报错，大致意思是：创建 Bean 失败，原因是当前 Bean 已经作为循环引用的一部分注入到了其他 Bean 中。</p><p>这就是字段注入的第二个问题：<strong>可能导致循环依赖</strong></p><p>字段注入还有第三个问题：** 无法设置注入的对象为 final，也无法注入静态变量，** 原因是变量必须在类实例化进行初始化。</p><p>整理一下，字段注入可能引起的三个问题：</p><ol><li><p><strong>对象的外部可见性</strong></p></li><li><p><strong>可能导致循环依赖</strong></p></li><li><p><strong>无法设置注入的对象为 final，也无法注入静态变量</strong></p></li></ol><hr><h3 id="接下来看构造器注入官方推荐的注入方式"><a class="markdownIt-Anchor" href="#接下来看构造器注入官方推荐的注入方式">#</a> 接下来看构造器注入–官方推荐的注入方式</h3><p>使用形式也很简单：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private TestHandleService testHandleService;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">public TestHandleController(TestHandleService testHandleService)&#123;</span><br><span class="line">    this.testHandleService = testHandleService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>通过构造器的方式将 Bean 注入到字段中。</p><p>构造器注入能够保证注入的组件不可变，并且确保需要的依赖不为空。</p><p>这样就可以将变量设置为 final，并且传递的肯定是一个对象，避免出现空指针异常。</p><p>若是出现字段注入中循环依赖的问题，在项目启动时 Spring 会非常形象的将错误抛出来：</p><blockquote><p>Description:</p><p>The dependencies of some of the beans in the application context form a cycle:</p><p>testContrtoller (field private com.example.designstudy.service.TestService com.example.designstudy.controller.TestContrtoller.testService)<br>┌─────┐<br>| testService defined in file [D:\design-study\target\classes\com\example\designstudy\service\TestService.class]<br>↑ ↓<br>| testHandleServiceImpl defined in file [D:\design-study\target\classes\com\example\designstudy\service\impl\TestHandleServiceImpl.class]<br>└─────┘</p></blockquote><p>显而易见的发现错误的地方。</p><p>由此可见，字段注入的三大问题都能解决，但是构造器注入就没有其他问题了吗？</p><p>答案肯定是否定的，当依赖的对象很多时，需要严格按照构造器的顺序去填写依赖的对象，这将导致代码可读性和可维护性变得很差。</p><p>这时候可以引入 Setter 方法进行注入，Setter 方法和构造器注入很像，不过 Setter 更具有可读性。</p><p>并且使用 Setter 方法注入可以实现按需注入，不使用的对象不需要想构造器注入一样强制注入。</p><p><strong>总结一下三种注入方式：</strong></p><blockquote><p><strong>构造器注入适用于强制对象注入</strong></p></blockquote><blockquote><p><strong>Setter 注入适合可选对象注入</strong></p></blockquote><blockquote><p><strong>字段注入方式应该尽量避免，因为对象无法脱离容器独立运行（话虽这么说，但我还是字段注入用得多，因为方便啊 [/ 狗头]）</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus分页插件配置</title>
      <link href="/2022/05/31/MybatisPlus%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/05/31/MybatisPlus%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>创建 MybatisPlus 配置类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置MP分页插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>service 层中增加方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中page是指定查询页数，pageSize是总页数，name是根据name模糊查询指定数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Page&lt;UserEntity&gt; <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize,String name)</span> &#123;</span><br><span class="line">       Page&lt;UserEntity&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">       LambdaQueryWrapper&lt;Employee&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       wrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);</span><br><span class="line">       page(pageInfo,wrapper);</span><br><span class="line">       <span class="keyword">return</span> pageInfo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>Controller 层中增加方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 员工信息分页查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page 查询页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 总页数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 条件查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Page</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;分页查询&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;Page&lt;Employee&gt;&gt; <span class="title function_">page</span><span class="params">(<span class="meta">@ApiParam(&quot;查询页&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@ApiParam(&quot;总页数&quot;)</span> <span class="type">int</span> pageSize,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@ApiParam(&quot;条件查询&quot;)</span> String name)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;page = &#123;&#125;,pageSize = &#123;&#125;,name = &#123;&#125;&quot;</span>,page,pageSize,name);</span><br><span class="line"></span><br><span class="line">        Page&lt;<span class="type">U</span> <span class="variable">pageInfo</span> <span class="operator">=</span> employeeService.getPage(page, pageSize, name);</span><br><span class="line">        <span class="keyword">return</span> R.success(pageInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MybatisPlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot热部署配置</title>
      <link href="/2022/05/30/SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/05/30/SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="使用devtool实现springboot热部署"><a class="markdownIt-Anchor" href="#使用devtool实现springboot热部署">#</a> 使用 devTool 实现 Springboot 热部署</h2><p>首先引入依赖项</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置 application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#设置开启热部署</span></span><br><span class="line">      <span class="attr">additional-paths:</span> <span class="string">src/main/java</span> <span class="comment">#重启目录</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">WEB-INF/**</span>  <span class="comment">#排除文件(不重启项目)</span></span><br><span class="line">    <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment">#不加载缓存</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用结果类R</title>
      <link href="/2022/05/30/%E9%A1%B9%E7%9B%AE/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/%E9%80%9A%E7%94%A8%E7%BB%93%E6%9E%9C%E7%B1%BBR/"/>
      <url>/2022/05/30/%E9%A1%B9%E7%9B%AE/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/%E9%80%9A%E7%94%A8%E7%BB%93%E6%9E%9C%E7%B1%BBR/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用返回结果类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">//编码：1成功，0和其它数字为失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//动态数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">success</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        R&lt;T&gt; r = <span class="keyword">new</span> <span class="title class_">R</span>&lt;T&gt;();</span><br><span class="line">        r.data = object;</span><br><span class="line">        r.code = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.msg = msg;</span><br><span class="line">        r.code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> R&lt;T&gt; <span class="title function_">add</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 瑞吉外卖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瑞吉外卖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvc静态资源路径注册</title>
      <link href="/2022/05/30/%E9%A1%B9%E7%9B%AE/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/mvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E6%B3%A8%E5%86%8C/"/>
      <url>/2022/05/30/%E9%A1%B9%E7%9B%AE/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/mvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC 默认的静态资源路径是 static，templates</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebMvcConfig extends WebMvcConfigurationSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:/backend/&quot;);</span><br><span class="line">        registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:/front/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 瑞吉外卖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瑞吉外卖 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day02-用户登录过滤器配置</title>
      <link href="/2022/05/30/%E9%A1%B9%E7%9B%AE/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/day02-%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%BF%87%E6%BB%A4%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/05/30/%E9%A1%B9%E7%9B%AE/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/day02-%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%BF%87%E6%BB%A4%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录过滤器</span></span><br><span class="line"><span class="comment"> * 检查用户是否已经完成登录</span></span><br><span class="line"><span class="comment"> * 未登录则拒绝访问部分页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;,urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">PATH_MATCHER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 获取本次请求的URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;拦截到请求：&quot;</span>+requestURI);</span><br><span class="line">        <span class="comment">//需要放行的资源</span></span><br><span class="line">        String[] urls = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                <span class="string">&quot;/employee/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/employee/logout&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/backend/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/front/**&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//2. 判断本次请求是否需要放行</span></span><br><span class="line">        <span class="keyword">if</span> (check(urls,requestURI)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求&quot;</span>+requestURI+<span class="string">&quot;被放行&quot;</span>);</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 判断登录状态，若已登录则放行</span></span><br><span class="line">        <span class="keyword">if</span> (request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>)!=<span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户已登录，用户id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 若未登录则返回登录结果，通过输出流方式向客户端页面响应数据</span></span><br><span class="line">        response.getWriter().write(JSON.toJSONString(R.error(<span class="string">&quot;NOTLOGIN&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径匹配，本次请求是否需要放行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestURI</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String[] urls,String requestURI)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls )&#123;</span><br><span class="line">            <span class="keyword">if</span> (PATH_MATCHER.match(url, requestURI)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要在 SpringBoot 启动类上增加 @ServletComponentScan 注解</strong></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 瑞吉外卖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 过滤器 </tag>
            
            <tag> 瑞吉外卖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存穿透与雪崩</title>
      <link href="/2022/05/21/Redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/"/>
      <url>/2022/05/21/Redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="redis缓存穿透与雪崩"><a class="markdownIt-Anchor" href="#redis缓存穿透与雪崩">#</a> Redis 缓存穿透与雪崩</h2><p>Redis 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询仿麦呢，但同时，它也带来了，它也带来了一些问题。其中，最要害的问题，就是数据一致性问题，从严格意义上讲，这个问题无解，如果对数据的一致性要求很高，那么就不能使用缓存</p><p>另外的一些经典问题就是，缓存穿透，缓存雪崩和缓存击穿，目前，业界也有一些比较流行的解决方案</p><h3 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透">#</a> 缓存穿透</h3><blockquote><p>概念</p></blockquote><p>用户想要查询一个数据，发现 redis 内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败，当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给数据库造成很大压力，相当于缓存穿透</p><blockquote><p>解决方案</p></blockquote><ul><li>布隆过滤器</li></ul><p>布隆过滤器是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力</p><p><img src="/2022/05/21/Redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWlpZU1l-,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><ul><li>缓存空对象</li></ul><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源</p><p><img src="/2022/05/21/Redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWlpZU1l-,size_20,color_FFFFFF,t_70,g_se,x_16-16531038930102.png" alt="在这里插入图片描述"></p><p><strong>但是这种方法会存在两个问题：</strong></p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h3 id="缓存击穿量太大缓存过期"><a class="markdownIt-Anchor" href="#缓存击穿量太大缓存过期">#</a> 缓存击穿（量太大，缓存过期）</h3><blockquote><p>概念</p></blockquote><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞<br>当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><blockquote><p>解决方案</p></blockquote><ul><li>设置热点数据永不过期</li></ul><p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p><ul><li>加互斥锁</li></ul><p>分布式锁∶使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><p><img src="/2022/05/21/Redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWlpZU1l-,size_20,color_FFFFFF,t_70,g_se,x_16-16531040925354.png" alt="在这里插入图片描述"></p><h3 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩">#</a> 缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机</p><p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况</p><p><img src="/2022/05/21/Redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWlpZU1l-,size_20,color_FFFFFF,t_70,g_se,x_16-16531041697446.png" alt="在这里插入图片描述"></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。<br><strong>（双十一：停掉一些服务，保证主要服务可用）</strong></p><blockquote><p>解决方案</p></blockquote><ul><li>redis 高可用</li></ul><p>这个思想的含义是，既然 redis 有可能挂掉，那我多增设几台 redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活）</p><ul><li>限流降级</li></ul><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</p><ul><li>数据预热</li></ul><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制</title>
      <link href="/2022/05/21/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2022/05/21/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="redis主从复制"><a class="markdownIt-Anchor" href="#redis主从复制">#</a> Redis 主从复制</h2><p>主从复制，是指将一台 Redis 服务器的数据，复制到其他 Redis 服务器，前者称为主节点 (master/leader), 后者称为从节点 (slave/follower), 数据的复制是单向的，只能由主节点到从节点，<strong>Master 以写为主，slave 以读为主</strong></p><p><strong>主从复制的作用：</strong></p><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个结点分担读负载，可以大大提高 Redis 服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础</li></ol><p>一般来说，要将 Redis 应用于工程项目中，只使用一台 Redis 是玩玩不可的，原因如下</p><ol><li>从结构上，单个 Redis 服务器会发生单点 故障，并且一台服务器需要处理所有的请求负载，压力较大；</li><li>从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量为 256G，也不能将所有内存用作 Redis 存储内存，一般来说，单台 Redis 最大使用内存不应该超过 20G</li></ol><p>电商网站上的商品，一般都是一次上传，数次浏览，也就是多读少写</p><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置">#</a> 环境配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication #查看当前库的信息</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master # 角色</span><br><span class="line">connected_slaves:0 # 从机数量</span><br><span class="line">master_replid:12673735635e5cedc1e668b27e7a83855086ab0c</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><h3 id="windows环境下配置"><a class="markdownIt-Anchor" href="#windows环境下配置">#</a> windows 环境下配置</h3><ul><li>复制 Redis 安装主文件夹</li><li>此处采用一主二从</li></ul><p><img src="/2022/05/21/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20220521101305709.png" alt="image-20220521101305709"></p><blockquote><ol><li>分别进入文件夹</li></ol><p>修改 redis.windows.conf 和 redis.windows-service.conf 中的端口信息</p><p>port 6380</p><p>slaveof 127.0.0.1 6379</p><ol start="2"><li>然后在 cmd 中安装服务</li></ol><p>redis-server --service-install redis.windows.conf --maxmemory 200m --service-name redis6380</p><p>redis-server --service-install redis.windows.conf --maxmemory 200m --service-name redis6381</p></blockquote><p><img src="/2022/05/21/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20220521101705547.png" alt="image-20220521101705547"></p><h2 id="一主二从"><a class="markdownIt-Anchor" href="#一主二从">#</a> 一主二从</h2><p><font color="red">默认情况下每台 Redis 服务器都是主节点 </font> 配置从机</p><ol><li>命令 slave 127.0.0.1    6379  #配置主机</li><li>改写配置文件</li></ol><p><strong>从机只读不写</strong></p><p>如果主机宕机，从机仍然可以读到数据</p><blockquote><p>复制原理</p></blockquote><p>Slave 启动成功连接到 master 后会发送一个 sync 命令</p><p>Master 接到命令后，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕后，master 将传送整个数据文件到 slave，并完成一次完全同步</p><p>全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中</p><p>增量复制，Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步</p><p>但是只要是重新连接 master，一次完全同步（全量复制）将被自动执行</p><blockquote><p>如果主机宕机，重新选择主句</p></blockquote><p>如果主机断开连接，可以使用 slaveof  no one 让自己变成主机。其他的结点就可以手动连接到最新的这个主节点（手动）。</p><h2 id="哨兵模式"><a class="markdownIt-Anchor" href="#哨兵模式">#</a> 哨兵模式</h2><blockquote><p>概述</p></blockquote><p>在 Redis 主从复制模式中，因为系统不具备自动恢复的功能，所以当主服务器（master）宕机后，需要手动把一台从服务器（slave）切换为主服务器。在这个过程中，不仅需要人为干预，而且还会造成一段时间内服务器处于不可用状态，同时数据安全性也得不到保障，因此主从模式的可用性较低，不适用于线上生产环境。</p><p>Redis 官方推荐一种高可用方案，也就是 Redis Sentinel 哨兵模式，它弥补了主从模式的不足。Sentinel 通过监控的方式获取主机的工作状态是否正常，当主机发生故障时， Sentinel 会自动进行 Failover（即故障转移），并将其监控的从机提升主服务器（master），从而保证了系统的高可用性。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理">#</a> 原理</h3><p>哨兵模式是一种特殊的模式，Redis 为其提供了专属的哨兵命令，它是一个独立的进程，能够独立运行。下面使用 Sentinel 搭建 Redis 集群，基本结构图如下所示：</p><p><img src="/2022/05/21/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1K00M955-0.gif" alt="哨兵模式"></p><blockquote><p>哨兵模式的作用</p></blockquote><ul><li>第一：哨兵节点会以每秒一次的频率对每个 Redis 节点发送 <code>PING</code>  命令，并通过 Redis 节点的回复来判断其运行状态。</li><li>第二：当哨兵监测到主服务器发生故障时，会自动在从节点中选择一台将机器，并其提升为主服务器，然后使用 PubSub 发布订阅模式，通知其他的从节点，修改配置文件，跟随新的主服务器。</li></ul><blockquote><p>多哨兵模式</p></blockquote><p>在实际生产情况中，Redis Sentinel 是集群的高可用的保障，为避免 Sentinel 发生意外，它一般是由 3～5 个节点组成，这样就算挂了个别节点，该集群仍然可以正常运转。其结构图如下所示：</p><p><img src="/2022/05/21/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1K00HQ5-1.gif" alt="Redis哨兵模式"></p><p>上图所示，多个哨兵之间也存在互相监控，这就形成了多哨兵模式，现在对该模式的工作过程进行讲解，介绍如下：</p><ol><li><strong>主观下线</strong></li></ol><p>主观下线，适用于主服务器和从服务器。如果在规定的时间内 (配置参数：down-after-milliseconds)，Sentinel 节点没有收到目标服务器的有效回复，则判定该服务器为 “主观下线”。比如 Sentinel1 向主服务发送了 <code>PING</code>  命令，在规定时间内没收到主服务器 <code>PONG</code>  回复，则 Sentinel1 判定主服务器为 “主观下线”。</p><ol start="2"><li><strong>客观下线</strong></li></ol><p>客观下线，只适用于主服务器。 Sentinel1 发现主服务器出现了故障，它会通过相应的命令，询问其它 Sentinel 节点对主服务器的状态判断。如果超过半数以上的 Sentinel 节点认为主服务器 down 掉，则 Sentinel1 节点判定主服务为 “客观下线”。</p><ol start="3"><li><strong>投票选举</strong></li></ol><p>投票选举，所有 Sentinel 节点会通过投票机制，按照谁发现谁去处理的原则，选举 Sentinel1 为领头节点去做 Failover（故障转移）操作。Sentinel1 节点则按照一定的规则在所有从节点中选择一个最优的作为主服务器，然后通过发布订功能通知其余的从节点（slave）更改配置文件，跟随新上任的主服务器（master）。至此就完成了主从切换的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis发布订阅</title>
      <link href="/2022/05/21/Redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
      <url>/2022/05/21/Redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
      
        <content type="html"><![CDATA[<h2 id="redis发布订阅"><a class="markdownIt-Anchor" href="#redis发布订阅">#</a> Redis 发布订阅</h2><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="/2022/05/21/Redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/pubsub1.png" alt="img"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/2022/05/21/Redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/pubsub2.png" alt="img"></p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例">#</a> 实例</h2><p>以下实例演示了发布订阅是如何工作的，需要开启两个 redis-cli 客户端。</p><p>在我们实例中我们创建了订阅频道名为 <strong>runoobChat</strong>:</p><p><strong>第一个 redis-cli 客户端</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE runoobChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;runoobChat&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。</p><p><strong>第二个 redis-cli 客户端</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>订阅者的客户端会显示如下消息</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) &quot;message&quot; #消息</span><br><span class="line">2) &quot;runoobChat&quot; #订阅</span><br><span class="line">3) &quot;Redis PUBLISH test&quot; #消息详情</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;runoobChat&quot;</span><br><span class="line">3) &quot;Learn redis by runoob.com&quot;</span><br></pre></td></tr></table></figure><h2 id="命令"><a class="markdownIt-Anchor" href="#命令">#</a> 命令</h2><ol><li>psubscribe pattern [pattern…]<ul><li>订阅一个或多个符合给定模式的频道</li></ul></li><li>pubsub subcommand [argument [argument…]]<ul><li>查看订阅与发布系统状态</li></ul></li><li>publish channel message<ul><li>将消息发送到指定的频道</li></ul></li><li>punsubscribe channel message<ul><li>将消息发送到指定的频道</li></ul></li><li>subscribe channel [channel…]<ul><li>订阅给定的一个或多个频道的消息</li></ul></li><li>unsubscribe [channel[channel…]]<ul><li>退订频道</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化_AOF</title>
      <link href="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-AOF/"/>
      <url>/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-AOF/</url>
      
        <content type="html"><![CDATA[<h2 id="redis持久化操作之aofappend-on-file"><a class="markdownIt-Anchor" href="#redis持久化操作之aofappend-on-file">#</a> Redis 持久化操作之 AOF（Append On File)</h2><p>​以独立日志的方式记录每次写命令，并在 Redis 重启时再重新执行 AOF 文件中的命令以达到恢复数据的目的。主要作用是解决数据持久化的实时性</p><h2 id="rdb和aof"><a class="markdownIt-Anchor" href="#rdb和aof">#</a> RDB 和 AOF</h2><p>antirez 在《Redis 持久化解密》一文中讲述了 RDB 和 AOF 各自的优缺点：</p><ul><li>RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据备份。非常适合备份，全量复制等场景。比如每 6 小时执行 bgsave 备份，并把 RDB 文件拷贝到远程机器或者文件系统中，用于灾难恢复。</li><li>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</li><li>RDB 方式数据没办法做到实时持久化，而 AOF 方式可以做到。</li></ul><h2 id="aof持久化流程"><a class="markdownIt-Anchor" href="#aof持久化流程">#</a> AOF 持久化流程</h2><ol><li><p>写入缓存：每次执行命令后，进行 append 操作写入 AOF 缓存</p></li><li><p>同步磁盘：AOF 缓冲区根据对应的策略向硬盘进行同步操作。</p></li><li><p>AOF 重写：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</p></li><li><p>重启加载： 当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</p></li></ol><p><img src="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-AOF/image-20220520140702861.png" alt="image-20220520140702861"></p><p><mark>默认不开启</mark></p><h2 id="aof重写"><a class="markdownIt-Anchor" href="#aof重写">#</a> AOF 重写</h2><p>因为 AOF 持久化是通过保存被执行的写命令来记录 Redis 状态的，所以随着 Redis 长时间运行，AOF 文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的 AOF 文件很可能对 Redis 甚至宿主计算机造成影响。</p><p>为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写 (rewrite) 功能。通过该功能，Redis 可以创建一个新的 AOF 文件来替代现有的 AOF 文件。新旧两个 AOF 文件所保存的 Redis 状态相同，但是新的 AOF 文件不会包含任何浪费空间的荣誉命令，所以新 AOF 文件的体积通常比旧 AOF 文件的体积要小得很多。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="comment"># Redis is able to automatically rewrite the log file implicitly calling</span></span><br><span class="line"><span class="comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span><br><span class="line"><span class="comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span></span><br><span class="line"><span class="comment"># the AOF at startup is used).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This base size is compared to the current size. If the current size is</span></span><br><span class="line"><span class="comment"># bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span></span><br><span class="line"><span class="comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span></span><br><span class="line"><span class="comment"># is reached but it is still pretty small.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify a percentage of zero in order to disable the automatic AOF</span></span><br><span class="line"><span class="comment"># rewrite feature.</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure><p><img src="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-AOF/ca3fed21bad23c649026bd4565476d1e.png" alt="img"></p><p>如上图所示，重写前要记录名为  <code>list</code>  的键的状态，AOF 文件要保存五条命令，而重写后，则只需要保存一条命令。</p><p>AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，而是通过读取服务器当前的数据库状态来实现的。首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是 AOF 重写功能的实现原理。</p><p>在实际过程中，为了避免在执行命令时造成客户端输入缓冲区溢出，AOF 重写在处理列表、哈希表、集合和有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果数量超过 REDISAOFREWRITEITEMSPER_CMD (一般为 64) 常量，则使用多条命令记录该键的值，而不是一条命令。</p><p>rewrite 的触发机制主要有一下三个：</p><ul><li>手动调用 bgrewriteaof 命令，如果当前有正在运行的 rewrite 子进程，则本次 rewrite 会推迟执行，否则，直接触发一次 rewrite。</li><li>通过配置指令手动开启 AOF 功能，如果没有 RDB 子进程的情况下，会触发一次 rewrite，将当前数据库中的数据写入 rewrite 文件。</li><li>在 Redis 定时器中，如果有需要退出执行的 rewrite 并且没有正在运行的 RDB 或者 rewrite 子进程时，触发一次或者 AOF 文件大小已经到达配置的 rewrite 条件也会自动触发一次。</li></ul><h2 id="aof的优缺点"><a class="markdownIt-Anchor" href="#aof的优缺点">#</a> AOF 的优缺点</h2><p><strong>优点：</strong></p><ul><li>每一次修改都同步，文件的完整性更好</li><li>每秒同步一次，可能会丢失疫苗的数据</li><li>从不同步，效率高</li></ul><p><strong>缺点：</strong></p><ul><li>相对于数据文件来说，aof 远远大于 rdb，修复速度也比 rdb 慢</li><li>aof 运行效率也比 rdb 慢，所以 redis 默认的配置是 rdb 持久化</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化_RDB</title>
      <link href="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/"/>
      <url>/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/</url>
      
        <content type="html"><![CDATA[<h2 id="持久化操作之rdbredis-database"><a class="markdownIt-Anchor" href="#持久化操作之rdbredis-database">#</a> 持久化操作之 RDB（Redis DataBase）</h2><p>redis 是内存数据库，如果不将内存中的数据保存到磁盘，那么一旦服务器进程退出，服务器中的数据状态也会消失，所以 redis 提供了持久化的功能</p><p>原理是 redis 会单独创建（fork）一个与当前线程一模一样的子进程来进行持久化，这个子线程的所有数据（变量。环境变量，程序程序计数器等）都和原进程一模一样，会先将数据写入到一个临时文件中，待持久化结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程不进行任何的 io 操作，这就确保了极高的性能。</p><p>我们默认的就是 RDB，一般情况下不需要修改这个配置</p><p>如果需要进行大规模数据恢复，且对于数据的完整性回复不是非常的敏感，那么 RDB 方式比 AOF 的方式更加高效。RDb 的缺点是<strong>最后一次持久化的数据可能会丢失</strong><br> rdb 保存的文件是<mark> dump.rdb</mark></p><h2 id="rdb快照模式原理"><a class="markdownIt-Anchor" href="#rdb快照模式原理">#</a> RDB 快照模式原理</h2><p>RDB 即快照模式，它是 Redis 默认的数据持久化方式，它会将数据库的快照保存在 dump.rdb 这个二进制文件中。</p><blockquote><p>提示：所谓 “快照” 就是将内存数据以二进制文件的形式保存起来。</p></blockquote><p>我们知道 Redis 是单线程的，也就说一个线程要同时负责多个客户端套接字的并发读写，以及内存数据结构的逻辑读写。</p><p>Redis 服务器不仅需要服务线上请求，同时还要备份内存快照。在备份过程中 Redis 必须进行文件 IO 读写，而 IO 操作会严重服务器的性能。那么如何实现既不影响客户端的请求，又实现快照备份操作呢，这时就用到了多进程。</p><p>Redis 使用操作系统的多进程 COW (Copy On Write) 机制来实现快照持久化操作。</p><p>RDB 实际上是 Redis 内部的一个定时器事件，它每隔一段固定时间就去检查当前数据发生改变的次数和改变的时间频率，看它们是否满足配置文件中规定的持久化触发条件。当满足条件时，Redis 就会通过操作系统调用 fork () 来创建一个子进程，该子进程与父进程享有相同的地址空间。</p><p>Redis 通过子进程遍历整个内存空间来获取存储的数据，从而完成数据持久化操作。注意，此时的主进程则仍然可以对外提供服务，父子进程之间通过操作系统的 COW 机制实现了数据段分离，从而保证了父子进程之间互不影响。</p><h2 id="rdb持久化触发策略"><a class="markdownIt-Anchor" href="#rdb持久化触发策略">#</a> RDB 持久化触发策略</h2><h3 id="1手动触发策略"><a class="markdownIt-Anchor" href="#1手动触发策略">#</a> 1）手动触发策略</h3><p>手动触发是通过 == <code>SAVAE</code> <mark> 命令或者</mark> <code>BGSAVE</code> == 命令将内存数据保存到磁盘文件中。如下所示：</p><p>(== <code>Lastsave</code> == 命令用于查看 BGSAVE 命令是否执行成功)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SAVE</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started</span><br><span class="line">127.0.0.1:6379&gt;  LASTSAVE</span><br><span class="line">(integer) 1611298430</span><br></pre></td></tr></table></figure><p>SAVE 命令会阻塞 Redis 服务器进程，直到 dump.rdb 文件创建完毕为止，在这个过程中，服务器不能处理任何的命令请求。</p><p><code>BGSAVE</code>  命令是非阻塞式的，所谓非阻塞式，指的是在该命令执行的过程中，并不影响 Redis 服务器处理客户端的其他请求。这是因为 Redis 服务器会 fork () 一个子进程来进行持久化操作（比如创建新的 dunp.rdb 文件），而父进程则继续处理客户端请求。当子进程处理完后会向父进程发送一个信号，通知它已经处理完毕。此时，父进程会用新的 dump.rdb 文件<strong>覆盖掉原来的旧文件</strong>。</p><p>因为 <code>SAVE</code>  命令无需创建子进程，所以执行速度要略快于 <code>BGSAVE</code>  命令，但是 <code>SAVE</code>  命令是阻塞式的，因此其可用性欠佳，如果在数据量较少的情况下，基本上体会不到两个命令的差别，不过仍然建议您使用  <code>BGSAVE</code>  命令。</p><h3 id="3自动触发策略"><a class="markdownIt-Anchor" href="#3自动触发策略">#</a> 3）自动触发策略</h3><p>自动触发策略，是指 Redis 在指定的时间内，数据发生了多少次变化时，会自动执行 <code>BGSAVE</code>  命令。自动触发的条件包含在了 Redis 的配置文件中，如下所示：</p><p>搜索 snapshot</p><p><img src="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODQxMjg0Ng==,size_16,color_FFFFFF,t_70-16530255128282.png" alt="在这里插入图片描述"></p><p><img src="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/2021040519580770.png" alt="在这里插入图片描述"></p><p>删除 dump.rdb 文件</p><p><img src="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/20210405200110446.png" alt="在这里插入图片描述"></p><p>一分钟内设置 5 次 key，自动生成 dump.rdb 文件</p><p><img src="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODQxMjg0Ng==,size_16,color_FFFFFF,t_70-16530255548305-16530255563167.png" alt="在这里插入图片描述"></p><p><img src="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/20210405200611422.png" alt="在这里插入图片描述"></p><p><img src="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODQxMjg0Ng==,size_16,color_FFFFFF,t_70-16530256237909-165302562609811.png" alt="在这里插入图片描述"></p><p>进程被占用，重启云服务器</p><p><strong>触发机制</strong><br> 1. 满足 save 规则<br> 2. 执行 flushdb 命令<br> 3. 退出 redis，都会产生 rdb 文件</p><p><strong>如何恢复 rdb 文件</strong><br> 1. 只需要将 rdb 文件放在 redis 启动目录就可以，redis 启动时就会自动检测 dum.rdb 文件，恢复其中数据<br> 2.rdb 文件存放的位置</p><p><strong>优点:</strong><br>1. 适合大规模的数据恢复<br> 2. 对数据的完整性要求不高<br><strong>缺点</strong><br> 1. 需要一定时间间隔进程操作，如果 redis 意外宕机，这个最后一次修改的数据就没了<br> 2.fork 进程的时候，会占用一定的内存空间</p><p>因此有时候生产环境会将这个文件备份</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis配置文件详解</title>
      <link href="/2022/05/19/Redis/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/05/19/Redis/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> .\path\to\local.conf</span><br><span class="line"><span class="keyword">include</span> c:\path\to\other.conf</span><br></pre></td></tr></table></figure><p>额外载入配置文件，如果需要的话，可以开启此配置</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">bind <span class="number">192.168</span>.<span class="number">1.100</span> <span class="number">10.0</span>.<span class="number">0.1</span></span><br><span class="line">bind <span class="number">127.0</span>.<span class="number">0.1</span> ::<span class="number">1</span></span><br></pre></td></tr></table></figure><p>绑定 redis 服务器网卡 IP，默认为 127.0.0.1, 即本地回环地址。这样的话，访问 redis 服务只能通过本机的客户端连接，而无法通过远程连接。如果 bind 选项为空的话，那会接受所有来自于可用网络接口的连接。如上配置，绑定一个 127.0.0.1 的本机地址和 192.168.1.100 的外网地址。</p><p>默认情况下，如果没有指定 “绑定” 配置指令，Redis 会侦听来自服务器上所有可用网络接口的连接。可以使用 “绑定” 配置指令仅监听一个或多个选定的接口，然后是一个或多个 IP 地址。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>-mode yes</span><br></pre></td></tr></table></figure><p>保护模式，默认是开启状态，只允许本地客户端连接， 可以设置密码或添加 bind 来连接</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">port <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>监听端口号，默认 6379.</p><p>若设置为 0，redis 将不在 socket 上监听任何客户端的连接</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">tcp-backlog <span class="number">511</span></span><br></pre></td></tr></table></figure><p>TCP 监听的最大容纳数量，在高并发环境下需要调高这个值以避免连接缓慢。</p><p>Linux 内核会把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值，要提高并发量需要修改这两个值才能达到目的</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">timeout <span class="number">0</span></span><br></pre></td></tr></table></figure><p>指定在一个 client 空闲多少秒之后关闭连接（0 表示永不关闭）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">tcp-keepalive <span class="number">300</span></span><br></pre></td></tr></table></figure><p>单位是秒，表示将周期性的使用 SO_KEEPALIVE 检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是 300s，如果设置为 0，则不会周期性的检测</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">loglevel notice</span><br></pre></td></tr></table></figure><p>定义日志级别。<br>可以是下面的这些值：</p><ol><li>debug（记录大量日志信息，适用于开发、测试阶段）</li><li>verbose（较多日志信息）</li><li>notice（适量日志信息，使用于生产环境）</li><li>warning（仅有部分重要、关键信息才会被记录）</li></ol><ul><li>line 165</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">logfile <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>日志文件的位置，当指定为空字符串时，为标准输出，如果 redis 已守护进程模式运行，那么日志将会输出到 /dev/null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syslog-enabled no</span><br></pre></td></tr></table></figure><p>要想把日志记录到系统日志，就把它改成 yes，也可以可选择性的更新其他的 syslog 参数以达到你的要求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syslog-ident redis</span><br></pre></td></tr></table></figure><p>设置系统日志的 ID</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syslog-facility local0</span><br></pre></td></tr></table></figure><p>指定系统日志设置，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure><p>设置数据库的数目。默认的数据库是 DB 0 ，可以在每个连接上使用 select <dbid> 命令选择一个不同的数据库，dbid 是一个介于 0 到 databases - 1 之间的数值。</dbid></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>存 DB 到磁盘：<br>格式：save &lt;间隔时间（秒）&gt; &lt; 写入次数 &gt;<br> 根据给定的时间间隔和写入次数将数据保存到磁盘<br>下面的例子的意思是：<br>900 秒内如果至少有 1 个 key 的值变化，则保存<br> 300 秒内如果至少有 10 个 key 的值变化，则保存<br> 60 秒内如果至少有 10000 个 key 的值变化，则保存<br>　<br>注意：你可以注释掉所有的 save 行来停用保存功能。<br>也可以直接一个空字符串来实现停用：<br>save “”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop-writes-on-bgsave-error yes</span><br></pre></td></tr></table></figure><p>如果用户开启了 RDB 快照功能，那么在 redis 持久化数据到磁盘时如果出现失败，默认情况下，redis 会停止接受所有的写请求。<br>这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。<br>如果 redis 不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。<br>如果下一次 RDB 持久化成功，redis 会自动恢复接受写请求。<br>如果不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，可以关闭这个功能，<br>以便在快照写入失败时，也能确保 redis 继续接受新的写请求。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。<br>如果是的话，redis 会采用 LZF 算法进行压缩。如果你不想消耗 CPU 来进行压缩的话，<br>可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><p>在存储快照后，我们还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，<br>如果希望获取到最大的性能提升，可以关闭此功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure><p>设置快照的文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /var/redis/6379</span><br></pre></td></tr></table></figure><p>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>主从复制，使用 slaveof 来让一个 redis 实例成为另一个 reids 实例的副本，默认关闭<br>注意这个只需要在 slave 上配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure><p>如果 master 需要密码认证，就在这里设置，默认不设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-serve-stale-data yes</span><br></pre></td></tr></table></figure><p>当一个 slave 与 master 失去联系，或者复制正在进行的时候，<br>slave 可能会有两种表现：<br>\1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，<br>或者数据可能是空的在第一次同步的时候<br> \2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，<br>slave 都将返回一个 “SYNC with master in progress” 的错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure><p>你可以配置一个 slave 实体是否接受写入操作。<br>通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，<br>因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。<br>但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。<br>从 redis 2.6 版起，默认 slaves 都是只读的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync no</span><br></pre></td></tr></table></figure><p>主从数据复制是否使用无硬盘复制功能。<br>新的从站和重连后不能继续备份的从站，需要做所谓的 “完全备份”，即将一个 RDB 文件从主站传送到从站。<br>这个传送有以下两种方式：<br>1）硬盘备份：redis 主站创建一个新的进程，用于把 RDB 文件写到硬盘上。过一会儿，其父进程递增地将文件传送给从站。<br>2）无硬盘备份：redis 主站创建一个新的进程，子进程直接把 RDB 文件写到从站的套接字，不需要用到硬盘。<br>在硬盘备份的情况下，主站的子进程生成 RDB 文件。一旦生成，多个从站可以立即排成队列使用主站的 RDB 文件。<br>在无硬盘备份的情况下，一次 RDB 传送开始，新的从站到达后，需要等待现在的传送结束，才能开启新的传送。<br>如果使用无硬盘备份，主站会在开始传送之间等待一段时间（可配置，以秒为单位），希望等待多个子站到达后并行传送。<br>在硬盘低速而网络高速（高带宽）情况下，无硬盘备份更好。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure><p>当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送 RDB 文件，这个等待时间是可配置的。<br>这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次 RDB 传送。因此服务器等待一段<br>时间以期更多的从站到达。<br>延迟时间以秒为单位，默认为 5 秒。要关掉这一功能，只需将它设置为 0 秒，传送会立即启动。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-ping-slave-period 10</span><br></pre></td></tr></table></figure><p>从 redis 会周期性的向主 redis 发出 PING 包，你可以通过 repl_ping_slave_period 指令来控制其周期，默认是 10 秒。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-timeout 60</span><br></pre></td></tr></table></figure><p>接下来的选项为以下内容设置备份的超时时间：<br>1）从从站的角度，同步期间的批量传输的 I/O<br>2）从站角度认为的主站超时（数据，ping）<br>3）主站角度认为的从站超时（REPLCONF ACK pings)<br> 确认这些值比定义的 repl-ping-slave-period 要大，否则每次主站和从站之间通信低速时都会被检测为超时。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-disable-tcp-nodelay no</span><br></pre></td></tr></table></figure><p>同步之后是否禁用从站上的 TCP_NODELAY<br> 如果你选择 yes，redis 会使用较少量的 TCP 包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。<br>Linux 内核默认配置情况下最多 40 毫秒的延时。<br>如果选择 no，从站的数据延时不会那么多，但备份需要的带宽相对较多。<br>默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为 yes 是个好主意。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure><p>设置备份的工作储备大小。工作储备是一个缓冲区，当从站断开一段时间的情况时，它替从站接收存储数据，<br>因此当从站重连时，通常不需要完全备份，只需要一个部分同步就可以，即把从站断开时错过的一部分数据接收。<br>工作储备越大，从站可以断开并稍后执行部分同步的断开时间就越长。<br>只要有一个从站连接，就会立刻分配一个工作储备。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-backlog-ttl 3600</span><br></pre></td></tr></table></figure><p>主站有一段时间没有与从站连接，对应的工作储备就会自动释放。<br>这个选项用于配置释放前等待的秒数，秒数从断开的那一刻开始计算，值为 0 表示不释放。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-priority 100</span><br></pre></td></tr></table></figure><p>从站优先级是可以从 redis 的 INFO 命令输出中查到的一个整数。当主站不能正常工作时<br> redis sentinel 使用它来选择一个从站并将它提升为主站。<br>低优先级的从站被认为更适合于提升，因此如果有三个从站优先级分别是 10，<br>100，25，sentinel 会选择优先级为 10 的从站，因为它的优先级最低。<br>然而优先级值为 0 的从站不能执行主站的角色，因此优先级为 0 的从站永远不会被 redis sentinel 提升。<br>默认优先级是 100</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>主站可以停止接受写请求，当与它连接的从站少于 N 个，滞后少于 M 秒，N 个从站必须是在线状态。<br>延迟的秒数必须 &lt;= 所定义的值，延迟秒数是从最后一次收到的来自从站的 ping 开始计算。ping 通常是每秒一次。<br>这一选项并不保证 N 个备份都会接受写请求，但是会限制在指定秒数内由于从站数量不够导致的写操作丢失的情况。<br>如果想要至少 3 个从站且延迟少于 10 秒，如上配置即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-announce-ip 5.5.5.5</span><br><span class="line">slave-announce-port 1234</span><br></pre></td></tr></table></figure><p>Redis master 能够以不同的方式列出所连接 slave 的地址和端口。<br>例如，“INFO replication” 部分提供此信息，除了其他工具之外，Redis Sentinel 还使用该信息来发现 slave 实例。<br>此信息可用的另一个地方在 masterser 的 “ROLE” 命令的输出中。<br>通常由 slave 报告的列出的 IP 和地址，通过以下方式获得：<br>IP：通过检查 slave 与 master 连接使用的套接字的对等体地址自动检测地址。<br>端口：端口在复制握手期间由 slavet 通信，并且通常是 slave 正在使用列出连接的端口。<br>然而，当使用端口转发或网络地址转换（NAT）时，slave 实际上可以通过 (不同的 IP 和端口对) 来到达。 slave 可以使用以下两个选项，以便向 master 报告一组特定的 IP 和端口，<br>以便 INFO 和 ROLE 将报告这些值。<br>如果你需要仅覆盖端口或 IP 地址，则没必要使用这两个选项。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requirepass foobared</span><br></pre></td></tr></table></figure><p>设置 redis 连接密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename-command CONFIG &quot;&quot;</span><br></pre></td></tr></table></figure><p>将命令重命名，为了安全考虑，可以将某些重要的、危险的命令重命名。<br>当你把某个命令重命名成空字符串的时候就等于取消了这个命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxclients 10000</span><br></pre></td></tr></table></figure><p>设置客户端最大并发连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件<br>描述符数 - 32（redis server 自身会使用一些），如果设置 maxclients 为 0<br> 表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure><p>指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key<br> 当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，<br>会把 Key 存放内存，Value 会存放在 swap 区，格式：maxmemory <bytes></bytes></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory-policy noeviction</span><br></pre></td></tr></table></figure><p>当内存使用达到最大值时，redis 使用的清楚策略。有以下几种可以选择：<br>1）volatile-lru  利用 LRU 算法移除设置过过期时间的 key (LRU: 最近使用 Least Recently Used)<br> 2）allkeys-lru  利用 LRU 算法移除任何 key<br>3）volatile-random 移除设置过过期时间的随机 key<br>4）allkeys-random 移除随机 ke<br>5）volatile-ttl  移除即将过期的 key (minor TTL)<br> 6）noeviction noeviction  不移除任何 key，只是返回一个写错误 ，默认选项</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure><p>LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法 (为了节省内存)<br> 随意你可以选择样本大小进行检，redis 默认选择 3 个样本进行检测，你可以通过 maxmemory-samples 进行设置样本数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure><p>默认 redis 使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了。但是 redis 如果中途宕机，<br>会导致可能有几分钟的数据丢失，根据 save 来策略进行持久化，Append Only File 是另一种持久化方式，<br>可以提供更好的持久化特性。Redis 会把每次写入的数据在接收后都写入 appendonly.aof 文件，<br>每次启动时 Redis 都会先把这个文件的数据读入内存里，先忽略 RDB 文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><p>aof 文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p>aof 持久化策略的配置<br> no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快。<br>always 表示每次写入都执行 fsync，以保证数据同步到磁盘。<br>everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no-appendfsync-on-rewrite no</span><br></pre></td></tr></table></figure><p>在 aof 重写或者写入 rdb 文件的时候，会执行大量 IO，此时对于 everysec 和 always 的 aof 模式来说，<br>执行 fsync 会造成阻塞过长时间，no-appendfsync-on-rewrite 字段设置为默认设置为 no。<br>如果对延迟要求很高的应用，这个字段可以设置为 yes，否则还是设置为 no，这样对持久化特性来说这是更安全的选择。<br>设置为 yes 表示 rewrite 期间对新写操作不 fsync, 暂时存在内存中，等 rewrite 完成后再写入，默认为 no，建议 yes。<br>Linux 的默认 fsync 策略是 30 秒。可能丢失 30 秒数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure><p>aof 自动重写配置，当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写，<br>即当 aof 文件增长到一定大小的时候，Redis 能够调用 bgrewriteaof 对日志文件进行重写。<br>当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍（设置为 100）时，自动启动新的日志重写过程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>设置允许重写的最小 aof 文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure><p>aof 文件可能在尾部是不完整的，当 redis 启动的时候，aof 文件的数据被载入内存。<br>重启可能发生在 redis 所在的主机操作系统宕机后，尤其在 ext4 文件系统没有加上 data=ordered 选项，出现这种现象<br> redis 宕机或者异常终止不会造成尾部不完整现象，可以选择让 redis 退出，或者导入尽可能多的数据。<br>如果选择的是 yes，当截断的 aof 文件被导入的时候，会自动发布一个 log 给客户端然后 load。<br>如果是 no，用户必须手动 redis-check-aof 修复 AOF 文件才可以。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua-time-limit 5000</span><br></pre></td></tr></table></figure><p>如果达到最大时间限制（毫秒），redis 会记个 log，然后返回 error。当一个脚本超过了最大时限。<br>只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 可以用。第一个可以杀没有调 write 命令的东西。<br>要是已经调用了 write，只能用第二个命令杀</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure><p>集群开关，默认是不开启集群模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-config-file nodes-6379.conf</span><br></pre></td></tr></table></figure><p>集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。<br>这个文件并不需要手动配置，这个配置文件有 Redis 生成并更新，每个 Redis 集群节点需要一个单独的配置文件<br>请确保与实例运行的系统中配置文件名称不冲突</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure><p>节点互连超时的阀值，集群节点超时毫秒数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-slave-validity-factor 10</span><br></pre></td></tr></table></figure><p>在进行故障转移的时候，全部 slave 都会请求申请为 master，但是有些 slave 可能与 master 断开连接一段时间了，<br>导致数据过于陈旧，这样的 slave 不应该被提升为 master。该参数就是用来判断 slave 节点与 master 断线的时间是否过长。<br>判断方法是：<br>比较 slave 断开连接的时间和 (node-timeout * slave-validity-factor) + repl-ping-slave-period<br> 如果节点超时时间为三十秒，并且 slave-validity-factor 为 10,<br> 假设默认的 repl-ping-slave-period 是 10 秒，即如果超过 310 秒 slave 将不会尝试进行故障转移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-migration-barrier 1</span><br></pre></td></tr></table></figure><p>master 的 slave 数量大于该值，slave 才能迁移到其他孤立 master 上，如这个参数若被设为 2，<br>那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure><p>默认情况下，集群全部的 slot 有节点负责，集群状态才为 ok，才能提供服务。<br>设置为 no，可以在 slot 没有全部分配的时候提供服务。<br>不建议打开该配置，这样会造成分区的时候，小分区的 master 一直在接受写请求，而造成很长时间数据不一致</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slowlog-log-slower-than 10000</span><br></pre></td></tr></table></figure><p>slog log 是用来记录 redis 运行中执行比较慢的命令耗时。<br>当命令的执行超过了指定时间，就记录在 slow log 中，slog log 保存在内存中，所以没有 IO 操作。<br>执行时间比 slowlog-log-slower-than 大的请求记录到 slowlog 里面，单位是微秒，所以 1000000 就是 1 秒。<br>注意，负数时间会禁用慢查询日志，而 0 则会强制记录所有命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure><p>慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉，这个长度没有限制。<br>只要有足够的内存就行，你可以通过 SLOWLOG RESET 来释放内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">latency-monitor-threshold 0</span><br></pre></td></tr></table></figure><p>延迟监控功能是用来监控 redis 中执行比较缓慢的一些操作，用 LATENCY 打印 redis 实例在跑命令时的耗时图表。<br>只记录大于等于下边设置的值的操作，0 的话，就是关闭监视。<br>默认延迟监控功能是关闭的，如果你需要打开，也可以通过 CONFIG SET 命令动态设置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">notify-keyspace-events &quot;&quot;</span><br></pre></td></tr></table></figure><p>键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。<br>notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：<br>K 键空间通知，所有通知以 <strong>keyspace@</strong> 为前缀<br> E 键事件通知，所有通知以 <strong>keyevent@</strong> 为前缀<br> g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知<br> $ 字符串命令的通知<br> l 列表命令的通知<br> s 集合命令的通知<br> h 哈希命令的通知<br> z 有序集合命令的通知<br> x 过期事件：每当有过期键被删除时发送<br> e 驱逐 (evict) 事件：每当有键因为 maxmemory 政策而被删除时发送<br> A 参数 g$lshzxe 的别名<br>输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br></pre></td></tr></table></figure><p>hash 类型的数据结构在编码上可以使用 ziplist 和 hashtable。<br>ziplist 的特点就是文件存储 (以及内存存储) 所需的空间较小，在内容较小时，性能和 hashtable 几乎一样。<br>因此 redis 对 hash 类型默认采取 ziplist。如果 hash 中条目的条目个数或者 value 长度达到阀值，将会被重构为 hashtable。<br>这个参数指的是 ziplist 中允许存储的最大条目个数，，默认为 512，建议为 128</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure><p>ziplist 中允许条目 value 值最大字节数，默认为 64，建议为 1024</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list-max-ziplist-size -2</span><br></pre></td></tr></table></figure><p>当取正值的时候，表示按照数据项个数来限定每个 quicklist 节点上的 ziplist 长度。比如，当这个参数配置成 5 的时候，表示每个 quicklist 节点的 ziplist 最多包含 5 个数据项。<br>当取负值的时候，表示按照占用字节数来限定每个 quicklist 节点上的 ziplist 长度。这时，它只能取 - 1 到 - 5 这五个值，每个值含义如下：<br>-5: 每个 quicklist 节点上的 ziplist 大小不能超过 64 Kb。（注：1kb =&gt; 1024 bytes）<br>-4: 每个 quicklist 节点上的 ziplist 大小不能超过 32 Kb。<br>-3: 每个 quicklist 节点上的 ziplist 大小不能超过 16 Kb。<br>-2: 每个 quicklist 节点上的 ziplist 大小不能超过 8 Kb。（-2 是 Redis 给出的默认值）<br>-1: 每个 quicklist 节点上的 ziplist 大小不能超过 4 Kb。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list-compress-depth 0</span><br></pre></td></tr></table></figure><p>这个参数表示一个 quicklist 两端不被压缩的节点个数。<br>注：这里的节点个数是指 quicklist 双向链表的节点个数，而不是指 ziplist 里面的数据项个数。<br>实际上，一个 quicklist 节点上的 ziplist，如果被压缩，就是整体被压缩的。<br>参数 list-compress-depth 的取值含义如下：<br>0: 是个特殊值，表示都不压缩。这是 Redis 的默认值。<br>1: 表示 quicklist 两端各有 1 个节点不压缩，中间的节点压缩。<br>2: 表示 quicklist 两端各有 2 个节点不压缩，中间的节点压缩。<br>3: 表示 quicklist 两端各有 3 个节点不压缩，中间的节点压缩。<br>依此类推…<br> 由于 0 是个特殊值，很容易看出 quicklist 的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-max-intset-entries 512</span><br></pre></td></tr></table></figure><p>数据量小于等于 set-max-intset-entries 用 intset，大于 set-max-intset-entries 用 set</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br></pre></td></tr></table></figure><p>数据量小于等于 zset-max-ziplist-entries 用 ziplist，大于 zset-max-ziplist-entries 用 zset</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hll-sparse-max-bytes 3000</span><br></pre></td></tr></table></figure><p>value 大小小于等于 hll-sparse-max-bytes 使用稀疏数据结构（sparse）<br>大于 hll-sparse-max-bytes 使用稠密的数据结构（dense），一个比 16000 大的 value 是几乎没用的，<br>建议的 value 大概为 3000。如果对 CPU 要求不高，对空间要求较高的，建议设置到 10000 左右</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure><p>Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用。<br>当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no。<br>如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit normal 0 0 0</span><br></pre></td></tr></table></figure><p>对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。<br>对于 normal client，第一个 0 表示取消 hard limit，第二个 0 和第三个 0 表示取消 soft limit，normal client 默认取消限制，因为如果没有寻问，他们是不会接收数据的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br></pre></td></tr></table></figure><p>对于 slave client 和 MONITER client，如果 client-output-buffer 一旦超过 256mb，又或者超过 64mb 持续 60 秒，那么服务器就会立即断开客户端连接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure><p>对于 pubsub client，如果 client-output-buffer 一旦超过 32mb，又或者超过 8mb 持续 60 秒，那么服务器就会立即断开客户端连接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hz 10</span><br></pre></td></tr></table></figure><p>redis 执行任务的频率为 1s 除以 hz</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>在 aof 重写的时候，如果打开了 aof-rewrite-incremental-fsync 开关，系统会每 32MB 执行一次 fsync。<br>这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Error01</title>
      <link href="/2022/05/18/SLF4J/Errors/Error01/"/>
      <url>/2022/05/18/SLF4J/Errors/Error01/</url>
      
        <content type="html"><![CDATA[<h2 id="错误明细"><a class="markdownIt-Anchor" href="#错误明细">#</a> 错误明细</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SLF4J: No SLF4J providers were found.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br></pre></td></tr></table></figure><h2 id="背景"><a class="markdownIt-Anchor" href="#背景">#</a> 背景</h2><p>在项目中引入 log4j 时，首先考虑项目中所用到的框架的日志本身对 log4j 的兼容性，为此需要引入一个各种日志的抽象层 slf4j，该抽象层使得你无论在项目中用什么日志框架，都可以很好的与项目中其他框架的日志兼容。所以，如果我们要使用 log4j 作为项目的日志框架，那么为了和项目中其他的框架的日志兼容，我们需要引入 slf4j-api 以及 slf4j-log4j12。</p><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案">#</a> 解决方案</h2><p>同时引入如下依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SLF4J </category>
          
          <category> Errors </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLF4J </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java：无效的目标发行版</title>
      <link href="/2022/05/18/IDEA/java%EF%BC%9A%E6%97%A0%E6%95%88%E7%9A%84%E7%9B%AE%E6%A0%87%E5%8F%91%E8%A1%8C%E7%89%88/"/>
      <url>/2022/05/18/IDEA/java%EF%BC%9A%E6%97%A0%E6%95%88%E7%9A%84%E7%9B%AE%E6%A0%87%E5%8F%91%E8%A1%8C%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>使用 IDEA 开发时碰到如下错误</p><blockquote><p>java: 错误：无效的目标发行版：16</p></blockquote><p>解决方案：<br>灵感来源：<a href="https://zhuanlan.zhihu.com/p/348660719">知乎</a></p><p><img src="/2022/05/18/IDEA/java%EF%BC%9A%E6%97%A0%E6%95%88%E7%9A%84%E7%9B%AE%E6%A0%87%E5%8F%91%E8%A1%8C%E7%89%88/image-20220518164104705-16528632683301.png" alt="image-20220518164104705"></p><p>语言基本取默认值 8</p><p><img src="/2022/05/18/IDEA/java%EF%BC%9A%E6%97%A0%E6%95%88%E7%9A%84%E7%9B%AE%E6%A0%87%E5%8F%91%E8%A1%8C%E7%89%88/image-20220518164221404.png" alt="image-20220518164221404"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jedis</title>
      <link href="/2022/05/18/Redis/Jedis/"/>
      <url>/2022/05/18/Redis/Jedis/</url>
      
        <content type="html"><![CDATA[<h2 id="jedis"><a class="markdownIt-Anchor" href="#jedis">#</a> Jedis</h2><blockquote><p>官方推荐的 Java 连接开发工具</p></blockquote><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>test</li></ol><p><strong>创建 Jedis 对象即可使用 redis 的全部命令</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. new Jedis对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 可以使用Redis的所有命令</span></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用api"><a class="markdownIt-Anchor" href="#常用api">#</a> 常用 API</h2><hr><p>所有的命令都不变</p><p>String</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. new Jedis对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 可以使用Redis的所有命令</span></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">        System.out.println(<span class="string">&quot;清空数据&quot;</span>+jedis.flushDB());</span><br><span class="line">        jedis.set(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;判断某个key是否存在&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;新增键值对&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;YiMing&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;系统中的所有键值对：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(keys);</span><br><span class="line">        System.out.println(<span class="string">&quot;查看key对应的类型&quot;</span>+jedis.type(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;随机返回key空间的一个&quot;</span>+jedis.randomKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;get值&quot;</span>+jedis.get(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;重命名&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;按索引查询&quot;</span>+jedis.select(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回key的数目&quot;</span>+jedis.dbSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;删除键值对&quot;</span>+jedis.del(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List</p><p>Set</p><p>Hash</p><p>Zset</p><h2 id="事务处理"><a class="markdownIt-Anchor" href="#事务处理">#</a> 事务处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSONObject;</span><br><span class="line"><span class="comment">//一定要手动导入这个包</span></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        JSONObject jsonObject=<span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;YiMing&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> jedis.multi();<span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transaction.set(<span class="string">&quot;user1&quot;</span>,result);</span><br><span class="line">            transaction.set(<span class="string">&quot;user2&quot;</span>,result);</span><br><span class="line">            transaction.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            transaction.discard();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="springboot整合"><a class="markdownIt-Anchor" href="#springboot整合">#</a> Springboot 整合</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><ul><li><p>Springboot 操作数据：Spring-data，jpa，mongodb，redis</p></li><li><p>在 Springboot 2.x 之后，原来使用的 jedis 被替换为了 lettuce</p><ul><li>jedis：采用的直连，多个线程操作的话不安全，如果想要避免，使用 jedis pool 连接池  BIO</li><li>lettuce：采用 netty，实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程数据了  NIO</li></ul></li></ul><p><strong>勉为其难地看看源码吧</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">       name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">   )</span></span><br><span class="line">   <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">   <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">       RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">       template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">       <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">   <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>Test</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisSpringbootApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来自RedisAutoConfig</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//redisTemplate 操作不同的数据类型，api和指令一致</span></span><br><span class="line">        <span class="comment">//redisTemplate.opsForValue  操作字符串</span></span><br><span class="line">        <span class="comment">//opsForSet</span></span><br><span class="line">        <span class="comment">//opsForHash</span></span><br><span class="line">        <span class="comment">//opsForZSet</span></span><br><span class="line">        <span class="comment">//opsForGeo</span></span><br><span class="line">        <span class="comment">//opsForHyperLogLog</span></span><br><span class="line">        <span class="comment">//除了基本操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取redis连接对象</span></span><br><span class="line">        <span class="type">RedisConnection</span> <span class="variable">redisConnection</span> <span class="operator">=</span> redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.flushDb();</span><br><span class="line">        redisConnection.flushAll();</span><br><span class="line">    &#125;</span><br><span class="line">-+</span><br></pre></td></tr></table></figure><h3 id="自定义redistemplate"><a class="markdownIt-Anchor" href="#自定义redistemplate">#</a> 自定义 RedisTemplate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line"><span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redis工具类"><a class="markdownIt-Anchor" href="#redis工具类">#</a> Redis 工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================common============================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定缓存失效时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断key是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================String=============================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通缓存获取</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="type">return</span> <span class="variable">key</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通缓存放入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForValue().set(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递增</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递减</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================================Map=================================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashGet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet 并设置时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">expire(key, time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">expire(key, time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除hash表中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> by 要增加几(大于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash递减</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> by 要减少记(小于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================set=============================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数据放入set缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将set数据放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">expire(key, time);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取set缓存的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除值为value的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取list缓存的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取list缓存的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">expire(key, time);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">expire(key, time);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().set(key, index, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除N个值为value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line"><span class="keyword">return</span> remove;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Jedis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2022/05/18/Redis/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/05/18/Redis/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a class="markdownIt-Anchor" href="#事务">#</a> 事务</h2><hr><p>Redis 事务的本质：一组命令的集合，一组事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序进行</p><p>一次性，顺序性，排他性</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务 (multi)。0</li><li>命令入队。</li><li>执行事务 (exec)。</li></ul><p><font color="red">Redis 事务没有隔离级别的概念</font></p><p>所有命令在事务中，并没有立即执行。只有发起执行命令时才会执行</p><p><font color="red">Redis 单条命令是保持原子性的，但是事务不保证原子性</font></p><hr><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启事务</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k1 v1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k2 v2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k3 v3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此时并未执行</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行事务</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a class="markdownIt-Anchor" href="#异常">#</a> 异常</h3><blockquote><p>编译型异常</p></blockquote><p>（代码有误，命令有错），事务中所有的命令都不会执行</p><blockquote><p>运行时异常</p></blockquote><p>如果事务队列中存在错误，那么执行的时候，其他命令可以正常执行，错误命令抛出异常</p><h3 id="监控"><a class="markdownIt-Anchor" href="#监控">#</a> 监控</h3><blockquote><p>悲观锁</p></blockquote><p>认为什么时候都会出错，无论做什么都会加锁</p><blockquote><p>乐观锁</p></blockquote><p>认为什么时候都不会出问题，所以不会上锁。</p><p>使用 version 字段，更新数据的时候判断在此期间是否有人修改过数据</p><h3 id="命令"><a class="markdownIt-Anchor" href="#命令">#</a> 命令</h3><ol><li>multi 开启事务</li><li>exec          执行事务</li><li>discard    放弃事务</li><li>unwatch   取消 watch 命令对所有 key 的监视</li><li>watch key [key…]     监视一个（或多个）key，如果在事务执行之前这个（或这些）key 被其他命令所改动，那么事务将被打断<ul><li>执行 watch 命令，相当于拿到了这个 key 的 version，每次执行完事务后要重新加锁，无论事务执行成功或失败，Redis 都会自动解锁</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BitMap</title>
      <link href="/2022/05/18/Redis/Redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/BitMap/"/>
      <url>/2022/05/18/Redis/Redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/BitMap/</url>
      
        <content type="html"><![CDATA[<h2 id="bitmaps"><a class="markdownIt-Anchor" href="#bitmaps">#</a> BitMaps</h2><p>相当于 map&lt;Integer,Byte&gt;</p><blockquote><p>位存储</p></blockquote><p>统计用户信息，活跃 or 不活跃，登录 or 未登录，凡是只有两个状态的，都可以使用 BitMaps</p><h2 id="命令"><a class="markdownIt-Anchor" href="#命令">#</a> 命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit （key） （offset） （value）</span><br><span class="line">getbit (key) (offset)</span><br><span class="line">bitcount (key) [start,end]</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit sign 0 0</span><br><span class="line">setbit sign 7 1</span><br><span class="line">getbit sign 7</span><br><span class="line">bitcount sign</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis特殊数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HyperLogLog</title>
      <link href="/2022/05/17/Redis/Redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/HyperLogLog/"/>
      <url>/2022/05/17/Redis/Redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/HyperLogLog/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是基数</p></blockquote><p>一个集合中不重复的元素个数，可以接收误差</p><blockquote><p>简介</p></blockquote><ul><li>Redis 在 2.8.9 版本添加了 HyperLogLog 结构</li><li>基数统计算法</li><li>优点：占用内存固定，2^64 不同的元素只需要 12KB 内存！如果要从内存角度来比较，Hyperloglog 首选</li><li>存在 0.81% 的错误率，如果不允许容错，使用 set 即可</li><li>网站的 UV（一个人访问一个网站多次，但算作一个人）<ul><li>传统统计方式：set 存储用户 id，然后就可以统计 set 中的元素作为标准判断</li><li>用传统方式保存大量用户 id 会比较麻烦</li></ul></li></ul><blockquote><p>命令</p></blockquote><table><thead><tr><th>1</th><th>[PFADD key element [element …]] 添加指定元素到 HyperLogLog 中。</th><th></th></tr></thead><tbody><tr><td>2</td><td>[PFCOUNT key [key …]] 返回给定 HyperLogLog 的基数估算值。</td><td></td></tr><tr><td>3</td><td>[PFMERGE destkey sourcekey [sourcekey …]] 将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis特殊数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令_列表（List）</title>
      <link href="/2022/05/17/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4-%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89/"/>
      <url>/2022/05/17/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4-%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="list命令"><a class="markdownIt-Anchor" href="#list命令">#</a> List 命令</h2><table><thead><tr><th>1</th><th>[BLPOP key1 <a href="https://www.runoob.com/redis/lists-blpop.html">key2 ] timeout</a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</th></tr></thead><tbody><tr><td>2</td><td>[BRPOP key1 <a href="https://www.runoob.com/redis/lists-brpop.html">key2 ] timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a> 通过索引获取列表中的元素</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a> 获取列表长度</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a> 移出并获取列表的第一个元素</td></tr><tr><td>8</td><td>[LPUSH key value1 <a href="https://www.runoob.com/redis/lists-lpush.html">value2]</a> 将一个或多个值插入到列表头部</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a> 获取列表指定范围内的元素</td></tr><tr><td>11</td><td><a href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a> 移除列表元素</td></tr><tr><td>12</td><td><a href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a> 通过索引设置列表元素的值</td></tr><tr><td>13</td><td><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a> 对一个列表进行修剪 (trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td>14</td><td><a href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a> 移除列表的最后一个元素，返回值为移除的元素。</td></tr><tr><td>15</td><td><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td>16</td><td>[RPUSH key value1 <a href="https://www.runoob.com/redis/lists-rpush.html">value2]</a> 在列表中添加一个或多个值</td></tr><tr><td>17</td><td><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a> 为已存在的列表添加值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis基本数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令_有序集合（SortedList）</title>
      <link href="/2022/05/17/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88SortedList%EF%BC%89/"/>
      <url>/2022/05/17/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88SortedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="sortedlist"><a class="markdownIt-Anchor" href="#sortedlist">#</a> SortedList</h2><table><thead><tr><th>1</th><th>[ZADD key score1 member1 <a href="https://www.runoob.com/redis/sorted-sets-zadd.html">score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</th></tr></thead><tbody><tr><td>2</td><td><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a> 获取有序集合的成员数</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td>5</td><td>[ZINTERSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">key …]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td>7</td><td>[ZRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrange.html">WITHSCORES]</a> 通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td>8</td><td>[ZRANGEBYLEX key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">LIMIT offset count]</a> 通过字典区间返回有序集合的成员</td></tr><tr><td>9</td><td>[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT]</a> 通过分数返回有序集合指定区间内的成员</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a> 返回有序集合中指定成员的索引</td></tr><tr><td>11</td><td>[ZREM key member <a href="https://www.runoob.com/redis/sorted-sets-zrem.html">member …]</a> 移除有序集合中的一个或多个成员</td></tr><tr><td>12</td><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td></tr><tr><td>13</td><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td></tr><tr><td>14</td><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td></tr><tr><td>15</td><td>[ZREVRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td>16</td><td>[ZREVRANGEBYSCORE key max min <a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">WITHSCORES]</a> 返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td>17</td><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减 (从大到小) 排序</td></tr><tr><td>18</td><td><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a> 返回有序集中，成员的分数值</td></tr><tr><td>19</td><td>[ZUNIONSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">key …]</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td>20</td><td>[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis基本数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令_集合（Set）</title>
      <link href="/2022/05/17/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4-%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89/"/>
      <url>/2022/05/17/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4-%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="set命令"><a class="markdownIt-Anchor" href="#set命令">#</a> Set 命令</h2><table><thead><tr><th>1</th><th>[SADD key member1 <a href="https://www.runoob.com/redis/sets-sadd.html">member2]</a> 向集合添加一个或多个成员</th></tr></thead><tbody><tr><td>2</td><td><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a> 获取集合的成员数</td></tr><tr><td>3</td><td>[SDIFF key1 <a href="https://www.runoob.com/redis/sets-sdiff.html">key2]</a> 返回第一个集合与其他集合之间的差异。</td></tr><tr><td>4</td><td>[SDIFFSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sdiffstore.html">key2]</a> 返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td>5</td><td>[SINTER key1 <a href="https://www.runoob.com/redis/sets-sinter.html">key2]</a> 返回给定所有集合的交集</td></tr><tr><td>6</td><td>[SINTERSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sinterstore.html">key2]</a> 返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a> 返回集合中的所有成员</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a> 移除并返回集合中的一个随机元素</td></tr><tr><td>11</td><td>[SRANDMEMBER key <a href="https://www.runoob.com/redis/sets-srandmember.html">count]</a> 返回集合中一个或多个随机数</td></tr><tr><td>12</td><td>[SREM key member1 <a href="https://www.runoob.com/redis/sets-srem.html">member2]</a> 移除集合中一个或多个成员</td></tr><tr><td>13</td><td>[SUNION key1 <a href="https://www.runoob.com/redis/sets-sunion.html">key2]</a> 返回所有给定集合的并集</td></tr><tr><td>14</td><td>[SUNIONSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sunionstore.html">key2]</a> 所有给定集合的并集存储在 destination 集合中</td></tr><tr><td>15</td><td>[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis基本数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令_服务器</title>
      <link href="/2022/05/16/Redis/Redis%E5%91%BD%E4%BB%A4/Redis%E5%91%BD%E4%BB%A4_%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/05/16/Redis/Redis%E5%91%BD%E4%BB%A4/Redis%E5%91%BD%E4%BB%A4_%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器"><a class="markdownIt-Anchor" href="#服务器">#</a> 服务器</h2><ol><li>在远程 Redis 服务上执行命令</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -h host -p port -a password</span></span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>连接到主机 127.0.0.1，端口为 6379，密码为 mypass 的 redis 服务上</p><blockquote><p>$ redis-cli -h 127.0.0.1 -p 6379 -a  “mypass”</p></blockquote><h2 id="键key命令"><a class="markdownIt-Anchor" href="#键key命令">#</a> 键（key）命令</h2><ol><li>设置键值对</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set (keyname) (keyvalue)</span><br></pre></td></tr></table></figure><ol start="2"><li>删除键</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del (key)</span><br></pre></td></tr></table></figure><ol start="3"><li>序列化给定 key，并返回被序列化的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dump (key)</span><br></pre></td></tr></table></figure><ol start="4"><li>检查给定 key 是否存在</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><ol start="5"><li>给 key 设置过期时间 (以秒为单位)</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire (key) (seconds)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire (key) (timestamp)</span><br><span class="line">EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pexpire (key) (milliseconds)</span><br><span class="line">设置key过期时间(以毫秒为单位)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PEXPIREAT (key) (milliseconds-timestamp)</span><br><span class="line">设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</span><br></pre></td></tr></table></figure><ol start="6"><li>查找所有符合给定模式 (pattern) 的 key</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>keys *</p><p>列出所有键</p><ol start="7"><li>移动 key 到指定数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><ol start="8"><li>移除 key 期间，key 将长久保持</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">persist (key)</span><br></pre></td></tr></table></figure><ol start="9"><li>返回 key 剩余的过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pttl (key)</span><br><span class="line">#以毫秒为单位</span><br><span class="line">ttl (key)</span><br><span class="line">#以秒为单位</span><br></pre></td></tr></table></figure><ol start="10"><li>从数据库中随机返回一个 key</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure><ol start="11"><li>修改 key 名称</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename (key) (newkey)</span><br></pre></td></tr></table></figure><ol start="12"><li>仅当 newkey 不存在时，将 key 改名为 newkey</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renamenx (key) (newkey)</span><br></pre></td></tr></table></figure><ol start="13"><li>返回 key 所存储的值的类型</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><ol start="14"><li>迭代数据库中的数据库键</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scan cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h2 id="string命令"><a class="markdownIt-Anchor" href="#string命令">#</a> String 命令</h2><ol><li>获取 (设定) 值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set (key) (value)</span><br><span class="line">get (key)</span><br><span class="line">getrange (key) start end #范围获取</span><br><span class="line">getset (keyvalue) #获取并设定，返回原值</span><br></pre></td></tr></table></figure><ol start="2"><li>对 key 所储存的字符串值，获取（设定）指定偏移量上的位 (bit)。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure><ol start="3"><li>获取一个或多个给定 key 的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mget key1[key2..]</span><br></pre></td></tr></table></figure><ol start="4"><li>更改</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">incr key #将 key 中储存的数字值增</span><br><span class="line">incrby key increament#将 key 所储存的值加上给定的增量值（increment）</span><br><span class="line">incrbyfloat key increament#将 key 所储存的值加上给定的浮点增量值</span><br><span class="line">decr key #将 key 中储存的数字值减一</span><br><span class="line">decrby key decrement#key 所储存的值减去给定的减量值</span><br><span class="line">append key value#如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</span><br></pre></td></tr></table></figure><h2 id="hash命令"><a class="markdownIt-Anchor" href="#hash命令">#</a> Hash 命令</h2><ol><li>查</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexists key field#查看哈希表key中，指定字段是否存在</span><br><span class="line">hget key field#获取</span><br><span class="line">hgetall key#获取所有字段和值</span><br><span class="line">hkeys key#获取所有哈希表中的字段</span><br><span class="line">hlen key#获取哈希表中字段数量</span><br><span class="line">hmget key field1 [field2]#获取所有给定字段的值</span><br><span class="line">hscan key cursor [MATCH pattern] [COUNT count]#迭代键值对</span><br><span class="line">hvals key#获取哈希表中所有值</span><br></pre></td></tr></table></figure><ol start="2"><li>增</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby key field increament#为哈希表 key 中的指定字段的整数值加上增量</span><br><span class="line">hincrbyfloat field increament#为哈希表 key 中的指定字段的浮点数值加上增量</span><br><span class="line">hmset key field1 value1 [field2] value2#设置多个键值对</span><br><span class="line">hsetnx key field value#字段不存在时设置字段的值</span><br></pre></td></tr></table></figure><ol start="3"><li>删</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdel key field1 [field2]#删除一个或多个字段</span><br></pre></td></tr></table></figure><ol start="4"><li>改</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure><h2 id="set命令"><a class="markdownIt-Anchor" href="#set命令">#</a> Set 命令</h2><table><thead><tr><th>1</th><th>[SADD key member1 <a href="https://www.runoob.com/redis/sets-sadd.html">member2]</a> 向集合添加一个或多个成员</th></tr></thead><tbody><tr><td>2</td><td><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a> 获取集合的成员数</td></tr><tr><td>3</td><td>[SDIFF key1 <a href="https://www.runoob.com/redis/sets-sdiff.html">key2]</a> 返回第一个集合与其他集合之间的差异。</td></tr><tr><td>4</td><td>[SDIFFSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sdiffstore.html">key2]</a> 返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td>5</td><td>[SINTER key1 <a href="https://www.runoob.com/redis/sets-sinter.html">key2]</a> 返回给定所有集合的交集</td></tr><tr><td>6</td><td>[SINTERSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sinterstore.html">key2]</a> 返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a> 返回集合中的所有成员</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a> 移除并返回集合中的一个随机元素</td></tr><tr><td>11</td><td>[SRANDMEMBER key <a href="https://www.runoob.com/redis/sets-srandmember.html">count]</a> 返回集合中一个或多个随机数</td></tr><tr><td>12</td><td>[SREM key member1 <a href="https://www.runoob.com/redis/sets-srem.html">member2]</a> 移除集合中一个或多个成员</td></tr><tr><td>13</td><td>[SUNION key1 <a href="https://www.runoob.com/redis/sets-sunion.html">key2]</a> 返回所有给定集合的并集</td></tr><tr><td>14</td><td>[SUNIONSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sunionstore.html">key2]</a> 所有给定集合的并集存储在 destination 集合中</td></tr><tr><td>15</td><td>[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td></tr></tbody></table><h2 id="sortedlist"><a class="markdownIt-Anchor" href="#sortedlist">#</a> SortedList</h2><table><thead><tr><th>1</th><th>[ZADD key score1 member1 <a href="https://www.runoob.com/redis/sorted-sets-zadd.html">score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</th></tr></thead><tbody><tr><td>2</td><td><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a> 获取有序集合的成员数</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td>5</td><td>[ZINTERSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">key …]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td>7</td><td>[ZRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrange.html">WITHSCORES]</a> 通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td>8</td><td>[ZRANGEBYLEX key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">LIMIT offset count]</a> 通过字典区间返回有序集合的成员</td></tr><tr><td>9</td><td>[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT]</a> 通过分数返回有序集合指定区间内的成员</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a> 返回有序集合中指定成员的索引</td></tr><tr><td>11</td><td>[ZREM key member <a href="https://www.runoob.com/redis/sorted-sets-zrem.html">member …]</a> 移除有序集合中的一个或多个成员</td></tr><tr><td>12</td><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td></tr><tr><td>13</td><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td></tr><tr><td>14</td><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td></tr><tr><td>15</td><td>[ZREVRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td>16</td><td>[ZREVRANGEBYSCORE key max min <a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">WITHSCORES]</a> 返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td>17</td><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减 (从大到小) 排序</td></tr><tr><td>18</td><td><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a> 返回有序集中，成员的分数值</td></tr><tr><td>19</td><td>[ZUNIONSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">key …]</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td>20</td><td>[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><h2 id="list命令"><a class="markdownIt-Anchor" href="#list命令">#</a> List 命令</h2><table><thead><tr><th>1</th><th>[BLPOP key1 <a href="https://www.runoob.com/redis/lists-blpop.html">key2 ] timeout</a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</th></tr></thead><tbody><tr><td>2</td><td>[BRPOP key1 <a href="https://www.runoob.com/redis/lists-brpop.html">key2 ] timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a> 通过索引获取列表中的元素</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a> 获取列表长度</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a> 移出并获取列表的第一个元素</td></tr><tr><td>8</td><td>[LPUSH key value1 <a href="https://www.runoob.com/redis/lists-lpush.html">value2]</a> 将一个或多个值插入到列表头部</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a> 获取列表指定范围内的元素</td></tr><tr><td>11</td><td><a href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a> 移除列表元素</td></tr><tr><td>12</td><td><a href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a> 通过索引设置列表元素的值</td></tr><tr><td>13</td><td><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a> 对一个列表进行修剪 (trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td>14</td><td><a href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a> 移除列表的最后一个元素，返回值为移除的元素。</td></tr><tr><td>15</td><td><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td>16</td><td>[RPUSH key value1 <a href="https://www.runoob.com/redis/lists-rpush.html">value2]</a> 在列表中添加一个或多个值</td></tr><tr><td>17</td><td><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a> 为已存在的列表添加值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令_键(key)</title>
      <link href="/2022/05/16/Redis/Redis%E5%91%BD%E4%BB%A4/Redis%E5%91%BD%E4%BB%A4_%E9%94%AE(key)/"/>
      <url>/2022/05/16/Redis/Redis%E5%91%BD%E4%BB%A4/Redis%E5%91%BD%E4%BB%A4_%E9%94%AE(key)/</url>
      
        <content type="html"><![CDATA[<h2 id="键key命令"><a class="markdownIt-Anchor" href="#键key命令">#</a> 键（key）命令</h2><ol><li>设置键值对</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set (keyname) (keyvalue)</span><br></pre></td></tr></table></figure><ol start="2"><li>删除键</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del (key)</span><br></pre></td></tr></table></figure><ol start="3"><li>序列化给定 key，并返回被序列化的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dump (key)</span><br></pre></td></tr></table></figure><ol start="4"><li>检查给定 key 是否存在</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><ol start="5"><li>给 key 设置过期时间 (以秒为单位)</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire (key) (seconds)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire (key) (timestamp)</span><br><span class="line">EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pexpire (key) (milliseconds)</span><br><span class="line">设置key过期时间(以毫秒为单位)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PEXPIREAT (key) (milliseconds-timestamp)</span><br><span class="line">设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</span><br></pre></td></tr></table></figure><ol start="6"><li>查找所有符合给定模式 (pattern) 的 key</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>keys *</p><p>列出所有键</p><ol start="7"><li>移动 key 到指定数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><ol start="8"><li>移除 key 期间，key 将长久保持</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">persist (key)</span><br></pre></td></tr></table></figure><ol start="9"><li>返回 key 剩余的过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pttl (key)</span><br><span class="line">#以毫秒为单位</span><br><span class="line">ttl (key)</span><br><span class="line">#以秒为单位</span><br></pre></td></tr></table></figure><ol start="10"><li>从数据库中随机返回一个 key</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure><ol start="11"><li>修改 key 名称</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename (key) (newkey)</span><br></pre></td></tr></table></figure><ol start="12"><li>仅当 newkey 不存在时，将 key 改名为 newkey</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renamenx (key) (newkey)</span><br></pre></td></tr></table></figure><ol start="13"><li>返回 key 所存储的值的类型</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><ol start="14"><li>迭代数据库中的数据库键</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scan cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令_哈希(Hash)</title>
      <link href="/2022/05/16/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4_%E5%93%88%E5%B8%8C(Hash)/"/>
      <url>/2022/05/16/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4_%E5%93%88%E5%B8%8C(Hash)/</url>
      
        <content type="html"><![CDATA[<h2 id="hash命令"><a class="markdownIt-Anchor" href="#hash命令">#</a> Hash 命令</h2><ol><li>查</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexists key field#查看哈希表key中，指定字段是否存在</span><br><span class="line">hget key field#获取</span><br><span class="line">hgetall key#获取所有字段和值</span><br><span class="line">hkeys key#获取所有哈希表中的字段</span><br><span class="line">hlen key#获取哈希表中字段数量</span><br><span class="line">hmget key field1 [field2]#获取所有给定字段的值</span><br><span class="line">hscan key cursor [MATCH pattern] [COUNT count]#迭代键值对</span><br><span class="line">hvals key#获取哈希表中所有值</span><br></pre></td></tr></table></figure><ol start="2"><li>增</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby key field increament#为哈希表 key 中的指定字段的整数值加上增量</span><br><span class="line">hincrbyfloat field increament#为哈希表 key 中的指定字段的浮点数值加上增量</span><br><span class="line">hmset key field1 value1 [field2] value2#设置多个键值对</span><br><span class="line">hsetnx key field value#字段不存在时设置字段的值</span><br></pre></td></tr></table></figure><ol start="3"><li>删</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdel key field1 [field2]#删除一个或多个字段</span><br></pre></td></tr></table></figure><ol start="4"><li>改</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis基本数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令_字符串(String)</title>
      <link href="/2022/05/16/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4_%E5%AD%97%E7%AC%A6%E4%B8%B2(String)/"/>
      <url>/2022/05/16/Redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%91%BD%E4%BB%A4_%E5%AD%97%E7%AC%A6%E4%B8%B2(String)/</url>
      
        <content type="html"><![CDATA[<h2 id="string命令"><a class="markdownIt-Anchor" href="#string命令">#</a> String 命令</h2><ol><li>获取 (设定) 值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set (key) (value)</span><br><span class="line">get (key)</span><br><span class="line">getrange (key) start end #范围获取</span><br><span class="line">getset (keyvalue) #获取并设定，返回原值</span><br></pre></td></tr></table></figure><ol start="2"><li>对 key 所储存的字符串值，获取（设定）指定偏移量上的位 (bit)。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure><ol start="3"><li>获取一个或多个给定 key 的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mget key1[key2..]</span><br></pre></td></tr></table></figure><ol start="4"><li>更改</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">incr key #将 key 中储存的数字值增</span><br><span class="line">incrby key increament#将 key 所储存的值加上给定的增量值（increment）</span><br><span class="line">incrbyfloat key increament#将 key 所储存的值加上给定的浮点增量值</span><br><span class="line">decr key #将 key 中储存的数字值减一</span><br><span class="line">decrby key decrement#key 所储存的值减去给定的减量值</span><br><span class="line">append key value#如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis基本数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Redis的单线程问题</title>
      <link href="/2022/05/16/Redis/%E6%A6%82%E8%AE%BA/%E5%85%B3%E4%BA%8ERedis%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/05/16/Redis/%E6%A6%82%E8%AE%BA/%E5%85%B3%E4%BA%8ERedis%E5%8D%95%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识">#</a> 基础知识</h2><blockquote><p>Redis 是单线程的</p></blockquote><h3 id="为什么redis单线程却支持高并发"><a class="markdownIt-Anchor" href="#为什么redis单线程却支持高并发">#</a> 为什么 Redis 单线程却支持高并发</h3><ol><li>纯内存操作</li><li>核心是基于非阻塞的 IO</li><li>多路复用机制 单线程反而避免了多线程的频繁上下文切换问题</li></ol><h3 id="redis高并发和快速的原因"><a class="markdownIt-Anchor" href="#redis高并发和快速的原因">#</a> Redis 高并发和快速的原因</h3><p>1.redis 是基于内存的，内存的读写速度非常快（纯内存）; 数据存在内存中，数据结构用 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O (1)。</p><p>2.redis 是单线程的，省去了很多上下文切换线程的时间（避免线程切换和竞态消耗）。</p><p>3.redis 使用 IO 多路复用技术（IO multiplexing, 解决对多个 I/O 监听时，一个 I/O 阻塞影响其他 I/O 的问题），可以处理并发的连接（非阻塞 IO）。</p><h3 id="为甚么redis是单线程的"><a class="markdownIt-Anchor" href="#为甚么redis是单线程的">#</a> 为甚么 Redis 是单线程的</h3><p><strong>官方答案</strong></p><p>因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p><strong>性能指标</strong></p><p>关于 redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p><strong>详细原因</strong></p><p>1）不需要各种锁的性能消耗</p><p>Redis 的数据结构并不全是简单的 Key-Value，还有 list，hash 等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在 hash 当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p><p>2）单线程多进程集群方案</p><p>单线程的威力实际上非常强大，单核 cpu 效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p>所以 “单线程、多进程的集群” 不失为一个时髦的解决方案。</p><p>3）CPU 消耗</p><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p><p>但是如果 CPU 成为 Redis 瓶颈，或者不想让服务器其他 CUP 核闲置，那怎么办？</p><p>可以考虑多起几个 Redis 进程，Redis 是 key-value 数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些 key 放在哪个 Redis 进程上就可以了。</p><h3 id="redis单线程的优劣势"><a class="markdownIt-Anchor" href="#redis单线程的优劣势">#</a> Redis 单线程的优劣势</h3><p><strong>单进程单线程优势</strong></p><p>代码更清晰，处理逻辑更简单。<br>不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗。<br>不存在 “多进程或者多线程导致的切换” 而消耗 CPU。</p><p><strong>单进程单线程弊端</strong></p><p>无法发挥多核 CPU 性能，不过可以通过在单机开多个 Redis 实例来完善。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 概论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理模式</title>
      <link href="/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述</h2><ul><li>动态代理和静态代理角色一样</li><li>动态代理的代理类是动态生成的，不是我们直接写好的</li><li>动态代理分为两大类，基于接口的动态代理，基于类的动态代理<ul><li>基于接口–JDK 动态代理</li><li>基于类：cglib</li><li>java 字节码实现：JAVAsist</li></ul></li></ul><h2 id="jdk动态代理"><a class="markdownIt-Anchor" href="#jdk动态代理">#</a> JDK 动态代理</h2><blockquote><p>使用 java 反射包 (java.lang.reflect) 中的类和接口事项动态代理的功能</p><p>里面有三个类：InvocationHandler，Method，Proxy</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务层模拟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span>&#123;</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;select方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insert方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;update方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log(method.getName());</span><br><span class="line">        Object result=method.invoke(target,args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String methodName)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+methodName+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//真实对象</span></span><br><span class="line">        UserServiceImpl userService=<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">//代理对象的调用处理程序</span></span><br><span class="line">        ProxyInvocationHandler proxyInvocationHandler=<span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">        proxyInvocationHandler.setTarget(userService); <span class="comment">//设置要代理的对象</span></span><br><span class="line">        IUserService proxy= (IUserService) proxyInvocationHandler.getProxy();<span class="comment">//动态生成代理类</span></span><br><span class="line">        proxy.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 动态代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态代理模式</title>
      <link href="/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/image-20220511090735455-16522312578361.png" alt="image-20220511090735455"></p><h2 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述</h2><p>​所谓静态也就是在程序运行前就已经存在代理类的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&amp;spm=1001.2101.3001.7020">字节码</a>文件，代理类和委托类的关系在运行前就确定了</p><p>举例理解：以租房为例，房东只需要处理自己的房子交给中介即可，其余的都是由中介充当代理进行租客签协议，带租客看房子，等等。</p><p><strong>静态代理需要满足三点</strong></p><p>1、需要有真实角色<br>  2、需要有一个代理角色<br>  3、这两个角色之间必须实现相同的接口</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现">#</a> 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 房东</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        host.rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seeHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东带你看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fare</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;受中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contract</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;签合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Host host=<span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line">        <span class="comment">//房东要出租房子</span></span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> <span class="title class_">Proxy</span>(host);</span><br><span class="line">        <span class="comment">//代理，中介帮房东出租，代理角色一般会有一些附属操作</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">        <span class="comment">//你不用面对房东，直接找中介租房即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a class="markdownIt-Anchor" href="#优点">#</a> 优点：</h2><ul><li>可以使真实角色操作更加纯粹，只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点</li><li>公共业务交给了代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候，方便集中管理</li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点">#</a> 缺点</h2><ul><li><p>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</p></li><li><p>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 静态代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境安装</title>
      <link href="/2022/05/10/Linux/Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2022/05/10/Linux/Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="jdk安装"><a class="markdownIt-Anchor" href="#jdk安装">#</a> JDK 安装</h2><ol><li><p>卸载 centos7 自带的 openjdk</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list installed |grep java</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps </span><br></pre></td></tr></table></figure></li><li><p>安装 jdk</p><p>2.1 yum 安装 jdk</p><p>​<strong>以下命令查找能够安装的 jdk 版本</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y list java*</span><br></pre></td></tr></table></figure><p>​定位到 /usr/local/java/ 安装 openJDK</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2022/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式">#</a> 原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍">#</a> 介绍</h2><p>** 意图：** 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p>** 主要解决：** 在运行期建立和删除原型。</p><p><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p>** 如何解决：** 利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p><p><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone ()，在 .NET 中可以使用 Object 类的 MemberwiseClone () 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些 &quot;易变类&quot; 拥有稳定的接口。</p><p><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone () 方法。</p><p><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。</p><p><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p><p><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p><p>** 注意事项：** 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现">#</a> 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Video</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        Video video=(Video) obj;</span><br><span class="line">        video.createTime= (Date) <span class="built_in">this</span>.createTime.clone();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Video</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 浅拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端实现克隆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BilibiliServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        Date date=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        Video video=<span class="keyword">new</span> <span class="title class_">Video</span>(<span class="string">&quot;my_video&quot;</span>,date);</span><br><span class="line">        System.out.println(video.hashCode());</span><br><span class="line">        Video v2= (Video) video.clone();</span><br><span class="line">        System.out.println(v2.hashCode());</span><br><span class="line">        <span class="comment">//两个对象指向同一个date，为浅克隆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim编辑器</title>
      <link href="/2022/05/09/Linux/Vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2022/05/09/Linux/Vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/05/09/Linux/Vim%E7%BC%96%E8%BE%91%E5%99%A8/image-20220509163720196-16520854463721.png" alt="image-20220509163720196"></p><h2 id="vivim-的使用"><a class="markdownIt-Anchor" href="#vivim-的使用">#</a> vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p><h3 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式">#</a> 命令模式：</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动 Vim，进入了命令模式，按下 i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h3 id="输入模式"><a class="markdownIt-Anchor" href="#输入模式">#</a> 输入模式</h3><p>在命令模式下按下 i 就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及 Shift 组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首 / 行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上 / 下翻页</li><li><strong>Insert</strong>，切换光标为输入 / 替换模式，光标将变成竖线 / 下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a class="markdownIt-Anchor" href="#底线命令模式">#</a> 底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按 ESC 键可随时退出底线命令模式。</p><blockquote><p>使用  vim filename 命令</p></blockquote><h2 id="vivim-按键说明"><a class="markdownIt-Anchor" href="#vivim-按键说明">#</a> vi/vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><h3 id="第一部分一般模式可用的光标移动-复制粘贴-搜索替换等"><a class="markdownIt-Anchor" href="#第一部分一般模式可用的光标移动-复制粘贴-搜索替换等">#</a> 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table><thead><tr><th style="text-align:left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td style="text-align:left">h 或 向左箭头键 (←)</td><td>光标向左移动一个字符</td></tr><tr><td style="text-align:left">j 或 向下箭头键 (↓)</td><td>光标向下移动一个字符</td></tr><tr><td style="text-align:left">k 或 向上箭头键 (↑)</td><td>光标向上移动一个字符</td></tr><tr><td style="text-align:left">l 或 向右箭头键 (→)</td><td>光标向右移动一个字符</td></tr><tr><td style="text-align:left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数 (数字) 后，按下动作即可！</td><td></td></tr><tr><td style="text-align:left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down] 按键 (常用)</td></tr><tr><td style="text-align:left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td style="text-align:left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td style="text-align:left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td style="text-align:left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td style="text-align:left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td style="text-align:left">n<space></space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></td></tr><tr><td style="text-align:left">0 或功能键 [Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td style="text-align:left">$ 或功能键 [End]</td><td>移动到这一行的最后面字符处 (常用)</td></tr><tr><td style="text-align:left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td style="text-align:left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td style="text-align:left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td style="text-align:left">G</td><td>移动到这个档案的最后一行 (常用)</td></tr><tr><td style="text-align:left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行 (可配合 :set nu)</td></tr><tr><td style="text-align:left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td style="text-align:left">n<Enter></Enter></td><td>n 为数字。光标向下移动 n 行 (常用)</td></tr><tr><td style="text-align:left">搜索替换</td><td></td></tr><tr><td style="text-align:left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td style="text-align:left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td style="text-align:left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行？vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td style="text-align:left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td style="text-align:left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td style="text-align:left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td style="text-align:left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td style="text-align:left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td style="text-align:left">删除、复制与贴上</td><td></td></tr><tr><td style="text-align:left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符 (相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td style="text-align:left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td style="text-align:left">dd</td><td>剪切游标所在的那一整行 (常用)，用 p/P 可以粘贴。</td></tr><tr><td style="text-align:left">ndd</td><td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行 (常用)，用 p/P 可以粘贴。</td></tr><tr><td style="text-align:left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td style="text-align:left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td style="text-align:left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td style="text-align:left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td style="text-align:left">yy</td><td>复制游标所在的那一行 (常用)</td></tr><tr><td style="text-align:left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行 (常用)</td></tr><tr><td style="text-align:left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td style="text-align:left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td style="text-align:left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td style="text-align:left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td style="text-align:left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td style="text-align:left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td style="text-align:left">c</td><td>重复删除多个数据，例如向下删除 10 行，[10cj]</td></tr><tr><td style="text-align:left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td style="text-align:left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td style="text-align:left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td style="text-align:left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><h3 id="第二部分一般模式切换到编辑模式的可用的按钮说明"><a class="markdownIt-Anchor" href="#第二部分一般模式切换到编辑模式的可用的按钮说明">#</a> 第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table><thead><tr><th style="text-align:left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td style="text-align:left">i, I</td><td>进入输入模式 (Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td style="text-align:left">a, A</td><td>进入输入模式 (Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td style="text-align:left">o, O</td><td>进入输入模式 (Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr><td style="text-align:left">r, R</td><td>进入取代模式 (Replace mode)： r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td style="text-align:left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td style="text-align:left">[Esc]</td><td>退出编辑模式，回到一般模式中 (常用)</td></tr></tbody></table><h3 id="第三部分一般模式切换到指令行模式的可用的按钮说明"><a class="markdownIt-Anchor" href="#第三部分一般模式切换到指令行模式的可用的按钮说明">#</a> 第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table><thead><tr><th style="text-align:left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td style="text-align:left">:w</td><td>将编辑的数据写入硬盘档案中 (常用)</td></tr><tr><td style="text-align:left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td style="text-align:left">:q</td><td>离开 vi (常用)</td></tr><tr><td style="text-align:left">:q!</td><td>若曾修改过档案，又不想储存，使用！为强制离开不储存档案。</td></tr><tr><td style="text-align:left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td style="text-align:left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td style="text-align:left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于 (保存并退出)</td></tr><tr><td style="text-align:left">ZQ</td><td>不保存，强制退出。效果等同于 <strong>:q!</strong>。</td></tr><tr><td style="text-align:left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td style="text-align:left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td style="text-align:left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td style="text-align:left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td style="text-align:left">vim 环境的变更</td><td></td></tr><tr><td style="text-align:left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td style="text-align:left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义">#</a> 定义</h3><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p></blockquote><h3 id="优点"><a class="markdownIt-Anchor" href="#优点">#</a> 优点</h3><ol><li>封装性好，构建和表示分离</li><li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦</li><li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险</li></ol><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点">#</a> 缺点</h3><ol><li>产品的组成部分必须相同，限制了其使用范围</li><li>如果产品的内部变化复杂，若产品内部发生改变，则建造者也要同步修改，后期维护成本大</li></ol><p>建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重部件的创建过程，但两者可以结合使用</p><h2 id="模式结构"><a class="markdownIt-Anchor" href="#模式结构">#</a> 模式结构</h2><table><thead><tr><th>模式</th><th>作用</th></tr></thead><tbody><tr><td>产品角色（Product）</td><td>包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件</td></tr><tr><td>抽象建造者（Builder）</td><td>它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult ()</td></tr><tr><td>具体建造者 (Concrete Builder）</td><td>实现 Builder 接口，完成复杂产品的各个部件的具体创建方法</td></tr><tr><td>指挥者（Director）</td><td>调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息</td></tr></tbody></table><p><img src="/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20220509121913779-16520699567131.png" alt="image-20220509121913779"></p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现">#</a> 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String buildA;</span><br><span class="line">    <span class="keyword">private</span> String buildB;</span><br><span class="line">    <span class="keyword">private</span> String buildC;</span><br><span class="line">    <span class="keyword">private</span> String buildD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildC</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildD</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.product = <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构建部件A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构建部件B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构建部件C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构建部件D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="comment">//指挥Worker</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">build</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        builder.buildA();</span><br><span class="line">        builder.buildB();</span><br><span class="line">        builder.buildC();</span><br><span class="line">        builder.buildD();</span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景">#</a> 应用场景</h2><p>建造者模式唯一区别于工厂模式的是针对<strong>复杂对象</strong>的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。</p><p>当需要创建的产品具备复杂创建过程时，可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。</p><p>建造者模式主要适用于以下应用场景：</p><ul><li>相同的方法，不同的执行顺序，产生不同的结果。</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。</li><li>产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。</li><li>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。</li></ul><h2 id="建造者模式和工厂模式"><a class="markdownIt-Anchor" href="#建造者模式和工厂模式">#</a> 建造者模式和工厂模式</h2><ul><li>建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。</li><li>创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样</li><li>关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。</li><li>建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述</h2><ul><li>作用<ul><li>实现了创建者和调用者的分离</li><li>详细分类<ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul></li></ul></li><li>OOP 满足<ul><li>开闭原则</li><li>依赖倒转</li><li>迪米特</li></ul></li><li>核心本质<ul><li>实例化对象不使用 new，用工厂方法代替</li><li>将选择实现类，创建对象统一管理和控制，从而将调用者跟实现类解耦</li></ul></li><li>三种模式<ul><li>简单（静态）工厂模式<ul><li>用来生产同一等级结构中的任意产品（对于增加的新的产品，需要覆盖已有的代码）</li></ul></li><li>工厂方法模式<ul><li>用来生产同一等级结构中的固定产品（支持增加任意产品）</li></ul></li><li>抽象工厂模式<ul><li>围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂</li></ul></li></ul></li></ul><h3 id="简单工厂模式"><a class="markdownIt-Anchor" href="#简单工厂模式">#</a> 简单工厂模式</h3><p>代码背景：有一个 consumer 前来买车</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeSiLa</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TeSiLa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WuLing</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WuLing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(String car)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (car.equals(<span class="string">&quot;WuLing&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WuLing</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (car.equals(<span class="string">&quot;TeSiLa&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TeSiLa</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;WuLing&quot;</span>);</span><br><span class="line">        car.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模式组成"><a class="markdownIt-Anchor" href="#模式组成">#</a> 模式组成</h4><table><thead><tr><th>组成（角色）</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品</td><td>具体产品的父类</td><td>描述产品的公共接口</td></tr><tr><td>具体产品</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>工厂（Creator）</td><td>被外界调用</td><td>根据传入不同参数从而创建不同具体产品类的实例</td></tr></tbody></table><h4 id="uml类图"><a class="markdownIt-Anchor" href="#uml类图">#</a> UML 类图</h4><p><img src="/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20220508111631047.png" alt="image-20220508111631047"></p><h4 id="优点"><a class="markdownIt-Anchor" href="#优点">#</a> 优点</h4><ul><li>将创建实例的工作和使用实例的工作分开，使用者不必关心对象如何创建，实现解耦</li><li>将初始化实例时的工作放到工厂进行，使代码更易于维护，更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程</li></ul><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点">#</a> 缺点：</h4><p>​如果增加不同品牌的车，需要在工厂中修改或添加方法，不满足 OOP 开闭原则</p><ul><li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响</li><li>违背 “开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂</li><li>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构</li></ul><h4 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景">#</a> 应用场景</h4><ul><li>客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时</li><li>当工厂类负责创建的对象（具体产品）比较少时</li></ul><h2 id="方法工厂模式"><a class="markdownIt-Anchor" href="#方法工厂模式">#</a> 方法工厂模式</h2><p>概述：在简单工厂模式上改进，给每种车增加一个工厂类</p><p>实现：</p><p>Car 类，TeSiLa 类，WuLing 类同上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂方法模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    Car <span class="title function_">getCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeSiLaFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TeSiLa</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WuLingFactory</span>().getCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式组成-2"><a class="markdownIt-Anchor" href="#模式组成-2">#</a> 模式组成</h3><table><thead><tr><th>主要角色</th><th>作用</th></tr></thead><tbody><tr><td>抽象工厂</td><td>提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct () 来创建产品</td></tr><tr><td>具体工厂</td><td>主要是实现抽象工厂中的抽象方法，完成具体产品的创建</td></tr><tr><td>抽象产品</td><td>定义了产品的规范，描述了产品的主要特性和功能。</td></tr><tr><td>具体产品</td><td>实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</td></tr></tbody></table><h3 id="uml类图-2"><a class="markdownIt-Anchor" href="#uml类图-2">#</a> UML 类图</h3><p><img src="/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20220508113730740.png" alt="image-20220508113730740"></p><blockquote><p>简单工厂模式违背了开闭原则，而工厂方法模式是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则</p></blockquote><h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2">#</a> 优点</h3><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2">#</a> 缺点</h3><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li><li>抽象产品只能生产一种产品，此弊端可使用<a href="http://c.biancheng.net/view/1351.html">抽象工厂模式</a>解决。</li></ul><h3 id="应用场景-2"><a class="markdownIt-Anchor" href="#应用场景-2">#</a> 应用场景</h3><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li><li>客户不关心创建产品的细节，只关心产品的品牌</li></ul><h2 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式">#</a> 抽象工厂模式</h2><p>代码背景：产品 Phone，Router 交由小米工厂生产</p><p>首先定义产品接口以及小米产品实现类</p><p>然后定义抽象工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    Phone <span class="title function_">getPhoneProduct</span><span class="params">()</span>;</span><br><span class="line">    Router <span class="title function_">getRouterProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小米工厂需要实现该抽象工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title class_">ProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhoneProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaoMiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Router <span class="title function_">getRouterProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaoMiRouter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2">#</a> 概述</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义">#</a> 定义</h4><p>提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类</p><h4 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景">#</a> 适用场景</h4><ul><li><h3 id="客户端应用层不依赖于产品实例如何被创建实现等细节"><a class="markdownIt-Anchor" href="#客户端应用层不依赖于产品实例如何被创建实现等细节">#</a> 客户端（应用层）不依赖于产品实例如何被创建，实现等细节</h3></li><li><p>强调一系列产品相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码</p></li><li><p>提供一个产品类的库，所有的产品以同样的接口出现，从而使客户不依赖于具体的实现</p></li></ul><h4 id="优点缺点"><a class="markdownIt-Anchor" href="#优点缺点">#</a> 优点 &amp; 缺点</h4><ul><li><h4 id="优点-3"><a class="markdownIt-Anchor" href="#优点-3">#</a> 优点</h4><ul><li>具体产品在应用层的代码隔离，无需关心创建的细节</li><li>将一个系列的产品统一到一起创建</li></ul></li><li><p>缺点</p><ul><li>规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难</li><li>增加了系统的抽象性和理解难度</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录结构</title>
      <link href="/2022/05/07/Linux/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2022/05/07/Linux/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构">#</a> 目录结构</h2><p><img src="/2022/05/07/Linux/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/image-20220507161042910-16519110450571.png" alt="image-20220507161042910"></p><ul><li><p>/bin  ：</p><p>​bin 是 Binaries (二进制文件) 的缩写，这个目录存放着最经常使用的命令。</p></li><li><p>/boot:</p><p>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p>/dev:</p><p>dev 是 Device (设备) 的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><mark><strong>/etc:</strong></mark></p><p>etc 是 Etcetera (等等) 的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><mark>/home：</mark></p><p>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></li><li><p>/lib：<br>lib 是 Library (库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p>/lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放突然关机的一些文件）</p></li><li><p>/media：<br>linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p>/mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><mark>/opt：</mark><br>opt 是 optional (可选) 的缩写，这是给主机额外<strong>安装软件所摆放的目录</strong>。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。</p></li><li><p>/proc：<br>proc 是 Processes (进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器：</p></li></ul><ul><li><p><mark><strong>/root</strong>：</mark><br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/selinux</strong>：<br>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</p></li><li><p><strong>/srv</strong>：<br>该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><mark><strong>/tmp</strong>：</mark><br>tmp 是 temporary (临时) 的缩写这个目录是用来存放一些临时文件的。</p></li><li><p><mark><strong>/usr</strong>：</mark><br>usr 是 unix shared resources (共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li><li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p></li><li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p></li><li><p><strong>/var</strong>：<br>var 是 variable (变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2022/05/07/Linux/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/07/Linux/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令">#</a> 常用命令</h2><h3 id="系统关机重启"><a class="markdownIt-Anchor" href="#系统关机重启">#</a> 系统关机 / 重启</h3><table><thead><tr><th>命令</th><th>简述</th></tr></thead><tbody><tr><td>sync</td><td>将数据由内存同步到硬盘中</td></tr><tr><td>shutdown</td><td>关机指令</td></tr><tr><td>shutdown -h 10</td><td>十分钟后关机</td></tr><tr><td>shutdown -h now</td><td>立即关机</td></tr><tr><td>shutdown -h 20:25</td><td>指定时间关机</td></tr><tr><td>shutdown -r now</td><td>立即重启</td></tr><tr><td>shutdown -r +10</td><td>十分钟后重启</td></tr><tr><td>reboot</td><td>重启，等同于 shutdown  -r now</td></tr><tr><td>halt</td><td>关闭系统</td></tr><tr><td>logout</td><td>注销</td></tr><tr><td>clear</td><td>清屏</td></tr></tbody></table><h3 id="文件和目录"><a class="markdownIt-Anchor" href="#文件和目录">#</a> 文件和目录</h3><table><thead><tr><th>命令</th><th>简述</th></tr></thead><tbody><tr><td>ls /</td><td>查看根目录</td></tr><tr><td>cd root</td><td>进入某个目录</td></tr><tr><td>cd …</td><td>目录回退</td></tr><tr><td>ls</td><td>查看目录中的文件</td></tr><tr><td>mkdir  mydir</td><td>创建文件夹</td></tr><tr><td>ls -F</td><td>查看目录中的文件</td></tr><tr><td>ls -l</td><td>查看文件和目录的详细资料</td></tr><tr><td>ls -a</td><td>显示隐藏文件</td></tr><tr><td>rm -f file1</td><td>删除 file1 文件</td></tr><tr><td>rmdir dir1</td><td>删除 dir1 目录</td></tr><tr><td>rm -rf dir1</td><td>删除 dir1 目录并删除其内容</td></tr><tr><td>mv dir1 new_dir</td><td>重命名 / 移动目录</td></tr><tr><td>cp file1 file2</td><td>复制一个文件</td></tr><tr><td>cp dir/* .</td><td>复制一个目录下的所有文件到当前工作目录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制一个目录</td></tr><tr><td>cd ~</td><td>进入用户目录</td></tr><tr><td>pwd</td><td>显示当前用户所在的目录</td></tr><tr><td>mkdir -p dir1/dir2/dir3</td><td>递归（连续）创建目录</td></tr><tr><td>ls -ll</td><td>查看文件属性</td></tr><tr><td>touch [filename]</td><td>创建文件</td></tr><tr><td>ln filename1 filename2</td><td>创建链接 (硬链接)</td></tr><tr><td>ln -s  filename1 filename2</td><td>创建链接 (软链接：删除源文件后无法访问)</td></tr><tr><td>echo  “text” &gt;&gt; file</td><td>文件写入内容</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="文件搜索"><a class="markdownIt-Anchor" href="#文件搜索">#</a> 文件搜索</h3><table><thead><tr><th>命令</th><th>简述</th></tr></thead><tbody><tr><td>find / -name file1</td><td>从‘/’开始进入根文件系统搜索文件和目录</td></tr><tr><td>find / -user user1</td><td>搜索属于用户 ‘user1’ 的文件和目录</td></tr><tr><td>find /home/user1 -name \*.bin</td><td>在目录 ‘/home/user1’ 中搜索带有’.bin’ 结尾的文件</td></tr><tr><td>find /usr/bin -type f -atime +100</td><td>搜索在过去 100 天内未被使用过的执行文件</td></tr><tr><td>find /usr/bin -type f -mtime -10</td><td>搜索在 10 天内被创建或者修改过的文件</td></tr><tr><td>locate *.ps</td><td>寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令</td></tr><tr><td>whereis halt</td><td>显示一个二进制文件、源码或 man 的位置</td></tr><tr><td>which halt</td><td>显示一个二进制文件或可执行文件的完整路径</td></tr><tr><td>find / -name *.rpm -exec chmod 755 ‘{}’ ;</td><td>搜索以 ‘.rpm’ 结尾的文件并定义其权限</td></tr><tr><td>find / -xdev -name *.rpm</td><td>搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备</td></tr></tbody></table><h3 id="文件属性"><a class="markdownIt-Anchor" href="#文件属性">#</a> 文件属性</h3><p>r : 4 可读</p><p>w：2 可写</p><p>x： 1 可执行</p><table><thead><tr><th>命令</th><th>简述</th></tr></thead><tbody><tr><td>chgrp [-R]  属组名  文件名</td><td>更改文件属组（-R：递归更改）</td></tr><tr><td>chown [-R] 属主名  <mark>或</mark>  chown [-R] 属主名：属组名 文件名</td><td>更改文件属主，也可以同时更改属组</td></tr><tr><td>chmod [-R] xyz 文件或目录（比如 chmod 777 file1，即最高权限）</td><td>更改文件九个属性</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="文件内容查看"><a class="markdownIt-Anchor" href="#文件内容查看">#</a> 文件内容查看</h3><table><thead><tr><th>命令</th><th>简述</th></tr></thead><tbody><tr><td>cat</td><td>由第一行开始显示文件内容（concatenate）</td></tr><tr><td>tac</td><td>从最后一行开始显示</td></tr><tr><td>nl</td><td>显示的时候输出行号</td></tr><tr><td>more</td><td>分页显示（空格翻页）</td></tr><tr><td>less</td><td>和 more 类似，但可以往前翻页</td></tr><tr><td>head</td><td>只看头几行 (head -n 20  filename)</td></tr><tr><td>tail</td><td>只看尾几行</td></tr><tr><td>q</td><td>退出查看文件</td></tr><tr><td>/</td><td>查询字符串 (/set)（n 寻找下一个  ，N 寻找上一个）</td></tr><tr><td>w</td><td>保存文件（通常和 q 联合使用，即:wq, 保存并退出）</td></tr><tr><td>vim filename</td><td>vim 编辑文件</td></tr></tbody></table><h2 id="账号管理"><a class="markdownIt-Anchor" href="#账号管理">#</a> 账号管理</h2><blockquote><p>useradd  -m  [用户名]</p></blockquote><ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用 - m 选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-s Shell 文件 指定用户的登录 Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有 - o 选项，则可以重复使用其他用户的标识号。</li></ul><ul><li>-m：自动创建这个用户的主目录 /home/ 用户名</li></ul><p>Linux 中一切皆文件，添加用户就是向某个文件中写入用户的信息</p><blockquote><p>userdel -r [用户名]</p></blockquote><p>删除用户并删除文件</p><blockquote><p>usermod  - 参数  [用户名]</p></blockquote><p>修改用户</p><p>常用的选项包括 - c, -d, -m, -g, -G, -s, -u 以及 - o 等，这些选项的意义与 useradd 命令中的选项一样，可以为用户指定新的资源值。</p><blockquote><p>passwd 选项 用户名</p></blockquote><p>用户口令管理</p><ul><li>-l 锁定口令，即禁用账号。</li><li>-u 口令解锁。</li><li>-d 使账号无口令。</li><li>-f 强迫用户下次登录时修改口令。</li></ul><h2 id="用户组管理"><a class="markdownIt-Anchor" href="#用户组管理">#</a> 用户组管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对 /etc/group 文件的更新。</p><h3 id="1-增加一个新的用户组使用groupadd命令-其格式如下"><a class="markdownIt-Anchor" href="#1-增加一个新的用户组使用groupadd命令-其格式如下">#</a> 1、增加一个新的用户组使用 groupadd 命令。其格式如下：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure><p>可以使用的选项有：</p><ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与 - g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID 相同。</li></ul><h4 id="实例1"><a class="markdownIt-Anchor" href="#实例1">#</a> 实例 1：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># groupadd group1</span><br></pre></td></tr></table></figure><p>此命令向系统中增加了一个新组 group1，新组的组标识号是在当前已有的最大组标识号的基础上加 1。</p><h4 id="实例2"><a class="markdownIt-Anchor" href="#实例2">#</a> 实例 2：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># groupadd -g 101 group2</span><br></pre></td></tr></table></figure><p>此命令向系统中增加了一个新组 group2，同时指定新组的组标识号是 101。</p><h3 id="2-如果要删除一个已有的用户组使用groupdel命令其格式如下"><a class="markdownIt-Anchor" href="#2-如果要删除一个已有的用户组使用groupdel命令其格式如下">#</a> 2、如果要删除一个已有的用户组，使用 groupdel 命令，其格式如下：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure><h4 id="例如"><a class="markdownIt-Anchor" href="#例如">#</a> 例如：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># groupdel group1</span><br></pre></td></tr></table></figure><p>此命令从系统中删除组 group1。</p><h3 id="3-修改用户组的属性使用groupmod命令-其语法如下"><a class="markdownIt-Anchor" href="#3-修改用户组的属性使用groupmod命令-其语法如下">#</a> 3、修改用户组的属性使用 groupmod 命令。其语法如下：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure><p>常用的选项有：</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与 - g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。</li><li>-n 新用户组 将用户组的名字改为新名字</li></ul><h4 id="实例1-2"><a class="markdownIt-Anchor" href="#实例1-2">#</a> 实例 1：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># groupmod -g 102 group2</span><br></pre></td></tr></table></figure><p>此命令将组 group2 的组标识号修改为 102。</p><h4 id="实例2-2"><a class="markdownIt-Anchor" href="#实例2-2">#</a> 实例 2：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure><p>此命令将组 group2 的标识号改为 10000，组名修改为 group3。</p><h3 id="4-如果一个用户同时属于多个用户组那么用户可以在用户组之间切换以便具有其他用户组的权限"><a class="markdownIt-Anchor" href="#4-如果一个用户同时属于多个用户组那么用户可以在用户组之间切换以便具有其他用户组的权限">#</a> 4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</h3><p>用户可以在登录后，使用命令 newgrp 切换到其他用户组，这个命令的参数就是目的用户组。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure><p>这条命令将当前用户切换到 root 用户组，前提条件是 root 用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p><h2 id="磁盘管理"><a class="markdownIt-Anchor" href="#磁盘管理">#</a> 磁盘管理</h2><p>常用命令 df，du，fdisk</p><h3 id="df命令"><a class="markdownIt-Anchor" href="#df命令">#</a> df 命令</h3><blockquote><p>检查文件系统的磁盘空间占用情况。可以利用该命令来获硬盘被占用了多少空间，目前还剩下多少空间等信息。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure><ul><li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li><li>-k ：以 KBytes 的容量显示各文件系统；</li><li>-m ：以 MBytes 的容量显示各文件系统；</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li><li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li><li>-T ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li></ul><h3 id="du命令"><a class="markdownIt-Anchor" href="#du命令">#</a> du 命令</h3><p>对文件和目录磁盘使用的空间的查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li><li>-h ：以人们较易读的容量格式 (G/M) 显示；</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li><li>-S ：不包括子目录下的总计，与 -s 有点差别。</li><li>-k ：以 KBytes 列出容量显示；</li><li>-m ：以 MBytes 列出容量显示；</li></ul><h3 id="fdisk命令"><a class="markdownIt-Anchor" href="#fdisk命令">#</a> fdisk 命令</h3><p>fdisk 是 Linux 的磁盘分区表操作工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdisk [-l] 装置名称</span><br></pre></td></tr></table></figure><h3 id="磁盘格式化"><a class="markdownIt-Anchor" href="#磁盘格式化">#</a> 磁盘格式化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs [-t 文件系统格式] 装置文件名</span><br></pre></td></tr></table></figure><ul><li>-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等 (系统有支持才会生效)</li></ul><h3 id="磁盘校验"><a class="markdownIt-Anchor" href="#磁盘校验">#</a> 磁盘校验</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fsck [-t 文件系统][-ACay] 装置名称</span><br></pre></td></tr></table></figure><ul><li>-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数</li><li>-s : 依序一个一个地执行 fsck 的指令来检查</li><li>-A : 对 /etc/fstab 中所有列出来的 分区（partition）做检查</li><li>-C : 显示完整的检查进度</li><li>-d : 打印出 e2fsck 的 debug 结果</li><li>-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行</li><li>-R : 同时有 -A 条件时，省略 / 不检查</li><li>-V : 详细显示模式</li><li>-a : 如果检查有错则自动修复</li><li>-r : 如果检查有错则由使用者回答是否修复</li><li>-y : 选项指定检测每个文件是自动输入 yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。</li></ul><h3 id="磁盘挂载和删除"><a class="markdownIt-Anchor" href="#磁盘挂载和删除">#</a> 磁盘挂载和删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><ul><li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li><li>-n ：不升级 /etc/mtab 情况下卸除。</li></ul><h2 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理">#</a> 进程管理</h2><blockquote><p>ps -xx</p></blockquote><ul><li>-a 显示当前终端运行的所有的进程信息</li><li>-u 以用户的信息显示进程</li><li>-x 显示后台运行进程的参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ps -aux  查看所有进程</span><br><span class="line">ps -aux | grep mysql  c</span><br><span class="line"># | 在linux中叫做管道符</span><br><span class="line"># grep 查找文件中符合条件的字符串</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="饿汉式单例模式"><a class="markdownIt-Anchor" href="#饿汉式单例模式">#</a> 饿汉式单例模式</h2><p>在程序开始时加载所有对象</p><p>问题：可能只需要部分对象，造成空间浪费</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungryMan</span> &#123;</span><br><span class="line">    <span class="comment">//提前加载对象</span></span><br><span class="line">    <span class="comment">//可能造成空间浪费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bytes0=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bytes1=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bytes2=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bytes3=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">HungryMan</span> <span class="variable">HUNGRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungryMan</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungryMan <span class="title function_">getHungryMan</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式单例模式"><a class="markdownIt-Anchor" href="#懒汉式单例模式">#</a> 懒汉式单例模式</h2><h3 id="非并发下"><a class="markdownIt-Anchor" href="#非并发下">#</a> 非并发下</h3><p>在需要使用该对象时创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要使用时创建</span></span><br><span class="line">    <span class="comment">//以下代码会在并发模式下出现问题，出现多个实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            lazyMan=<span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在问题</strong></p><blockquote><p>当 A，B 并发时，A,B 同时检测到  lazyMan 为 null，并分别创建对象</p></blockquote><h3 id="使用静态内部类"><a class="markdownIt-Anchor" href="#使用静态内部类">#</a> 使用静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">HOLDER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重检测锁模式处理并发问题"><a class="markdownIt-Anchor" href="#双重检测锁模式处理并发问题">#</a> 双重检测锁模式处理并发问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检测锁模式，懒汉式单例，DCL懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">                    lazyMan=<span class="keyword">new</span> <span class="title class_">LazyMan</span>();<span class="comment">//但这不是一个原子性操作</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 1. 分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2. 执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3. 把对象指向这个空间</span></span><br><span class="line"><span class="comment">                     * 底层执行顺序会被打乱(指令重排)</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用反射破坏单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> LazyMan.getInstance();</span><br><span class="line">        Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">LazyMan</span>&gt; declaredConstructor = instance.getClass().getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);<span class="comment">//无视私有构造器</span></span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在问题</strong></p><ol><li>lazyMan=new LazyMan (); 不是一个原子性操作<ul><li>执行过程：<ol><li>分配内存空间</li><li>执行构造方法</li><li>把对象指向这个空间</li></ol></li><li>123 是正常执行流程，但底层执行时会出现指令重排（执行顺序被打乱）</li></ul></li><li>可以通过反射破坏单例模式</li></ol><h3 id="优化"><a class="markdownIt-Anchor" href="#优化">#</a> 优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span><span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">false</span>)&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;实例已被创建&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font color="red">但是！！！</font></p><p>依然可以通过反射破坏 flag，从而破坏单例模式</p><h2 id="枚举单例"><a class="markdownIt-Anchor" href="#枚举单例">#</a> 枚举单例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    EnumSingle()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        EnumSingle instance1=EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        EnumSingle instance2=declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举本身也是一个 Class</p><p>枚举类没有空参构造器</p><p>反射不能破坏枚举的单例模式</p><p>通过 JAD 编译枚举类</p><p><img src="https://s2.loli.net/2022/05/07/87tNqOGwml3sby1.png" alt="在这里插入图片描述"></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h2><ul><li>优点 ：<ul><li>只生成一个实例减少系统性能开销</li><li>可以在系统设置全局的访问点，优化共享资源访问</li></ul></li><li>常见实现方式<ul><li>饿汉式 （线程安全，调用效率高，不能延迟加载）</li><li>懒汉式（线程安全，调用效率不高，可以延迟加载）</li><li>DCL 懒汉式（由于 JVM 底层内部模型原因，偶尔会出现问题，不建议使用）</li><li>饿汉式改进：静态内部类（线程安全，调用效率高，延迟加载）</li><li>枚举单例（线程安全，调用效率高，不能延迟加载）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP七大原则</title>
      <link href="/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>PBP/OBP/OOP 的特征 PBP（基于过程）：函数、域与生命周期的概念、函数重载、函数模板、异常处理、范型算法。 OBP（基于对象）：类（接口）、类的生命周期、类模板。 OOP（面向对象）：继承、多态。 三个概念步步深入，后者包括前者。其目的是实现软件开发的可重用性，解决软件危机（软件工程思想未引入之前）。 OOP 不可避免设计原则的发展与设计模式的产生，这是 OOP 独具的特征决定的（正如前面所说，特征的产生是由其产生目的决定的）。</p></blockquote><blockquote><p>OOP 的方法论：高内聚，低耦合，易复用</p></blockquote><h2 id="oop七大原则"><a class="markdownIt-Anchor" href="#oop七大原则">#</a> OOP 七大原则</h2><h3 id="开闭原则ocp"><a class="markdownIt-Anchor" href="#开闭原则ocp">#</a> 开闭原则 (OCP)</h3><blockquote><p>对扩展开放，对修改关闭</p></blockquote><p>根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。</p><p><strong>扩展开放</strong>：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。</p><p><strong>修改关闭</strong>：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求模块是修改关闭的。</p><h3 id="里氏替换原则lsp"><a class="markdownIt-Anchor" href="#里氏替换原则lsp">#</a> 里氏替换原则 (LSP)</h3><blockquote><p>所有引用基类的地方必须能透明地使用其子类的对象</p></blockquote><blockquote><p>里式替换原则的引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。</p></blockquote><p>​也就是说，只有满足以下 2 个条件的 OO 设计才可被认为是满足了 LSP 原则：</p><p>​1. 不应该在代码中出现 if/else 之类对派生类类型进行判断的条件。</p><p>​2. 派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。</p><h3 id="依赖倒置原则dip"><a class="markdownIt-Anchor" href="#依赖倒置原则dip">#</a> 依赖倒置原则 (DIP)</h3><blockquote><p>高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>面向接口编程，不要面向实现编程</p><h3 id="单一职责原则"><a class="markdownIt-Anchor" href="#单一职责原则">#</a> 单一职责原则</h3><blockquote><p>控制类的粒度大小，将对象解耦，提高其内聚性</p></blockquote><p>单一职责原则：<strong><em>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中</em>。</strong><br>单一职责原则的另一种定义方式：<strong><em>就一个类而言，应该仅有一个引起它变化的原因</em>。</strong></p><h3 id="接口隔离原则isp"><a class="markdownIt-Anchor" href="#接口隔离原则isp">#</a> 接口隔离原则（ISP）</h3><blockquote><p><strong>使用多个专门的接口，而不使用单一 的总接口，即客户端不应该依赖那些它不需要的接口。</strong></p></blockquote><p>​换句话说，使用多个专门的接口比使用单一的总接口总要好。</p><p>它包含了 2 层意思：</p><ol><li><p>接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。</p></li><li><p>接口的依赖（继承）原则：如果一个接口 a 继承另一个接口 b，则接口 a 相当于继承了接口 b 的方法，那么继承了接口 b 后的接口 a 也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口 a 被 b 给污染了，应该重新设计它们的关系。</p></li></ol><p>​根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接 口的客户端仅需知道与之相关的方法即可。</p><h3 id="迪米特法则lod"><a class="markdownIt-Anchor" href="#迪米特法则lod">#</a> 迪米特法则 (LoD)</h3><p>也叫<font color="red">最少知道原则</font></p><blockquote><p>只与直接的朋友交谈，不和 “陌生人 “说话</p></blockquote><p>​迪米特法则可以简单说成：talk only to your immediate friends。 对于 OOD 来说，又被解释为下面几种方式：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p><p>​迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>​迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系 —— 这在一定程度上增加了系统的复杂度。</p><p>​如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><h4 id="lod法则缺点"><a class="markdownIt-Anchor" href="#lod法则缺点">#</a> LoD 法则缺点</h4><p>​在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。</p><p>​遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。</p><h3 id="合成复用原则carp"><a class="markdownIt-Anchor" href="#合成复用原则carp">#</a> 合成复用原则 (CARP)</h3><blockquote><p>尽量先使用组合或者聚合等关联关系来实现，其次考虑使用继承关系来实现</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="本质优点"><a class="markdownIt-Anchor" href="#本质优点">#</a> 本质 &amp; 优点</h2><hr><ul><li><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性，继承性和多态性及类的关联关系和组合关系的充分理解</p></li><li><p>正确使用设计模式的优点</p><ul><li>提高思维，编程和设计能力</li><li>使程序设计标准化，代码编制更加工程化，提高软件开发效率，缩短开发周期</li><li>代码可重用性高，可读性强，可靠性高，灵活性好，可维护性强</li></ul></li></ul><h2 id="设计模式的基本要素"><a class="markdownIt-Anchor" href="#设计模式的基本要素">#</a> 设计模式的基本要素</h2><ul><li><p>模式名称</p><ul><li>GoF23<ul><li>创建型模式：<ul><li>单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式</li></ul></li><li>结构性模式：<ul><li>适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式</li></ul></li><li>行为型模式：<ul><li>模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式</li></ul></li></ul></li></ul></li><li><p>问题</p></li><li><p>解决方案</p></li><li><p>效果</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot拦截器配置方法</title>
      <link href="/2022/05/06/SpringBoot%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>/2022/05/06/SpringBoot%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="项目需求"><a class="markdownIt-Anchor" href="#项目需求">#</a> 项目需求</h2><pre><code>在用户浏览部分页面前，检测用户是否已经登录过，若登录过，则允许访问，若未登陆过，则拦截目标页面的访问，并跳转至登录界面</code></pre><h2 id="配置方法"><a class="markdownIt-Anchor" href="#配置方法">#</a> 配置方法</h2><h3 id="步骤一"><a class="markdownIt-Anchor" href="#步骤一">#</a> 步骤一</h3><p>创建 inteceptor 包，创建 LoginInteceptor 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测全局session对象中是否有uid数据，如果有则放行，若没有则重定向到登陆界面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 处理器（url+Controller，映射）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true则放行，false拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Object obj=request.getSession().getAttribute(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//用户没有登录过系统</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/web/index.html&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤二"><a class="markdownIt-Anchor" href="#步骤二">#</a> 步骤二</h3><pre><code>在config包下创建LoginInterceptorConfig类实现WebMvcConfigure类注册拦截器</code></pre><blockquote><p>registry.addInterceptor () 用于注册拦截器<br> addPathPatterns (&quot;/**&quot;) 意为拦截所有页面，参数是需要拦截的页面<br> excludePathPatterns () 参数是不需要拦截的页面</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    HandlerInterceptor interceptor=<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        List&lt;String&gt; patterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        patterns.add(<span class="string">&quot;/bootstrap3/**&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/css/**&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/images/**&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/web/register.html&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/web/index.html&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/web/login.html&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/web/product.html&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/users/reg&quot;</span>);</span><br><span class="line">        patterns.add(<span class="string">&quot;/users/login&quot;</span>);</span><br><span class="line">        registry.addInterceptor(interceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(patterns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 拦截器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot处理跨域请求的几种方法</title>
      <link href="/2022/05/06/SpringBoot%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022/05/06/SpringBoot%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="error"><a class="markdownIt-Anchor" href="#error">#</a> Error：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://localhost:8080/store/users/reg&#x27; from origin &#x27;http://localhost:52972&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.</span><br></pre></td></tr></table></figure><h2 id="原因"><a class="markdownIt-Anchor" href="#原因">#</a> 原因</h2><blockquote><p>浏览器出于安全考虑，使用 XMLHttpRequest 对象发起 HTTP 请求时必须遵守同源策略 (<strong>要求源相同才能正常进行通信，即协议，域名，端口号都完全一致</strong>)<br> 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p></blockquote><h2 id="方案"><a class="markdownIt-Anchor" href="#方案">#</a> 方案</h2><h3 id="方案一-直接采用springboot的注解crossorigin支持springmvc"><a class="markdownIt-Anchor" href="#方案一-直接采用springboot的注解crossorigin支持springmvc">#</a> 方案一 直接采用 SpringBoot 的注解 @CrossOrigin（支持 SpringMvc）</h3><p>在 Control 层需要跨域的方法或类上增加注解 @CrossOrigin</p><p><font color="red">该注解可继承</font></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="comment">//以json数据格式响应到前端</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">extends</span> <span class="title class_">BaseController</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/reg&quot;)</span></span><br><span class="line">    <span class="meta">@CrossOrigin</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title function_">reg</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        JsonResult&lt;Void&gt; result=<span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;();</span><br><span class="line">        userService.register(user);</span><br><span class="line">        result.setState(<span class="number">200</span>);</span><br><span class="line">        result.setMessage(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-处理跨域请求的configuration"><a class="markdownIt-Anchor" href="#方法二-处理跨域请求的configuration">#</a> 方法二、处理跨域请求的 Configuration</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个配置类，CrossOriginConfig.java。继承WebMvcConfigurerAdapter或者实现WebMvcConfigurer接口，其他都不用管，项目启动时，会自动读取配置。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AJAX请求跨域</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.W</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2018-08-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ORIGINS[] = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span> &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;*&quot;</span>).allowCredentials(<span class="literal">true</span>).allowedMethods(ORIGINS).maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-采用过滤器filter的方式"><a class="markdownIt-Anchor" href="#方法三-采用过滤器filter的方式">#</a> 方法三、采用过滤器（filter）的方式</h3><blockquote><p>同方法二加配置类，增加一个 CORSFilter 类，并实现 Filter 接口即可，其他都不用管，接口调用时，会过滤跨域的拦截。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CORSFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">    res.addHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    res.addHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    res.addHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET, POST, DELETE, PUT&quot;</span>);</span><br><span class="line">    res.addHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type,X-CAF-Authorization-Token,sessionToken,X-TOKEN&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (((HttpServletRequest) request).getMethod().equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传下载功能</title>
      <link href="/2022/05/06/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2022/05/06/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="基于springmvc的文件上传"><a class="markdownIt-Anchor" href="#基于springmvc的文件上传">#</a> 基于 SpringMVC 的文件上传</h2><h3 id="1-multipartfile接口"><a class="markdownIt-Anchor" href="#1-multipartfile接口">#</a> 1 MultipartFile 接口</h3><p>MultipartFile 接口常用的的 API 见下表：</p><table><thead><tr><th style="text-align:left">方法</th><th>功能描述</th></tr></thead><tbody><tr><td style="text-align:left">String getOriginalFilename()</td><td>获取上传文件的原始文件名，即该文件在客户端中的文件名</td></tr><tr><td style="text-align:left">boolean isEmpty()</td><td>判断上传的文件是否为空，当没有选择文件就直接上传，或者选中的文件是 0 字节的空文件时，返回 true，否则返回 false</td></tr><tr><td style="text-align:left">long getSize()</td><td>获取上传的文件大小，以字节为单位</td></tr><tr><td style="text-align:left">String getContentType()</td><td>根据所上传的文件的扩展名决定该文件的 MIME 类型，例如上传.jpg 格式的图片，将返回 image/jpeg</td></tr><tr><td style="text-align:left">InputStream getInputStream()</td><td>获取上传文件的输入字节流，通常用于自定义读取所上传的文件的过程，该方法与 transferTo () 方法不可以同时使用</td></tr><tr><td style="text-align:left">void transferTo(File dest)</td><td>保存上传的文件，该方法与 getInputStream () 方法不可以同时使用</td></tr></tbody></table><h3 id="2-multipartresolver接口"><a class="markdownIt-Anchor" href="#2-multipartresolver接口">#</a> 2 MultipartResolver 接口</h3><p>1.MultipartResolver 可以将上传过程中产生的数据封装为 MultipartFile 类型的对象中。</p><p>2. 在配置 MultipartResovler 时，可以为其中的几个属性注入值：</p><ul><li>maxUploadSize：上传文件的最大大小，假设设置值为 10M，一次性上传 5 个文件，则 5 个文件的大小总和不允许超过 10M。</li><li>maxUploadSizePerFile：每个上传文件的最大大小，假设设置值为 10M，一次性上传 5 个文件，则每个文件的大小都不可以超过 10M，但是 5 个文件的大小总和可以接近 50M。</li><li>defaultEncoding：默认编码。</li></ul><h3 id="3-基于springmvc的文件上传案例"><a class="markdownIt-Anchor" href="#3-基于springmvc的文件上传案例">#</a> 3 基于 SpringMVC 的文件上传案例</h3><h4 id="31-创建项目"><a class="markdownIt-Anchor" href="#31-创建项目">#</a> 3.1 创建项目</h4><p>1. 创建 Java Enterprise 项目，设置 Name 为 springmvc-upload，<a href="http://xn--Groupcom-1g0m.cy">Group 为 com.cy</a>，Artifact 为 controller 的 Java 企业级项目。</p><p>2. 将项目 com.cy.controller 包下自动生成的 HelloServlet 类删除，并删除 webapp 下自动生成的 index.jsp 文件。</p><p>3. 添加文件上传 jar 包依赖（关于文件上传需要添加 spring-webmvc 和 commons-fileupload 依赖）。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文件上传 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4. 在 src\main\resources 文件夹下创建 spring 配置文件，并将文件命名为 spring-upload.xml。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="32-前端页面设计"><a class="markdownIt-Anchor" href="#32-前端页面设计">#</a> 3.2 前端页面设计</h4><p>在 webapp 目录下创建 upload.html 页面，并在页面中添加如下代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文件上传<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>文件上传<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- enctype属性：规定表单中数据在提交给服务器之前如何进行编码。默认表单数据的编码是&quot;application/x-www-form-urlencoded&quot;。</span></span><br><span class="line"><span class="comment">         application/x-www-form-urlencoded：提交前表单中所有数据都会进行编码；编码的规则是：空格转换为&quot;+&quot;加号，特殊符号转换为ASCII HEX值</span></span><br><span class="line"><span class="comment">         text/plain：提交前表单中数据空格转换为&quot;+&quot;加号，但不对特殊字符进行编码。</span></span><br><span class="line"><span class="comment">         multipart/form-data：提交前表单中不对字符进行编码；在使用包含文件上传控件的表单中，必须使用该值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>文件名(N)：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;上传&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：form 表单的请求方式必须设置为 POST，并配置属性 enctype=“multipart/form-data”，文件上传 input 控件的 name 属性值需设置为 file 值。</p></blockquote><h4 id="33-后台功能实现"><a class="markdownIt-Anchor" href="#33-后台功能实现">#</a> 3.3 后台功能实现</h4><p>1. 在 web.xml 文件中配置前端控制器和过滤器，并指定 DispatcherServlet 加载的配置文件 springmvc-upload.xml 的位置。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-upload.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2. 创建 com.cy.controller.UploadController 控制器类，在类的声明之前添加 @Controller 注解，并在控制器中添加处理请求的 upload () 方法，为此方法添加类型为 MultipartFile 接口的参数，并为该参数添加 @RequestParam 注解，表示客户端上传的文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @RequestMapping(&quot;upload.do&quot;)</span></span><br><span class="line"><span class="comment">    @ResponseBody</span></span><br><span class="line"><span class="comment">    public String upload(@RequestParam(&quot;file&quot;) MultipartFile file) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;UploadController.upload()...&quot;);</span></span><br><span class="line"><span class="comment">        File dest = new File(&quot;D:/1.png&quot;);</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            // 调用MultipartFile参数对象的transferTo()方法即可保存上传的文件</span></span><br><span class="line"><span class="comment">            file.transferTo(dest);</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return &quot;OK&quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;upload.do&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(HttpServletRequest request, <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取上传文件的原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 获取上下文的绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;upload&quot;</span>);</span><br><span class="line">        System.out.println(realPath);</span><br><span class="line">        <span class="comment">// 创建File文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(realPath);</span><br><span class="line">        <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自定义上传文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 获取上传文件扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">beginIndex</span> <span class="operator">=</span> originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            suffix = originalFilename.substring(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fullFilename</span> <span class="operator">=</span> fileName + suffix;</span><br><span class="line">        <span class="comment">// 调用MultipartFile参数对象的transferTo()方法即可保存上传的文件</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(dir, fullFilename));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3. 在 springmvc-upload.xml 配置文件中添加组件扫描和 CommonsMultipartResolver 类的 bean 标签配置。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.cy&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- CommonsMultipartResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：CommonsMultipartResolver 类在配置时，id 值必须设置成 multipartResolver。</p></blockquote><p>4. 启动项目，访问 http://localhost:8080/springmvc_upload_war_exploded/upload.html 网址测试文件提交。</p><h2 id="上传头像"><a class="markdownIt-Anchor" href="#上传头像">#</a> 上传头像</h2><h3 id="1-用户-上传头像-持久层"><a class="markdownIt-Anchor" href="#1-用户-上传头像-持久层">#</a> 1 用户 - 上传头像 - 持久层</h3><h4 id="11-规划需要执行的sql语句"><a class="markdownIt-Anchor" href="#11-规划需要执行的sql语句">#</a> 1.1 规划需要执行的 SQL 语句</h4><p>上传文件的操作其实是：先将用户上传的文件保存到服务器端的某个位置，然后将保存文件的路径记录在数据库中。当后续需要使用该文件时，从数据库中读出文件的路径，即可实现在线访问该文件。</p><p>在持久层处理数据库中的数据时，只需要关心如何记录头像文件的路径，并不需要考虑上传时保存文件的过程。所以，需要执行的 SQL 语句大致是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update t_user set avatar=?, modified_user=?, modified_time=? where uid=?</span><br></pre></td></tr></table></figure><h4 id="12-接口与抽象方法"><a class="markdownIt-Anchor" href="#12-接口与抽象方法">#</a> 1.2 接口与抽象方法</h4><p>在 UserMapper 接口中添加 updateAvatarByUid () 抽象方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据uid更新用户的头像</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uid 用户的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> avatar 新头像的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modifiedUser 修改执行人</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modifiedTime 修改时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 受影响的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Integer <span class="title function_">updateAvatarByUid</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;uid&quot;)</span> Integer uid,</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;avatar&quot;)</span> String avatar,</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;modifiedUser&quot;)</span> String modifiedUser,</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;modifiedTime&quot;)</span> Date modifiedTime)</span>;</span><br></pre></td></tr></table></figure><h4 id="13-配置sql映射"><a class="markdownIt-Anchor" href="#13-配置sql映射">#</a> 1.3 配置 SQL 映射</h4><p>1. 在 UserMapper.xml 中配置 updateAvatarByUid () 抽象方法的映射。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据uid更新用户的头像</span></span><br><span class="line"><span class="comment"> Integer updateAvatarByUid(</span></span><br><span class="line"><span class="comment">@Param(&quot;uid&quot;) Integer uid,</span></span><br><span class="line"><span class="comment">@Param(&quot;avatar&quot;) String avatar,</span></span><br><span class="line"><span class="comment">@Param(&quot;modifiedUser&quot;) String modifiedUser,</span></span><br><span class="line"><span class="comment">@Param(&quot;modifiedTime&quot;) Date modifiedTime) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAvatarByUid&quot;</span>&gt;</span></span><br><span class="line">UPDATE</span><br><span class="line">t_user</span><br><span class="line">SET</span><br><span class="line">avatar = #&#123;avatar&#125;,</span><br><span class="line">modified_user = #&#123;modifiedUser&#125;,</span><br><span class="line">modified_time = #&#123;modifiedTime&#125;</span><br><span class="line">WHERE</span><br><span class="line">uid = #&#123;uid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2. 在 UserMapperTests 中编写并执行单元测试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAvatarByUid</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">uid</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="string">&quot;/upload/avatar.png&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">modifiedUser</span> <span class="operator">=</span> <span class="string">&quot;超级管理员&quot;</span>;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">modifiedTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.updateAvatarByUid(uid, avatar, modifiedUser, modifiedTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;rows=&quot;</span> + rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-用户-上传头像-业务层"><a class="markdownIt-Anchor" href="#2-用户-上传头像-业务层">#</a> 2 用户 - 上传头像 - 业务层</h3><h4 id="21-规划异常"><a class="markdownIt-Anchor" href="#21-规划异常">#</a> 2.1 规划异常</h4><p>在修改头像值前先检查用户数据状态，可能抛 UserNotFoundException 异常；由于最终执行的是修改操作还可能抛 UpdateException 异常。</p><h4 id="22-接口与抽象方法"><a class="markdownIt-Anchor" href="#22-接口与抽象方法">#</a> 2.2 接口与抽象方法</h4><p>在 IUserService 中添加 changeAvatar (Integer uid, String username, String avatar) 抽象方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改用户头像</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uid 当前登录的用户的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username 当前登录的用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> avatar 用户的新头像的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">changeAvatar</span><span class="params">(Integer uid, String username, String avatar)</span>;</span><br></pre></td></tr></table></figure><h4 id="23-实现抽象方法"><a class="markdownIt-Anchor" href="#23-实现抽象方法">#</a> 2.3 实现抽象方法</h4><p>1. 在 UserServiceImpl 类中实现 changeAvatar (Integer uid, String username, String avatar) 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeAvatar</span><span class="params">(Integer uid, String username, String avatar)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用userMapper的findByUid()方法，根据参数uid查询用户数据</span></span><br><span class="line">    <span class="comment">// 检查查询结果是否为null</span></span><br><span class="line">    <span class="comment">// 是：抛出UserNotFoundException</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查查询结果中的isDelete是否为1</span></span><br><span class="line">    <span class="comment">// 是：抛出UserNotFoundException</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建当前时间对象</span></span><br><span class="line">    <span class="comment">// 调用userMapper的updateAvatarByUid()方法执行更新，并获取返回值</span></span><br><span class="line">    <span class="comment">// 判断以上返回的受影响行数是否不为1</span></span><br><span class="line">    <span class="comment">// 是：抛了UpdateException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.changeAvatar (Integer uid, String username, String avatar) 方法中代码的具体实现为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeAvatar</span><span class="params">(Integer uid, String username, String avatar)</span> &#123;</span><br><span class="line"><span class="comment">// 调用userMapper的findByUid()方法，根据参数uid查询用户数据</span></span><br><span class="line"><span class="type">User</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.findByUid(uid);</span><br><span class="line"><span class="comment">// 检查查询结果是否为null</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 是：抛出UserNotFoundException</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotFoundException</span>(<span class="string">&quot;用户数据不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查查询结果中的isDelete是否为1</span></span><br><span class="line"><span class="keyword">if</span> (result.getIsDelete().equals(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="comment">// 是：抛出UserNotFoundException</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotFoundException</span>(<span class="string">&quot;用户数据不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建当前时间对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 调用userMapper的updateAvatarByUid()方法执行更新，并获取返回值</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.updateAvatarByUid(uid, avatar, username, now);</span><br><span class="line"><span class="comment">// 判断以上返回的受影响行数是否不为1</span></span><br><span class="line"><span class="keyword">if</span> (rows != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 是：抛出UpdateException</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UpdateException</span>(<span class="string">&quot;更新用户数据时出现未知错误，请联系系统管理员&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3. 在 UserServiceTests 类中进行单元测试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">uid</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;头像管理员&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="string">&quot;/upload/avatar.png&quot;</span>;</span><br><span class="line">        userService.changeAvatar(uid, username, avatar);</span><br><span class="line">        System.out.println(<span class="string">&quot;OK.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServiceException e) &#123;</span><br><span class="line">        System.out.println(e.getClass().getSimpleName());</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-用户-上传头像-控制器"><a class="markdownIt-Anchor" href="#3-用户-上传头像-控制器">#</a> 3 用户 - 上传头像 - 控制器</h3><h4 id="31-处理异常"><a class="markdownIt-Anchor" href="#31-处理异常">#</a> 3.1 处理异常</h4><p>1. 在处理上传文件的过程中，用户可能会选择错误的文件上传，此时就应该抛出对应的异常并进行处理。所以需要创建文件上传相关异常的基类，即在 com.cy.store.controller.ex 包下创建 FileUploadException 类，并继承自 RuntimeException 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.store.service.ex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 文件上传相关异常的基类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileUploadException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileUploadException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileUploadException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileUploadException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">FileUploadException</span><span class="params">(String message, Throwable cause, <span class="type">boolean</span> enableSuppression, <span class="type">boolean</span> writableStackTrace)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause, enableSuppression, writableStackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2. 在处理上传的文件过程中，经分析可能会产生以下异常。这些异常类都需要继承自 FileUploadException 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上传的文件为空</span></span><br><span class="line">cn.tedu.store.controller.ex.FileEmptyException</span><br><span class="line"><span class="comment">// 上传的文件大小超出了限制值</span></span><br><span class="line">cn.tedu.store.controller.ex.FileSizeException</span><br><span class="line"><span class="comment">// 上传的文件类型超出了限制</span></span><br><span class="line">cn.tedu.store.controller.ex.FileTypeException</span><br><span class="line"><span class="comment">// 上传的文件状态异常</span></span><br><span class="line">cn.tedu.store.controller.ex.FileStateException</span><br><span class="line"><span class="comment">// 上传文件时读写异常</span></span><br><span class="line">cn.tedu.store.controller.ex.FileUploadIOException</span><br></pre></td></tr></table></figure><p>3. 创建 FileEmptyException 异常类，并继承 FileUploadException 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.store.service.ex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 上传的文件为空的异常，例如没有选择上传的文件就提交了表单，或选择的文件是0字节的空文件 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEmptyException</span> <span class="keyword">extends</span> <span class="title class_">FileUploadException</span> &#123;</span><br><span class="line">    <span class="comment">// Override Methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4. 创建 FileSizeException 异常类，并继承 FileUploadException 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.store.service.ex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 上传的文件的大小超出了限制值 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSizeException</span> <span class="keyword">extends</span> <span class="title class_">FileUploadException</span> &#123;</span><br><span class="line">    <span class="comment">// Override Methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5. 创建 FileTypeException 异常类，并继承 FileUploadException 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.store.service.ex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 上传的文件类型超出了限制 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTypeException</span> <span class="keyword">extends</span> <span class="title class_">FileUploadException</span> &#123;</span><br><span class="line">    <span class="comment">// Override Methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6. 创建 FileStateException 异常类，并继承 FileUploadException 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.store.service.ex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 上传的文件状态异常 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileStateException</span> <span class="keyword">extends</span> <span class="title class_">FileUploadException</span> &#123;</span><br><span class="line">    <span class="comment">// Override Methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7. 创建 FileUploadIOException 异常类，并继承 FileUploadException 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.store.service.ex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 上传文件时读写异常 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadIOException</span> <span class="keyword">extends</span> <span class="title class_">FileUploadException</span> &#123;</span><br><span class="line">    <span class="comment">// Override Methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8. 然后在 BaseController 的 handleException () 的 @ExceptionHandler 注解中添加 FileUploadException.class 异常的处理；最后在方法中处理这些异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(&#123;ServiceException.class, FileUploadException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title function_">handleException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">JsonResult&lt;Void&gt; result = <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;Void&gt;(e);</span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">instanceof</span> UsernameDuplicateException) &#123;</span><br><span class="line">result.setState(<span class="number">4000</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> UserNotFoundException) &#123;</span><br><span class="line">result.setState(<span class="number">4001</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> PasswordNotMatchException) &#123;</span><br><span class="line">result.setState(<span class="number">4002</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InsertException) &#123;</span><br><span class="line">result.setState(<span class="number">5000</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> UpdateException) &#123;</span><br><span class="line">result.setState(<span class="number">5001</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FileEmptyException) &#123;</span><br><span class="line">result.setState(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FileSizeException) &#123;</span><br><span class="line">result.setState(<span class="number">6001</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FileTypeException) &#123;</span><br><span class="line">result.setState(<span class="number">6002</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FileStateException) &#123;</span><br><span class="line">result.setState(<span class="number">6003</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FileUploadIOException) &#123;</span><br><span class="line">result.setState(<span class="number">6004</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="32-设计请求"><a class="markdownIt-Anchor" href="#32-设计请求">#</a> 3.2 设计请求</h4><p>设计用户提交的请求，并设计响应的方式：</p><pre><code>请求路径：/users/change_avatar请求参数：MultipartFile file, HttpSession session请求类型：POST响应结果：JsonResult&lt;String&gt;</code></pre><h4 id="33-处理请求"><a class="markdownIt-Anchor" href="#33-处理请求">#</a> 3.3 处理请求</h4><p>1. 在 UserController 类中添加处理请求的 changeAvatar (@RequestParam (“file”) MultipartFile file, HttpSession session) 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;change_avatar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult&lt;String&gt; <span class="title function_">changeAvatar</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpSession session)</span> &#123;</span><br><span class="line"><span class="comment">// 判断上传的文件是否为空</span></span><br><span class="line"><span class="comment">// 是：抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断上传的文件大小是否超出限制值</span></span><br><span class="line"><span class="comment">// 是：抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断上传的文件类型是否超出限制</span></span><br><span class="line"><span class="comment">// 是：抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前项目的绝对磁盘路径</span></span><br><span class="line"><span class="comment">// 保存头像文件的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存的头像文件的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件对象，表示保存的头像文件</span></span><br><span class="line"><span class="comment">// 执行保存头像文件</span></span><br><span class="line"><span class="comment">// 如果产生异常则抛出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头像路径</span></span><br><span class="line"><span class="comment">// 从Session中获取uid和username</span></span><br><span class="line"><span class="comment">// 将头像写入到数据库中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回成功和头像路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.changeAvatar (@RequestParam (“file”) MultipartFile file, HttpSession session) 方法中具体代码实现为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 头像文件大小的上限值(10MB) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AVATAR_MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/** 允许上传的头像的文件类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; AVATAR_TYPES = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 初始化允许上传的头像的文件类型 */</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">AVATAR_TYPES.add(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">AVATAR_TYPES.add(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">AVATAR_TYPES.add(<span class="string">&quot;image/bmp&quot;</span>);</span><br><span class="line">AVATAR_TYPES.add(<span class="string">&quot;image/gif&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;change_avatar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult&lt;String&gt; <span class="title function_">changeAvatar</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpSession session)</span> &#123;</span><br><span class="line"><span class="comment">// 判断上传的文件是否为空</span></span><br><span class="line"><span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 是：抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileEmptyException</span>(<span class="string">&quot;上传的头像文件不允许为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断上传的文件大小是否超出限制值</span></span><br><span class="line"><span class="keyword">if</span> (file.getSize() &gt; AVATAR_MAX_SIZE) &#123; <span class="comment">// getSize()：返回文件的大小，以字节为单位</span></span><br><span class="line"><span class="comment">// 是：抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileSizeException</span>(<span class="string">&quot;不允许上传超过&quot;</span> + (AVATAR_MAX_SIZE / <span class="number">1024</span>) + <span class="string">&quot;KB的头像文件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断上传的文件类型是否超出限制</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> file.getContentType();</span><br><span class="line"><span class="comment">// public boolean list.contains(Object o)：当前列表若包含某元素，返回结果为true；若不包含该元素，返回结果为false。</span></span><br><span class="line"><span class="keyword">if</span> (!AVATAR_TYPES.contains(contentType)) &#123;</span><br><span class="line"><span class="comment">// 是：抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileTypeException</span>(<span class="string">&quot;不支持使用该类型的文件作为头像，允许的文件类型：\n&quot;</span> + AVATAR_TYPES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前项目的绝对磁盘路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> session.getServletContext().getRealPath(<span class="string">&quot;upload&quot;</span>);</span><br><span class="line"><span class="comment">// 保存头像文件的文件夹</span></span><br><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent);</span><br><span class="line"><span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">dir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存的头像文件的文件名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line"><span class="type">int</span> <span class="variable">beginIndex</span> <span class="operator">=</span> originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (beginIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">suffix = originalFilename.substring(beginIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件对象，表示保存的头像文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir, filename);</span><br><span class="line"><span class="comment">// 执行保存头像文件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">file.transferTo(dest);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileStateException</span>(<span class="string">&quot;文件状态异常，可能文件已被移动或删除&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileUploadIOException</span>(<span class="string">&quot;上传文件时读写错误，请稍后重尝试&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头像路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="string">&quot;/upload/&quot;</span> + filename;</span><br><span class="line"><span class="comment">// 从Session中获取uid和username</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">uid</span> <span class="operator">=</span> getUidFromSession(session);</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getUsernameFromSession(session);</span><br><span class="line"><span class="comment">// 将头像写入到数据库中</span></span><br><span class="line">userService.changeAvatar(uid, username, avatar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回成功头像路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;String&gt;(OK, avatar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-用户-上传头像-设置上传文件大小"><a class="markdownIt-Anchor" href="#4-用户-上传头像-设置上传文件大小">#</a> 4 用户 - 上传头像 - 设置上传文件大小</h3><p>1.SpringBoot 中默认 MultipartResolver 的最大文件大小值为 1M。如果上传的文件的大小超过 1M，会抛 FileSizeLimitExceededException 异常。</p><p>[外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-bRrqkhoI-1650868471285)(img/2.png)]</p><p>2. 如果需要调整上传的限制值，直接在启动类中添加 getMultipartConfigElement () 方法，并且在启动类之前添加 @Configuration 注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.store;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.MultipartConfigFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.unit.DataSize;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.unit.DataUnit;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.MultipartConfigElement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.cy.store.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoreApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(StoreApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MultipartConfigElement <span class="title function_">getMultipartConfigElement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MultipartConfigFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipartConfigFactory</span>();</span><br><span class="line">        <span class="comment">// DataSize dataSize = DataSize.ofMegabytes(10);</span></span><br><span class="line">        <span class="comment">// 设置文件最大10M，DataUnit提供5中类型B,KB,MB,GB,TB</span></span><br><span class="line">        factory.setMaxFileSize(DataSize.of(<span class="number">10</span>, DataUnit.MEGABYTES));</span><br><span class="line">        factory.setMaxRequestSize(DataSize.of(<span class="number">10</span>, DataUnit.MEGABYTES));</span><br><span class="line">        <span class="comment">// 设置总上传数据总大小10M</span></span><br><span class="line">        <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3. 除了以上编写方法配置上传的上限值以外，还可以通过在 application.properties 或 application.yml 中添加配置来实现。</p><p>(1) 低版本：1.X</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.http.multipart.max-file-size</span>=<span class="string">10MB</span></span><br><span class="line"><span class="attr">spring.http.multipart.max-request-size</span>=<span class="string">10MB</span></span><br></pre></td></tr></table></figure><p>(2) 高版本：2.X</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方式1</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-file-size</span>=<span class="string">10MB</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-request-size</span>=<span class="string">10MB</span></span><br><span class="line"><span class="comment">#方式2</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.maxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.maxRequestSize</span>=<span class="string">10MB</span></span><br></pre></td></tr></table></figure><h2 id="基于springbootmybatisplus"><a class="markdownIt-Anchor" href="#基于springbootmybatisplus">#</a> 基于 SpringBoot+mybatisPlus</h2><h3 id="上传"><a class="markdownIt-Anchor" href="#上传">#</a> 上传</h3><p><strong>文件上传时，对页面的 form 表单有如下要求</strong></p><ul><li><p>method = “post”----------------- 采用 post 方式提交数据</p></li><li><p>enctype = “multipart/form-data”---- 采用 multipart 格式上传文件</p></li><li><p>type = “file”--------------------- 使用 input 的 file 控件上传</p></li></ul><p>服务端要接收客户端页面上传的文件，通常使用 Apache 的两个组件：</p><ul><li>commons-fileupload</li><li>commons-io</li></ul><p>Spring 框架在 spring-web 包中对文件上传进行了封装，只需要在 Controller 方法中声明一个 MultipartFile 类型的参数即可接收上传的文件</p><h3 id="下载"><a class="markdownIt-Anchor" href="#下载">#</a> 下载</h3><p>通过浏览器进行文件下载，通常有两种形式</p><ul><li>以附件形式下载，退出保存对话框，将文件保存到指定磁盘目录</li><li>直接在浏览器中打开</li></ul><p>通过浏览器下载文件，本质是服务端将文件以流的形式写回浏览器的过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件，参数名与input组件的name属性保持一致</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>&#123;</span><br><span class="line">        <span class="comment">//这里file为临时文件形式（拓展名.tmp）</span></span><br><span class="line">        log.info(<span class="string">&quot;文件上传:&#123;&#125;&quot;</span>,file.getOriginalFilename());</span><br><span class="line">        <span class="comment">//转存文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString()+suffix;</span><br><span class="line">        <span class="comment">//创建目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">        <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + fileName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.success(basePath+fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String name, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath+name));</span><br><span class="line">                <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        ) &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len=fileInputStream.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger配置</title>
      <link href="/2022/05/06/Swagger%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/05/06/Swagger%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一款致力于解决接口规范化，标准化，文档化的开源库<br>一款可以根据 restful 风格生成的接口开发文档，并且支持做测试的一款中间软件</p></blockquote><p>使用 Swagger 你只需要按照它的规范去定义接口以及接口相关信息，再通过 Swagger 衍生出一系列的项目和工具，生成接口文档</p><h2 id="springboot项目嵌入swagger"><a class="markdownIt-Anchor" href="#springboot项目嵌入swagger">#</a> SpringBoot 项目嵌入 Swagger</h2><h3 id="引入依赖"><a class="markdownIt-Anchor" href="#引入依赖">#</a> 引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建配置swagger配置类"><a class="markdownIt-Anchor" href="#创建配置swagger配置类">#</a> 创建配置 Swagger 配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Swagger2的Bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                <span class="comment">//是否启用Swagger</span></span><br><span class="line">                .enable(<span class="literal">true</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//RequestHandlerSelectors配置要扫描接口的方式</span></span><br><span class="line">                <span class="comment">//basePackage指定要扫描的包</span></span><br><span class="line">                <span class="comment">//any()扫描全部</span></span><br><span class="line">                <span class="comment">//none()不扫描</span></span><br><span class="line">                <span class="comment">//withClassAnnotation:扫描类上的注解</span></span><br><span class="line">                <span class="comment">//withMethodAnnotation:扫描方法上的注解</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.bigcat.admin.cnotroller&quot;</span>))</span><br><span class="line">                <span class="comment">//path()过滤路径</span></span><br><span class="line">                .paths(PathSelectors.ant(<span class="string">&quot;/bigcat/**&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Swagger信息 apiInfo</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfo</span>(<span class="string">&quot;Api Documentation标题&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Api Documentation描述&quot;</span>,</span><br><span class="line">                <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;https://blog.kuangstudy.com/&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;YiMing&quot;</span>,<span class="string">&quot;https://blog.kuangstudy.com&quot;</span>,<span class="string">&quot;248099287@qq.com&quot;</span>),</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;https://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关于高版本springboot整合swagger2出现error的解决方案"><a class="markdownIt-Anchor" href="#关于高版本springboot整合swagger2出现error的解决方案">#</a> 关于高版本 SpringBoot 整合 Swagger2 出现 Error 的解决方案</h2><h3 id="方案一"><a class="markdownIt-Anchor" href="#方案一">#</a> 方案一：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">pathmatch:</span></span><br><span class="line">      <span class="attr">matching-strategy:</span> <span class="string">ANT_PATH_MATCHER</span></span><br></pre></td></tr></table></figure><h3 id="方案二"><a class="markdownIt-Anchor" href="#方案二">#</a> 方案二：</h3><p>配置 WebMvcConfigure.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfigurer</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发现如果继承了WebMvcConfigurationSupport，则在yml中配置的相关内容会失效。 需要重新指定静态资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>).addResourceLocations(</span><br><span class="line">                <span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;swagger-ui.html&quot;</span>, <span class="string">&quot;doc.html&quot;</span>).addResourceLocations(</span><br><span class="line">                <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(</span><br><span class="line">                <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.addResourceHandlers(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="swagger增强"><a class="markdownIt-Anchor" href="#swagger增强">#</a> Swagger 增强</h2><p>knife4j 是为 Java MVC 框架集成 Swagger 生成 Api 文档的增强解决方案</p><p><strong>引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在 WebMvcConfig 类上加入注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br></pre></td></tr></table></figure><p>在 WebMvcConfig 类中增加如下方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Swagger2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">               .apiInfo(apiInfo())</span><br><span class="line">               .select()</span><br><span class="line">               .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.prehitting.admin.controller&quot;</span>))</span><br><span class="line">               .paths(PathSelectors.any())</span><br><span class="line">               .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">               .title(<span class="string">&quot;瑞吉外卖&quot;</span>)</span><br><span class="line">               .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">               .description(<span class="string">&quot;瑞吉外卖项目接口文档&quot;</span>)</span><br><span class="line">               .build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>设置静态资源映射</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/backend/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/backend/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/front/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/front/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/METE-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/METE-INF/resources/webjars&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>配置不需要拦截的请求路径</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;/doc.html&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/swagger-resources&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/v2/api-docs&quot;</span></span><br></pre></td></tr></table></figure><h3 id="常用注解"><a class="markdownIt-Anchor" href="#常用注解">#</a> 常用注解</h3><table><thead><tr><th>@Api</th><th>用于请求的类上，比如 Controller，表示对类的说明</th></tr></thead><tbody><tr><td>@ApiModel</td><td>用在类上，通常是表示实体类，表示一个返回响应数据的信息</td></tr><tr><td>@ApiModelProperty</td><td>用在效应类的属性上</td></tr><tr><td>@ApiOperation</td><td>用在请求的方法上，说明方法的用途，作用</td></tr><tr><td>@ApilmplicitParams</td><td>用在用在请求的方法上，表示一组参数的说明</td></tr><tr><td>@ApilmplicitParam</td><td>用在 @ApilmplicitParams 注解中，指定一个请求参数的各个方面</td></tr><tr><td>@ApiParam</td><td>直接作用于请求方法的参数</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
