{
    "version": "https://jsonfeed.org/version/1",
    "title": "不利索の鸣 • All posts by \"spring\" category",
    "description": "欢迎来到鸣崽的空间，这里不仅有学习，还有生活",
    "home_page_url": "https://prehitting.gitee.io",
    "items": [
        {
            "id": "https://prehitting.gitee.io/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/",
            "url": "https://prehitting.gitee.io/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/",
            "title": "Spring如何解决循环依赖问题",
            "date_published": "2022-06-19T12:32:01.000Z",
            "content_html": "<h2 id=\"先上解决方案\"><a class=\"markdownIt-Anchor\" href=\"#先上解决方案\">#</a> 先上解决方案：</h2>\n<p>@Lazy</p>\n<p><strong>Spring 高频面试题：如何解决循环依赖问题！</strong></p>\n<h2 id=\"循环依赖问题全景图\"><a class=\"markdownIt-Anchor\" href=\"#循环依赖问题全景图\">#</a> <strong>循环依赖问题全景图</strong></h2>\n<p><img src=\"/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/1620.png\" alt=\"img\"></p>\n<h2 id=\"什么是循环依赖问题\"><a class=\"markdownIt-Anchor\" href=\"#什么是循环依赖问题\">#</a> <strong>什么是循环依赖问题？</strong></h2>\n<blockquote>\n<p>❝类与类之间的依赖关系形成了闭环，就会导致循环依赖问题的产生。 ❞</p>\n<p>❝比如下图中 A 类依赖了 B 类，B 类依赖了 C 类，而最后 C 类又依赖了 A 类，这样就形成了循环依赖问题。 ❞</p>\n</blockquote>\n<p><img src=\"/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/1620-16556419433531.png\" alt=\"img\"></p>\n<h2 id=\"循环依赖问题案例分析\"><a class=\"markdownIt-Anchor\" href=\"#循环依赖问题案例分析\">#</a> <strong>循环依赖问题案例分析</strong></h2>\n<p>演示代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassA</span> <span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">private</span> ClassB classB<span class=\"token punctuation\">;</span>\n\n <span class=\"token keyword\">public</span> ClassB <span class=\"token function\">getClassB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> classB<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setClassB</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ClassB classB</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>classB <span class=\"token operator\">=</span> classB<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassB</span> <span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">private</span> ClassA classA<span class=\"token punctuation\">;</span>\n\n <span class=\"token keyword\">public</span> ClassA <span class=\"token function\">getClassA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> classA<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setClassA</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ClassA classA</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>classA <span class=\"token operator\">=</span> classA<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>复制</p>\n<p>配置文件：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>xml version<span class=\"token operator\">=</span><span class=\"token string\">\"1.0\"</span> encoding<span class=\"token operator\">=</span><span class=\"token string\">\"UTF-8\"</span><span class=\"token operator\">?</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>beans xmlns<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.springframework.org/schema/beans\"</span>\n <span class=\"token literal-property property\">xmlns</span><span class=\"token operator\">:</span>xsi<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n <span class=\"token literal-property property\">xsi</span><span class=\"token operator\">:</span>schemaLocation<span class=\"token operator\">=</span>\"http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>beans\n        <span class=\"token literal-property property\">http</span><span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>beans<span class=\"token operator\">/</span>spring<span class=\"token operator\">-</span>beans<span class=\"token punctuation\">.</span>xsd\"<span class=\"token operator\">></span>\n\n <span class=\"token operator\">&lt;</span>bean id<span class=\"token operator\">=</span><span class=\"token string\">\"classA\"</span> <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"ioc.cd.ClassA\"</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>property name<span class=\"token operator\">=</span><span class=\"token string\">\"classB\"</span> ref<span class=\"token operator\">=</span><span class=\"token string\">\"classB\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>property<span class=\"token operator\">></span>\n <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>bean<span class=\"token operator\">></span>\n <span class=\"token operator\">&lt;</span>bean id<span class=\"token operator\">=</span><span class=\"token string\">\"classB\"</span> <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"ioc.cd.ClassB\"</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>property name<span class=\"token operator\">=</span><span class=\"token string\">\"classA\"</span> ref<span class=\"token operator\">=</span><span class=\"token string\">\"classA\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>property<span class=\"token operator\">></span>\n <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>bean<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>beans<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>复制</p>\n<p>测试代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">@Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> throws Exception <span class=\"token punctuation\">&#123;</span>\n <span class=\"token comment\">// 创建IoC容器，并进行初始化</span>\n String resource <span class=\"token operator\">=</span> <span class=\"token string\">\"spring/spring-ioc-circular-dependency.xml\"</span><span class=\"token punctuation\">;</span>\n ApplicationContext context <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassPathXmlApplicationContext</span><span class=\"token punctuation\">(</span>resource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token comment\">// 获取ClassA的实例（此时会发生循环依赖）</span>\n ClassA classA <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ClassA<span class=\"token punctuation\">)</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>ClassA<span class=\"token punctuation\">.</span>class<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>复制</p>\n<p>通过 Spring IOC 流程的源码分析循环依赖问题：</p>\n<p><img src=\"/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/1620-16556419433542.png\" alt=\"img\"></p>\n<h2 id=\"以上案例有几种循环依赖问题\"><a class=\"markdownIt-Anchor\" href=\"#以上案例有几种循环依赖问题\">#</a> <strong>以上案例有几种循环依赖问题？</strong></h2>\n<p>循环依赖问题在 Spring 中主要有三种情况：</p>\n<ul>\n<li>通过构造方法进行依赖注入时产生的循环依赖问题。</li>\n<li>通过 setter 方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</li>\n<li>通过 setter 方法进行依赖注入且是在单例模式下产生的循环依赖问题。</li>\n</ul>\n<blockquote>\n<p>❝注意：在 Spring 中，只有【第三种方式】的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。 ❞</p>\n</blockquote>\n<p>其实也很好解释:</p>\n<ul>\n<li>第一种构造方法注入的情况下，在 new 对象的时候就会堵塞住了，其实也就是” 先有鸡还是先有蛋 “的历史难题。</li>\n<li>第二种 setter 方法 &amp;&amp; 多例的情况下，每一次 getBean () 时，都会产生一个新的 Bean，如此反复下去就会有无穷无尽的 Bean 产生了，最终就会导致 OOM 问题的出现。</li>\n</ul>\n<h2 id=\"如何解决循环依赖问题\"><a class=\"markdownIt-Anchor\" href=\"#如何解决循环依赖问题\">#</a> <strong>如何解决循环依赖问题？</strong></h2>\n<p>那 Spring 到底是如何解决的 setter 方法依赖注入引起的循环依赖问题呢？请看下图（其实主要是通过两个缓存来解决的）：</p>\n<p><img src=\"/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/1620-16556419433543.png\" alt=\"img\"></p>\n<h2 id=\"spring三大缓存介绍\"><a class=\"markdownIt-Anchor\" href=\"#spring三大缓存介绍\">#</a> <strong>Spring 三大缓存介绍</strong></h2>\n<p>Spring 中有三个缓存，用于存储单例的 Bean 实例，这三个缓存是彼此互斥的，不会针对同一个 Bean 的实例同时存储。</p>\n<blockquote>\n<p>❝如果调用 getBean，则需要从三个缓存中依次获取指定的 Bean 实例。读取顺序依次是一级缓存–&gt; 二级缓存–&gt; 三级缓存 ❞</p>\n</blockquote>\n<p><img src=\"/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/1620-16556419433544.png\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">一级缓存：Map&lt;String, Object&gt; singletonObjects<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"第一级缓存的作用\"><a class=\"markdownIt-Anchor\" href=\"#第一级缓存的作用\">#</a> <strong>第一级缓存的作用？</strong></h3>\n<ul>\n<li>用于存储单例模式下创建的 Bean 实例（已经创建完毕）。</li>\n<li>该缓存是对外使用的，指的就是使用 Spring 框架的程序员。</li>\n</ul>\n<h3 id=\"存储什么数据\"><a class=\"markdownIt-Anchor\" href=\"#存储什么数据\">#</a> <strong>存储什么数据？</strong></h3>\n<ul>\n<li>K：bean 的名称</li>\n<li>V：bean 的实例对象（有代理对象则指的是代理对象，已经创建完毕）</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">第二级缓存：Map&lt;String, Object&gt; earlySingletonObjects<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"第二级缓存的作用\"><a class=\"markdownIt-Anchor\" href=\"#第二级缓存的作用\">#</a> <strong>第二级缓存的作用？</strong></h3>\n<ul>\n<li>用于存储单例模式下创建的 Bean 实例（该 Bean 被提前暴露的引用，该 Bean 还在创建中）。</li>\n<li>该缓存是对内使用的，指的就是 Spring 框架内部逻辑使用该缓存。</li>\n<li>为了解决第一个 classA 引用最终如何替换为代理对象的问题（如果有代理对象）请爬楼参考演示案例</li>\n</ul>\n<h3 id=\"存储什么数据-2\"><a class=\"markdownIt-Anchor\" href=\"#存储什么数据-2\">#</a> <strong>存储什么数据？</strong></h3>\n<ul>\n<li>K：bean 的名称</li>\n<li>V：bean 的实例对象（有代理对象则指的是代理对象，该 Bean 还在创建中）</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">第三级缓存：Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"第三级缓存的作用\"><a class=\"markdownIt-Anchor\" href=\"#第三级缓存的作用\">#</a> <strong>第三级缓存的作用？</strong></h3>\n<p>通过 ObjectFactory 对象来存储单例模式下提前暴露的 Bean 实例的引用（正在创建中）。该缓存是对内使用的，指的就是 Spring 框架内部逻辑使用该缓存。此缓存是解决循环依赖最大的功臣</p>\n<h3 id=\"存储什么数据-3\"><a class=\"markdownIt-Anchor\" href=\"#存储什么数据-3\">#</a> <strong>存储什么数据？</strong></h3>\n<ul>\n<li>K：bean 的名称</li>\n<li>V：ObjectFactory，该对象持有提前暴露的 bean 的引用</li>\n</ul>\n<p><img src=\"/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/1620-16556419433545.png\" alt=\"img\"></p>\n<blockquote>\n<p>❝为什么第三级缓存要使用 ObjectFactory？需要提前产生代理对象。 ❞</p>\n</blockquote>\n<p><img src=\"/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/1620-16556419433546.png\" alt=\"img\"></p>\n<blockquote>\n<p>❝什么时候将 Bean 的引用提前暴露给第三级缓存的 ObjectFactory 持有？时机就是在第一步实例化之后，第二步依赖注入之前，完成此操作。 ❞</p>\n</blockquote>\n<p><img src=\"/2022/06/19/spring-ru-he-jie-jue-xun-huan-yi-lai-wen-ti/1620-16556419433547.png\" alt=\"img\"></p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> <strong>总结</strong></h3>\n<p>以上就是 Spring 解决循环依赖的关键点！总结来说，就是要搞清楚以下几点：</p>\n<ul>\n<li>搞清楚 Spring 三级缓存的作用？</li>\n<li>搞清楚第三级缓存中 ObjectFactory 的作用？</li>\n<li>搞清楚为什么需要第二级缓存？</li>\n<li>搞清楚什么时候使用三级缓存（添加和查询操作）？</li>\n<li>搞清楚什么时候使用二级缓存（添加和查询操作）？</li>\n<li>当目标对象产生代理对象时，Spring<a href=\"https://cloud.tencent.com/product/tke?from=10680\"> 容器</a>中（第一级缓存）到底存储的是谁？</li>\n</ul>\n",
            "tags": [
                "Spring"
            ]
        },
        {
            "id": "https://prehitting.gitee.io/2022/05/31/spring-zhong-wei-shi-me-bu-tui-jian-shi-yong-zi-duan-zhu-ru/",
            "url": "https://prehitting.gitee.io/2022/05/31/spring-zhong-wei-shi-me-bu-tui-jian-shi-yong-zi-duan-zhu-ru/",
            "title": "Spring中为什么不推荐使用字段注入",
            "date_published": "2022-05-31T11:01:19.000Z",
            "content_html": "<blockquote>\n<p>在使用 Idea 中通过注解注入字段时是否遇见过这样一个提示：</p>\n<p>Field injection is not recommended（不推荐使用字段注入）</p>\n</blockquote>\n<h2 id=\"一-什么是字段注入spring中依赖注入的方式有哪些\"><a class=\"markdownIt-Anchor\" href=\"#一-什么是字段注入spring中依赖注入的方式有哪些\">#</a> 一。什么是字段注入，Spring 中依赖注入的方式有哪些？</h2>\n<p>在 Spring 中依赖注入有三大类：字段注入、构造器注入、Setter 方法注入。</p>\n<p>字段注入是将 Bean 作为字段注入到类中，也是最方便，用的最多的注入方式。</p>\n<h2 id=\"二-官方为什么不推荐使用字段注入\"><a class=\"markdownIt-Anchor\" href=\"#二-官方为什么不推荐使用字段注入\">#</a> 二。官方为什么不推荐使用字段注入</h2>\n<h3 id=\"首先来看字段注入\"><a class=\"markdownIt-Anchor\" href=\"#首先来看字段注入\">#</a> 首先来看字段注入</h3>\n<blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@RestController\npublic class TestHandleController &#123;\n\n    @Autowired\n    TestHandleService testHandleService;\n\n    public void helloTestService()&#123;\n        testHandleService.hello();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<p>字段注入的非常的简便，通过以上代码我们就可以轻松的使用 TestHandleService 类，但是如果变成下面这样呢：</p>\n<blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">TestHandleController testHandle &#x3D; new TestHandleController();\ntestHandle.helloTestService();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</blockquote>\n<p>这样执行结果为空指针异常，这就是字段注入的第一个问题：** 对象的外部可见性，** 无法在容器外部实例化 TestHandleService（例如在测试类中无法注入该组件），类和容器的耦合度过高，无法脱离容器访问目标对象。</p>\n<p>接下来看第二段代码：</p>\n<blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class TestA()&#123;\n\n    @Autowired\n    private TestB testB;\n\n&#125;\n\npublic class TestB()&#123;\n\n    @Autowired\n    private TestA testA;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<p>这段代码在 idea 中不会报任何错误，但是当你启动项目时会发现报错，大致意思是：创建 Bean 失败，原因是当前 Bean 已经作为循环引用的一部分注入到了其他 Bean 中。</p>\n<p>这就是字段注入的第二个问题：<strong>可能导致循环依赖</strong></p>\n<p>字段注入还有第三个问题：** 无法设置注入的对象为 final，也无法注入静态变量，** 原因是变量必须在类实例化进行初始化。</p>\n<p>整理一下，字段注入可能引起的三个问题：</p>\n<ol>\n<li>\n<p><strong>对象的外部可见性</strong></p>\n</li>\n<li>\n<p><strong>可能导致循环依赖</strong></p>\n</li>\n<li>\n<p><strong>无法设置注入的对象为 final，也无法注入静态变量</strong></p>\n</li>\n</ol>\n<hr>\n<h3 id=\"接下来看构造器注入官方推荐的注入方式\"><a class=\"markdownIt-Anchor\" href=\"#接下来看构造器注入官方推荐的注入方式\">#</a> 接下来看构造器注入–官方推荐的注入方式</h3>\n<p>使用形式也很简单：</p>\n<blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private TestHandleService testHandleService;\n\n@Autowired\npublic TestHandleController(TestHandleService testHandleService)&#123;\n    this.testHandleService &#x3D; testHandleService;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<p>通过构造器的方式将 Bean 注入到字段中。</p>\n<p>构造器注入能够保证注入的组件不可变，并且确保需要的依赖不为空。</p>\n<p>这样就可以将变量设置为 final，并且传递的肯定是一个对象，避免出现空指针异常。</p>\n<p>若是出现字段注入中循环依赖的问题，在项目启动时 Spring 会非常形象的将错误抛出来：</p>\n<blockquote>\n<p>Description:</p>\n<p>The dependencies of some of the beans in the application context form a cycle:</p>\n<p>testContrtoller (field private com.example.designstudy.service.TestService com.example.designstudy.controller.TestContrtoller.testService)<br>\n┌─────┐<br>\n| testService defined in file [D:\\design-study\\target\\classes\\com\\example\\designstudy\\service\\TestService.class]<br>\n↑ ↓<br>\n| testHandleServiceImpl defined in file [D:\\design-study\\target\\classes\\com\\example\\designstudy\\service\\impl\\TestHandleServiceImpl.class]<br>\n└─────┘</p>\n</blockquote>\n<p>显而易见的发现错误的地方。</p>\n<p>由此可见，字段注入的三大问题都能解决，但是构造器注入就没有其他问题了吗？</p>\n<p>答案肯定是否定的，当依赖的对象很多时，需要严格按照构造器的顺序去填写依赖的对象，这将导致代码可读性和可维护性变得很差。</p>\n<p>这时候可以引入 Setter 方法进行注入，Setter 方法和构造器注入很像，不过 Setter 更具有可读性。</p>\n<p>并且使用 Setter 方法注入可以实现按需注入，不使用的对象不需要想构造器注入一样强制注入。</p>\n<p><strong>总结一下三种注入方式：</strong></p>\n<blockquote>\n<p><strong>构造器注入适用于强制对象注入</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>Setter 注入适合可选对象注入</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>字段注入方式应该尽量避免，因为对象无法脱离容器独立运行（话虽这么说，但我还是字段注入用得多，因为方便啊 [/ 狗头]）</strong></p>\n</blockquote>\n",
            "tags": [
                "Spring"
            ]
        }
    ]
}