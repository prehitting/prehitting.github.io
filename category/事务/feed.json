{
    "version": "https://jsonfeed.org/version/1",
    "title": "不利索の鸣 • All posts by \"事务\" category",
    "description": "欢迎来到鸣崽的空间，这里不仅有学习，还有生活",
    "home_page_url": "https://prehitting.gitee.io",
    "items": [
        {
            "id": "https://prehitting.gitee.io/2022/05/18/Redis/%E4%BA%8B%E5%8A%A1/",
            "url": "https://prehitting.gitee.io/2022/05/18/Redis/%E4%BA%8B%E5%8A%A1/",
            "title": "事务",
            "date_published": "2022-05-18T03:41:50.000Z",
            "content_html": "<h2 id=\"事务\"><a class=\"markdownIt-Anchor\" href=\"#事务\">#</a> 事务</h2>\n<hr>\n<p>Redis 事务的本质：一组命令的集合，一组事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序进行</p>\n<p>一次性，顺序性，排他性</p>\n<ul>\n<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>\n<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>\n<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>\n</ul>\n<p>一个事务从开始到执行会经历以下三个阶段：</p>\n<ul>\n<li>开始事务 (multi)。0</li>\n<li>命令入队。</li>\n<li>执行事务 (exec)。</li>\n</ul>\n<p><font color=\"red\">Redis 事务没有隔离级别的概念</font></p>\n<p>所有命令在事务中，并没有立即执行。只有发起执行命令时才会执行</p>\n<p><font color=\"red\">Redis 单条命令是保持原子性的，但是事务不保证原子性</font></p>\n<hr>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">multi</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">开启事务</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\"><span class=\"built_in\">set</span> k1 v1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\"><span class=\"built_in\">set</span> k2 v2</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\"><span class=\"built_in\">set</span> k3 v3</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">此时并未执行</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\"><span class=\"built_in\">exec</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">执行事务</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"异常\"><a class=\"markdownIt-Anchor\" href=\"#异常\">#</a> 异常</h3>\n<blockquote>\n<p>编译型异常</p>\n</blockquote>\n<p>（代码有误，命令有错），事务中所有的命令都不会执行</p>\n<blockquote>\n<p>运行时异常</p>\n</blockquote>\n<p>如果事务队列中存在错误，那么执行的时候，其他命令可以正常执行，错误命令抛出异常</p>\n<h3 id=\"监控\"><a class=\"markdownIt-Anchor\" href=\"#监控\">#</a> 监控</h3>\n<blockquote>\n<p>悲观锁</p>\n</blockquote>\n<p>认为什么时候都会出错，无论做什么都会加锁</p>\n<blockquote>\n<p>乐观锁</p>\n</blockquote>\n<p>认为什么时候都不会出问题，所以不会上锁。</p>\n<p>使用 version 字段，更新数据的时候判断在此期间是否有人修改过数据</p>\n<h3 id=\"命令\"><a class=\"markdownIt-Anchor\" href=\"#命令\">#</a> 命令</h3>\n<ol>\n<li>multi \t\t开启事务</li>\n<li>exec          执行事务</li>\n<li>discard    放弃事务</li>\n<li>unwatch   取消 watch 命令对所有 key 的监视</li>\n<li>watch key [key…]     监视一个（或多个）key，如果在事务执行之前这个（或这些）key 被其他命令所改动，那么事务将被打断\n<ul>\n<li>执行 watch 命令，相当于拿到了这个 key 的 version，每次执行完事务后要重新加锁，无论事务执行成功或失败，Redis 都会自动解锁</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "Redis"
            ]
        }
    ]
}