<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://prehitting.gitee.io</id>
    <title>不利索の鸣 • Posts by &#34;事务&#34; category</title>
    <link href="https://prehitting.gitee.io" />
    <updated>2022-05-18T03:41:50.000Z</updated>
    <category term="SpringBoot" />
    <category term="MybatisPlus" />
    <category term="拦截器" />
    <category term="Spring" />
    <category term="SpringCache" />
    <category term="Redis" />
    <category term="Swagger" />
    <category term="Springmvc" />
    <category term="mybatisPlus" />
    <category term="IDEA" />
    <category term="Linux" />
    <category term="设计模式" />
    <category term="OOP" />
    <category term="动态代理模式" />
    <category term="单例模式" />
    <category term="原型模式" />
    <category term="工厂模式" />
    <category term="建造者模式" />
    <category term="静态代理模式" />
    <category term="SLF4J" />
    <category term="Redis命令" />
    <category term="过滤器" />
    <category term="瑞吉外卖" />
    <category term="SpringMVC" />
    <category term="Vim" />
    <category term="Jedis" />
    <entry>
        <id>https://prehitting.gitee.io/2022/05/18/redis/shi-wu/</id>
        <title>事务</title>
        <link rel="alternate" href="https://prehitting.gitee.io/2022/05/18/redis/shi-wu/"/>
        <content type="html">&lt;h2 id=&#34;事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务&#34;&gt;#&lt;/a&gt; 事务&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Redis 事务的本质：一组命令的集合，一组事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序进行&lt;/p&gt;
&lt;p&gt;一次性，顺序性，排他性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批量操作在发送 EXEC 命令前被放入队列缓存。&lt;/li&gt;
&lt;li&gt;收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。&lt;/li&gt;
&lt;li&gt;在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个事务从开始到执行会经历以下三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始事务 (multi)。0&lt;/li&gt;
&lt;li&gt;命令入队。&lt;/li&gt;
&lt;li&gt;执行事务 (exec)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=&#34;red&#34;&gt;Redis 事务没有隔离级别的概念&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;所有命令在事务中，并没有立即执行。只有发起执行命令时才会执行&lt;/p&gt;
&lt;p&gt;&lt;font color=&#34;red&#34;&gt;Redis 单条命令是保持原子性的，但是事务不保证原子性&lt;/font&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; multi
&lt;span class=&#34;token comment&#34;&gt;#开启事务&lt;/span&gt;
&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;set&lt;/span&gt; k1 v1
&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;set&lt;/span&gt; k2 v2
&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;set&lt;/span&gt; k3 v3
&lt;span class=&#34;token comment&#34;&gt;#此时并未执行&lt;/span&gt;
&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;exec&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;#执行事务&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;异常&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#异常&#34;&gt;#&lt;/a&gt; 异常&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;编译型异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（代码有误，命令有错），事务中所有的命令都不会执行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行时异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果事务队列中存在错误，那么执行的时候，其他命令可以正常执行，错误命令抛出异常&lt;/p&gt;
&lt;h3 id=&#34;监控&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#监控&#34;&gt;#&lt;/a&gt; 监控&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;悲观锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;认为什么时候都会出错，无论做什么都会加锁&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;乐观锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;认为什么时候都不会出问题，所以不会上锁。&lt;/p&gt;
&lt;p&gt;使用 version 字段，更新数据的时候判断在此期间是否有人修改过数据&lt;/p&gt;
&lt;h3 id=&#34;命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#命令&#34;&gt;#&lt;/a&gt; 命令&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;multi 		开启事务&lt;/li&gt;
&lt;li&gt;exec          执行事务&lt;/li&gt;
&lt;li&gt;discard    放弃事务&lt;/li&gt;
&lt;li&gt;unwatch   取消 watch 命令对所有 key 的监视&lt;/li&gt;
&lt;li&gt;watch key [key…]     监视一个（或多个）key，如果在事务执行之前这个（或这些）key 被其他命令所改动，那么事务将被打断
&lt;ul&gt;
&lt;li&gt;执行 watch 命令，相当于拿到了这个 key 的 version，每次执行完事务后要重新加锁，无论事务执行成功或失败，Redis 都会自动解锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Redis" />
        <updated>2022-05-18T03:41:50.000Z</updated>
    </entry>
</feed>
