<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://prehitting.gitee.io</id>
    <title>不利索の鸣 • Posts by &#34;概论&#34; category</title>
    <link href="https://prehitting.gitee.io" />
    <updated>2022-05-16T14:15:41.000Z</updated>
    <category term="SpringBoot" />
    <category term="MybatisPlus" />
    <category term="拦截器" />
    <category term="Spring" />
    <category term="SpringCache" />
    <category term="Redis" />
    <category term="Swagger" />
    <category term="Springmvc" />
    <category term="mybatisPlus" />
    <category term="IDEA" />
    <category term="Linux" />
    <category term="设计模式" />
    <category term="OOP" />
    <category term="动态代理模式" />
    <category term="单例模式" />
    <category term="原型模式" />
    <category term="工厂模式" />
    <category term="建造者模式" />
    <category term="静态代理模式" />
    <category term="SLF4J" />
    <category term="Redis命令" />
    <category term="过滤器" />
    <category term="瑞吉外卖" />
    <category term="SpringMVC" />
    <category term="Vim" />
    <category term="Jedis" />
    <entry>
        <id>https://prehitting.gitee.io/2022/05/16/Redis/%E6%A6%82%E8%AE%BA/%E5%85%B3%E4%BA%8ERedis%E5%8D%95%E7%BA%BF%E7%A8%8B/</id>
        <title>关于Redis的单线程问题</title>
        <link rel="alternate" href="https://prehitting.gitee.io/2022/05/16/Redis/%E6%A6%82%E8%AE%BA/%E5%85%B3%E4%BA%8ERedis%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
        <content type="html">&lt;h2 id=&#34;基础知识&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基础知识&#34;&gt;#&lt;/a&gt; 基础知识&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis 是单线程的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么redis单线程却支持高并发&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#为什么redis单线程却支持高并发&#34;&gt;#&lt;/a&gt; 为什么 Redis 单线程却支持高并发&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;纯内存操作&lt;/li&gt;
&lt;li&gt;核心是基于非阻塞的 IO&lt;/li&gt;
&lt;li&gt;多路复用机制 单线程反而避免了多线程的频繁上下文切换问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;redis高并发和快速的原因&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis高并发和快速的原因&#34;&gt;#&lt;/a&gt; Redis 高并发和快速的原因&lt;/h3&gt;
&lt;p&gt;1.redis 是基于内存的，内存的读写速度非常快（纯内存）; 数据存在内存中，数据结构用 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O (1)。&lt;/p&gt;
&lt;p&gt;2.redis 是单线程的，省去了很多上下文切换线程的时间（避免线程切换和竞态消耗）。&lt;/p&gt;
&lt;p&gt;3.redis 使用 IO 多路复用技术（IO multiplexing, 解决对多个 I/O 监听时，一个 I/O 阻塞影响其他 I/O 的问题），可以处理并发的连接（非阻塞 IO）。&lt;/p&gt;
&lt;h3 id=&#34;为甚么redis是单线程的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#为甚么redis是单线程的&#34;&gt;#&lt;/a&gt; 为甚么 Redis 是单线程的&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;官方答案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能指标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详细原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）不需要各种锁的性能消耗&lt;/p&gt;
&lt;p&gt;Redis 的数据结构并不全是简单的 Key-Value，还有 list，hash 等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在 hash 当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。&lt;/p&gt;
&lt;p&gt;总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗。&lt;/p&gt;
&lt;p&gt;2）单线程多进程集群方案&lt;/p&gt;
&lt;p&gt;单线程的威力实际上非常强大，单核 cpu 效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。&lt;/p&gt;
&lt;p&gt;所以 “单线程、多进程的集群” 不失为一个时髦的解决方案。&lt;/p&gt;
&lt;p&gt;3）CPU 消耗&lt;/p&gt;
&lt;p&gt;采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。&lt;/p&gt;
&lt;p&gt;但是如果 CPU 成为 Redis 瓶颈，或者不想让服务器其他 CUP 核闲置，那怎么办？&lt;/p&gt;
&lt;p&gt;可以考虑多起几个 Redis 进程，Redis 是 key-value 数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些 key 放在哪个 Redis 进程上就可以了。&lt;/p&gt;
&lt;h3 id=&#34;redis单线程的优劣势&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis单线程的优劣势&#34;&gt;#&lt;/a&gt; Redis 单线程的优劣势&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;单进程单线程优势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码更清晰，处理逻辑更简单。&lt;br&gt;
不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗。&lt;br&gt;
不存在 “多进程或者多线程导致的切换” 而消耗 CPU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单进程单线程弊端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无法发挥多核 CPU 性能，不过可以通过在单机开多个 Redis 实例来完善。&lt;/p&gt;
</content>
        <category term="Redis" />
        <updated>2022-05-16T14:15:41.000Z</updated>
    </entry>
</feed>
