{
    "version": "https://jsonfeed.org/version/1",
    "title": "不利索の鸣 • All posts by \"概论\" category",
    "description": "欢迎来到鸣崽的空间，这里不仅有学习，还有生活",
    "home_page_url": "https://prehitting.gitee.io",
    "items": [
        {
            "id": "https://prehitting.gitee.io/2022/05/16/redis/gai-lun/guan-yu-redis-dan-xian-cheng/",
            "url": "https://prehitting.gitee.io/2022/05/16/redis/gai-lun/guan-yu-redis-dan-xian-cheng/",
            "title": "关于Redis的单线程问题",
            "date_published": "2022-05-16T14:15:41.000Z",
            "content_html": "<h2 id=\"基础知识\"><a class=\"markdownIt-Anchor\" href=\"#基础知识\">#</a> 基础知识</h2>\n<blockquote>\n<p>Redis 是单线程的</p>\n</blockquote>\n<h3 id=\"为什么redis单线程却支持高并发\"><a class=\"markdownIt-Anchor\" href=\"#为什么redis单线程却支持高并发\">#</a> 为什么 Redis 单线程却支持高并发</h3>\n<ol>\n<li>纯内存操作</li>\n<li>核心是基于非阻塞的 IO</li>\n<li>多路复用机制 单线程反而避免了多线程的频繁上下文切换问题</li>\n</ol>\n<h3 id=\"redis高并发和快速的原因\"><a class=\"markdownIt-Anchor\" href=\"#redis高并发和快速的原因\">#</a> Redis 高并发和快速的原因</h3>\n<p>1.redis 是基于内存的，内存的读写速度非常快（纯内存）; 数据存在内存中，数据结构用 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O (1)。</p>\n<p>2.redis 是单线程的，省去了很多上下文切换线程的时间（避免线程切换和竞态消耗）。</p>\n<p>3.redis 使用 IO 多路复用技术（IO multiplexing, 解决对多个 I/O 监听时，一个 I/O 阻塞影响其他 I/O 的问题），可以处理并发的连接（非阻塞 IO）。</p>\n<h3 id=\"为甚么redis是单线程的\"><a class=\"markdownIt-Anchor\" href=\"#为甚么redis是单线程的\">#</a> 为甚么 Redis 是单线程的</h3>\n<p><strong>官方答案</strong></p>\n<p>因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n<p><strong>性能指标</strong></p>\n<p>关于 redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<p><strong>详细原因</strong></p>\n<p>1）不需要各种锁的性能消耗</p>\n<p>Redis 的数据结构并不全是简单的 Key-Value，还有 list，hash 等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在 hash 当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>\n<p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>\n<p>2）单线程多进程集群方案</p>\n<p>单线程的威力实际上非常强大，单核 cpu 效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>\n<p>所以 “单线程、多进程的集群” 不失为一个时髦的解决方案。</p>\n<p>3）CPU 消耗</p>\n<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>\n<p>但是如果 CPU 成为 Redis 瓶颈，或者不想让服务器其他 CUP 核闲置，那怎么办？</p>\n<p>可以考虑多起几个 Redis 进程，Redis 是 key-value 数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些 key 放在哪个 Redis 进程上就可以了。</p>\n<h3 id=\"redis单线程的优劣势\"><a class=\"markdownIt-Anchor\" href=\"#redis单线程的优劣势\">#</a> Redis 单线程的优劣势</h3>\n<p><strong>单进程单线程优势</strong></p>\n<p>代码更清晰，处理逻辑更简单。<br>\n不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗。<br>\n不存在 “多进程或者多线程导致的切换” 而消耗 CPU。</p>\n<p><strong>单进程单线程弊端</strong></p>\n<p>无法发挥多核 CPU 性能，不过可以通过在单机开多个 Redis 实例来完善。</p>\n",
            "tags": [
                "Redis"
            ]
        }
    ]
}