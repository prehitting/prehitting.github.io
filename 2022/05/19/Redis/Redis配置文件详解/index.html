<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#447EA5"><meta name="author" content="YiMing"><meta name="keywords" content=""><meta name="description" content="Redis配置文件"><meta property="og:type" content="article"><meta property="og:title" content="Redis配置文件详解"><meta property="og:url" content="http://prehitting.gitee.io/2022/05/19/Redis/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/index.html"><meta property="og:site_name" content="不利索の鸣"><meta property="og:description" content="Redis配置文件"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-05-19T14:43:22.000Z"><meta property="article:modified_time" content="2022-05-20T03:33:06.667Z"><meta property="article:author" content="YiMing"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary_large_image"><title>Redis配置文件详解 - 不利索の鸣</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css@4/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css@2/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/prismjs@1/themes/prism.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"prehitting.gitee.io",root:"/",version:"1.8.14",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!0},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!1,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>YiMing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/article_banner.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Redis配置文件详解"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> YiMing </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-19 22:43" pubdate>2022年5月19日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 91 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Redis配置文件详解</h1><p class="note note-info">本文最后更新于：13 天前</p><div class="markdown-body"><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php"><span class="token keyword">include</span> <span class="token operator">.</span>\path\to\local<span class="token operator">.</span>conf
<span class="token keyword">include</span> c<span class="token punctuation">:</span>\path\to\other<span class="token operator">.</span>conf</code></pre></div><p>额外载入配置文件，如果需要的话，可以开启此配置</p><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php">bind <span class="token number">192.168</span><span class="token number">.1</span><span class="token number">.100</span> <span class="token number">10.0</span><span class="token number">.0</span><span class="token number">.1</span>
bind <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span> <span class="token operator">::</span><span class="token number">1</span></code></pre></div><p>绑定redis服务器网卡IP，默认为127.0.0.1,即本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind选项为空的话，那会接受所有来自于可用网络接口的连接。如上配置，绑定一个127.0.0.1的本机地址和192.168.1.100的外网地址。</p><p>默认情况下，如果没有指定“绑定”配置指令，Redis 会侦听来自服务器上所有可用网络接口的连接。可以使用“绑定”配置指令仅监听一个或多个选定的接口，然后是一个或多个 IP 地址。</p><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php"><span class="token keyword">protected</span><span class="token operator">-</span>mode yes</code></pre></div><p>保护模式，默认是开启状态，只允许本地客户端连接， 可以设置密码或添加bind来连接</p><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php">port <span class="token number">6379</span></code></pre></div><p>监听端口号，默认6379.</p><p>若设置为0，redis将不在socket上监听任何客户端的连接</p><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php">tcp<span class="token operator">-</span>backlog <span class="token number">511</span></code></pre></div><p>TCP监听的最大容纳数量，在高并发环境下需要调高这个值以避免连接缓慢。</p><p>Linux内核会把这个值缩小成&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn对应的值，要提高并发量需要修改这两个值才能达到目的</p><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php">timeout <span class="token number">0</span></code></pre></div><p>指定在一个 client 空闲多少秒之后关闭连接（0表示永不关闭）</p><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php">tcp<span class="token operator">-</span>keepalive <span class="token number">300</span></code></pre></div><p>单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测</p><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php">loglevel notice</code></pre></div><p>定义日志级别。<br>可以是下面的这些值：</p><ol><li>debug（记录大量日志信息，适用于开发、测试阶段）</li><li>verbose（较多日志信息）</li><li>notice（适量日志信息，使用于生产环境）</li><li>warning（仅有部分重要、关键信息才会被记录）</li></ol><ul><li>line 165</li></ul><div class="code-wrapper"><pre class="language-php" data-language="php"><code class="language-php">logfile <span class="token string double-quoted-string">""</span></code></pre></div><p>日志文件的位置，当指定为空字符串时，为标准输出，如果redis已守护进程模式运行，那么日志将会输出到&#x2F;dev&#x2F;null</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">syslog-enabled no</code></pre></div><p>要想把日志记录到系统日志，就把它改成 yes，也可以可选择性的更新其他的syslog 参数以达到你的要求</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">syslog-ident redis</code></pre></div><p>设置系统日志的ID</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">syslog-facility local0</code></pre></div><p>指定系统日志设置，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">databases 16</code></pre></div><p>设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select<dbid>命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。</dbid></p><div class="code-wrapper"><pre class="language-none"><code class="language-none">save 900 1
save 300 10
save 60 10000</code></pre></div><p>存 DB 到磁盘：<br>格式：save &lt;间隔时间（秒）&gt; &lt;写入次数&gt;<br>根据给定的时间间隔和写入次数将数据保存到磁盘<br>下面的例子的意思是：<br>900 秒内如果至少有 1 个 key 的值变化，则保存<br>300 秒内如果至少有 10 个 key 的值变化，则保存<br>60 秒内如果至少有 10000 个 key 的值变化，则保存<br>　<br>注意：你可以注释掉所有的 save 行来停用保存功能。<br>也可以直接一个空字符串来实现停用：<br>save “”</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">stop-writes-on-bgsave-error yes</code></pre></div><p>如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。<br>这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。<br>如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。<br>如果下一次RDB持久化成功，redis会自动恢复接受写请求。<br>如果不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，可以关闭这个功能，<br>以便在快照写入失败时，也能确保redis继续接受新的写请求。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">rdbcompression yes</code></pre></div><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。<br>如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，<br>可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">rdbchecksum yes</code></pre></div><p>在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，<br>如果希望获取到最大的性能提升，可以关闭此功能。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">dbfilename dump.rdb</code></pre></div><p>设置快照的文件名</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">dir &#x2F;var&#x2F;redis&#x2F;6379</code></pre></div><p>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">slaveof &lt;masterip&gt; &lt;masterport&gt;</code></pre></div><p>主从复制，使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本，默认关闭<br>注意这个只需要在 slave 上配置</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">masterauth &lt;master-password&gt;</code></pre></div><p>如果 master 需要密码认证，就在这里设置，默认不设置</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">slave-serve-stale-data yes</code></pre></div><p>当一个 slave 与 master 失去联系，或者复制正在进行的时候，<br>slave 可能会有两种表现：<br>\1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，<br>或者数据可能是空的在第一次同步的时候<br>\2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，<br>slave 都将返回一个 “SYNC with master in progress” 的错误</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">slave-read-only yes</code></pre></div><p>你可以配置一个 slave 实体是否接受写入操作。<br>通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，<br>因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。<br>但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。<br>从 redis 2.6 版起，默认 slaves 都是只读的。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">repl-diskless-sync no</code></pre></div><p>主从数据复制是否使用无硬盘复制功能。<br>新的从站和重连后不能继续备份的从站，需要做所谓的“完全备份”，即将一个RDB文件从主站传送到从站。<br>这个传送有以下两种方式：<br>1）硬盘备份：redis主站创建一个新的进程，用于把RDB文件写到硬盘上。过一会儿，其父进程递增地将文件传送给从站。<br>2）无硬盘备份：redis主站创建一个新的进程，子进程直接把RDB文件写到从站的套接字，不需要用到硬盘。<br>在硬盘备份的情况下，主站的子进程生成RDB文件。一旦生成，多个从站可以立即排成队列使用主站的RDB文件。<br>在无硬盘备份的情况下，一次RDB传送开始，新的从站到达后，需要等待现在的传送结束，才能开启新的传送。<br>如果使用无硬盘备份，主站会在开始传送之间等待一段时间（可配置，以秒为单位），希望等待多个子站到达后并行传送。<br>在硬盘低速而网络高速（高带宽）情况下，无硬盘备份更好。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">repl-diskless-sync-delay 5</code></pre></div><p>当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。<br>这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段<br>时间以期更多的从站到达。<br>延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">repl-ping-slave-period 10</code></pre></div><p>从redis会周期性的向主redis发出PING包，你可以通过repl_ping_slave_period指令来控制其周期，默认是10秒。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">repl-timeout 60</code></pre></div><p>接下来的选项为以下内容设置备份的超时时间：<br>1）从从站的角度，同步期间的批量传输的I&#x2F;O<br>2）从站角度认为的主站超时（数据，ping）<br>3）主站角度认为的从站超时（REPLCONF ACK pings)<br>确认这些值比定义的repl-ping-slave-period要大，否则每次主站和从站之间通信低速时都会被检测为超时。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">repl-disable-tcp-nodelay no</code></pre></div><p>同步之后是否禁用从站上的TCP_NODELAY<br>如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。<br>Linux内核默认配置情况下最多40毫秒的延时。<br>如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。<br>默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">repl-backlog-size 1mb</code></pre></div><p>设置备份的工作储备大小。工作储备是一个缓冲区，当从站断开一段时间的情况时，它替从站接收存储数据，<br>因此当从站重连时，通常不需要完全备份，只需要一个部分同步就可以，即把从站断开时错过的一部分数据接收。<br>工作储备越大，从站可以断开并稍后执行部分同步的断开时间就越长。<br>只要有一个从站连接，就会立刻分配一个工作储备。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">repl-backlog-ttl 3600</code></pre></div><p>主站有一段时间没有与从站连接，对应的工作储备就会自动释放。<br>这个选项用于配置释放前等待的秒数，秒数从断开的那一刻开始计算，值为0表示不释放。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">slave-priority 100</code></pre></div><p>从站优先级是可以从redis的INFO命令输出中查到的一个整数。当主站不能正常工作时<br>redis sentinel使用它来选择一个从站并将它提升为主站。<br>低优先级的从站被认为更适合于提升，因此如果有三个从站优先级分别是10，<br>100，25，sentinel会选择优先级为10的从站，因为它的优先级最低。<br>然而优先级值为0的从站不能执行主站的角色，因此优先级为0的从站永远不会被redis sentinel提升。<br>默认优先级是100</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">min-slaves-to-write 3
min-slaves-max-lag 10</code></pre></div><p>主站可以停止接受写请求，当与它连接的从站少于N个，滞后少于M秒，N个从站必须是在线状态。<br>延迟的秒数必须&lt;&#x3D;所定义的值，延迟秒数是从最后一次收到的来自从站的ping开始计算。ping通常是每秒一次。<br>这一选项并不保证N个备份都会接受写请求，但是会限制在指定秒数内由于从站数量不够导致的写操作丢失的情况。<br>如果想要至少3个从站且延迟少于10秒，如上配置即可</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">slave-announce-ip 5.5.5.5
slave-announce-port 1234</code></pre></div><p>Redis master能够以不同的方式列出所连接slave的地址和端口。<br>例如，“INFO replication”部分提供此信息，除了其他工具之外，Redis Sentinel还使用该信息来发现slave实例。<br>此信息可用的另一个地方在masterser的“ROLE”命令的输出中。<br>通常由slave报告的列出的IP和地址,通过以下方式获得：<br>IP：通过检查slave与master连接使用的套接字的对等体地址自动检测地址。<br>端口：端口在复制握手期间由slavet通信，并且通常是slave正在使用列出连接的端口。<br>然而，当使用端口转发或网络地址转换（NAT）时，slave实际上可以通过(不同的IP和端口对)来到达。 slave可以使用以下两个选项，以便向master报告一组特定的IP和端口，<br>以便INFO和ROLE将报告这些值。<br>如果你需要仅覆盖端口或IP地址，则没必要使用这两个选项。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">requirepass foobared</code></pre></div><p>设置redis连接密码</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">rename-command CONFIG &quot;&quot;</code></pre></div><p>将命令重命名，为了安全考虑，可以将某些重要的、危险的命令重命名。<br>当你把某个命令重命名成空字符串的时候就等于取消了这个命令。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">maxclients 10000</code></pre></div><p>设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件<br>描述符数-32（redis server自身会使用一些），如果设置 maxclients为0<br>表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">maxmemory &lt;bytes&gt;</code></pre></div><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key<br>当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，<br>会把Key存放内存，Value会存放在swap区，格式：maxmemory<bytes></bytes></p><div class="code-wrapper"><pre class="language-none"><code class="language-none">maxmemory-policy noeviction</code></pre></div><p>当内存使用达到最大值时，redis使用的清楚策略。有以下几种可以选择：<br>1）volatile-lru 利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )<br>2）allkeys-lru 利用LRU算法移除任何key<br>3）volatile-random 移除设置过过期时间的随机key<br>4）allkeys-random 移除随机ke<br>5）volatile-ttl 移除即将过期的key(minor TTL)<br>6）noeviction noeviction 不移除任何key，只是返回一个写错误 ，默认选项</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">maxmemory-samples 5</code></pre></div><p>LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)<br>随意你可以选择样本大小进行检，redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">appendonly no</code></pre></div><p>默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，<br>会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，<br>可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入appendonly.aof文件，<br>每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">appendfilename &quot;appendonly.aof&quot;</code></pre></div><p>aof文件名</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">appendfsync always
appendfsync everysec
appendfsync no</code></pre></div><p>aof持久化策略的配置<br>no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。<br>always表示每次写入都执行fsync，以保证数据同步到磁盘。<br>everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">no-appendfsync-on-rewrite no</code></pre></div><p>在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，<br>执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。<br>如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。<br>设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。<br>Linux的默认fsync策略是30秒。可能丢失30秒数据。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">auto-aof-rewrite-percentage 100</code></pre></div><p>aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，<br>即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。<br>当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">auto-aof-rewrite-min-size 64mb</code></pre></div><p>设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">aof-load-truncated yes</code></pre></div><p>aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。<br>重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data&#x3D;ordered选项，出现这种现象<br>redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。<br>如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。<br>如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">lua-time-limit 5000</code></pre></div><p>如果达到最大时间限制（毫秒），redis会记个log，然后返回error。当一个脚本超过了最大时限。<br>只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。<br>要是已经调用了write，只能用第二个命令杀</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">cluster-enabled yes</code></pre></div><p>集群开关，默认是不开启集群模式</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">cluster-config-file nodes-6379.conf</code></pre></div><p>集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。<br>这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件<br>请确保与实例运行的系统中配置文件名称不冲突</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">cluster-node-timeout 15000</code></pre></div><p>节点互连超时的阀值，集群节点超时毫秒数</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">cluster-slave-validity-factor 10</code></pre></div><p>在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，<br>导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。<br>判断方法是：<br>比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period<br>如果节点超时时间为三十秒, 并且slave-validity-factor为10,<br>假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">cluster-migration-barrier 1</code></pre></div><p>master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，<br>那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">cluster-require-full-coverage yes</code></pre></div><p>默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。<br>设置为no，可以在slot没有全部分配的时候提供服务。<br>不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">slowlog-log-slower-than 10000</code></pre></div><p>slog log是用来记录redis运行中执行比较慢的命令耗时。<br>当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。<br>执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。<br>注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">slowlog-max-len 128</code></pre></div><p>慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉，这个长度没有限制。<br>只要有足够的内存就行，你可以通过 SLOWLOG RESET 来释放内存</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">latency-monitor-threshold 0</code></pre></div><p>延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。<br>只记录大于等于下边设置的值的操作，0的话，就是关闭监视。<br>默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">notify-keyspace-events &quot;&quot;</code></pre></div><p>键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。<br>notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：<br>K 键空间通知，所有通知以 <strong>keyspace@</strong> 为前缀<br>E 键事件通知，所有通知以 <strong>keyevent@</strong> 为前缀<br>g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知<br>$ 字符串命令的通知<br>l 列表命令的通知<br>s 集合命令的通知<br>h 哈希命令的通知<br>z 有序集合命令的通知<br>x 过期事件：每当有过期键被删除时发送<br>e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送<br>A 参数 g$lshzxe 的别名<br>输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">hash-max-ziplist-entries 512</code></pre></div><p>hash类型的数据结构在编码上可以使用ziplist和hashtable。<br>ziplist的特点就是文件存储(以及内存存储)所需的空间较小,在内容较小时,性能和hashtable几乎一样。<br>因此redis对hash类型默认采取ziplist。如果hash中条目的条目个数或者value长度达到阀值,将会被重构为hashtable。<br>这个参数指的是ziplist中允许存储的最大条目个数，，默认为512，建议为128</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">hash-max-ziplist-value 64</code></pre></div><p>ziplist中允许条目value值最大字节数，默认为64，建议为1024</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">list-max-ziplist-size -2</code></pre></div><p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。<br>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：<br>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb &#x3D;&gt; 1024 bytes）<br>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。<br>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。<br>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）<br>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">list-compress-depth 0</code></pre></div><p>这个参数表示一个quicklist两端不被压缩的节点个数。<br>注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。<br>实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。<br>参数list-compress-depth的取值含义如下：<br>0: 是个特殊值，表示都不压缩。这是Redis的默认值。<br>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。<br>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。<br>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。<br>依此类推…<br>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">set-max-intset-entries 512</code></pre></div><p>数据量小于等于set-max-intset-entries用intset，大于set-max-intset-entries用set</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">zset-max-ziplist-entries 128
zset-max-ziplist-value 64</code></pre></div><p>数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">hll-sparse-max-bytes 3000</code></pre></div><p>value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse）<br>大于hll-sparse-max-bytes使用稠密的数据结构（dense），一个比16000大的value是几乎没用的，<br>建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">activerehashing yes</code></pre></div><p>Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。<br>当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。<br>如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">client-output-buffer-limit normal 0 0 0</code></pre></div><p>对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。<br>对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">client-output-buffer-limit slave 256mb 64mb 60</code></pre></div><p>对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">client-output-buffer-limit pubsub 32mb 8mb 60</code></pre></div><p>对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">hz 10</code></pre></div><p>redis执行任务的频率为1s除以hz</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">aof-rewrite-incremental-fsync yes</code></pre></div><p>在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。<br>这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Redis/">Redis</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Redis/">Redis</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Redis持久化_RDB</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/05/18/SLF4J/Errors/Error01/"><span class="hidden-mobile">Error01</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){var t="github-light",e="github-dark",r="dark"===(r=document.documentElement.getAttribute("data-user-color-scheme"))?e:t;window.UtterancesThemeLight=t,window.UtterancesThemeDark=e;var n=document.createElement("script");n.setAttribute("src","https://utteranc.es/client.js"),n.setAttribute("repo","prehitting/commit-utterances"),n.setAttribute("issue-term","pathname"),n.setAttribute("label","utterances"),n.setAttribute("theme",r),n.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(n)})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="https://lib.baomitu.com/tocbot@4/dist/tocbot.min.js"></script><script src="https://lib.baomitu.com/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="https://lib.baomitu.com/anchor-js@4/anchor.min.js"></script><script defer src="https://lib.baomitu.com/clipboard@2/dist/clipboard.min.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script src="/js/boot.js"></script></body></html>