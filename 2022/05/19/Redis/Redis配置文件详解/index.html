<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Redis配置文件详解, 孤注一掷"><meta name="description" content="欢迎来到鸣崽的空间，这里不仅有学习，还有生活"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>Redis配置文件详解 | 不利索の鸣</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">不利索の鸣</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">不利索の鸣</div><div class="logo-desc">欢迎来到鸣崽的空间，这里不仅有学习，还有生活</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/prehitting" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/prehitting" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/8.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Redis配置文件详解</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis/" class="post-category">Redis</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2022-05-19</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2022-05-20</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> .\path\to\local.conf</span><br><span class="line"><span class="keyword">include</span> c:\path\to\other.conf</span><br></pre></td></tr></table></figure><p>额外载入配置文件，如果需要的话，可以开启此配置</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">bind <span class="number">192.168</span>.<span class="number">1.100</span> <span class="number">10.0</span>.<span class="number">0.1</span></span><br><span class="line">bind <span class="number">127.0</span>.<span class="number">0.1</span> ::<span class="number">1</span></span><br></pre></td></tr></table></figure><p>绑定 redis 服务器网卡 IP，默认为 127.0.0.1, 即本地回环地址。这样的话，访问 redis 服务只能通过本机的客户端连接，而无法通过远程连接。如果 bind 选项为空的话，那会接受所有来自于可用网络接口的连接。如上配置，绑定一个 127.0.0.1 的本机地址和 192.168.1.100 的外网地址。</p><p>默认情况下，如果没有指定 “绑定” 配置指令，Redis 会侦听来自服务器上所有可用网络接口的连接。可以使用 “绑定” 配置指令仅监听一个或多个选定的接口，然后是一个或多个 IP 地址。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>-mode yes</span><br></pre></td></tr></table></figure><p>保护模式，默认是开启状态，只允许本地客户端连接， 可以设置密码或添加 bind 来连接</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">port <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>监听端口号，默认 6379.</p><p>若设置为 0，redis 将不在 socket 上监听任何客户端的连接</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">tcp-backlog <span class="number">511</span></span><br></pre></td></tr></table></figure><p>TCP 监听的最大容纳数量，在高并发环境下需要调高这个值以避免连接缓慢。</p><p>Linux 内核会把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值，要提高并发量需要修改这两个值才能达到目的</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">timeout <span class="number">0</span></span><br></pre></td></tr></table></figure><p>指定在一个 client 空闲多少秒之后关闭连接（0 表示永不关闭）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">tcp-keepalive <span class="number">300</span></span><br></pre></td></tr></table></figure><p>单位是秒，表示将周期性的使用 SO_KEEPALIVE 检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是 300s，如果设置为 0，则不会周期性的检测</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">loglevel notice</span><br></pre></td></tr></table></figure><p>定义日志级别。<br>可以是下面的这些值：</p><ol><li>debug（记录大量日志信息，适用于开发、测试阶段）</li><li>verbose（较多日志信息）</li><li>notice（适量日志信息，使用于生产环境）</li><li>warning（仅有部分重要、关键信息才会被记录）</li></ol><ul><li>line 165</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">logfile <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>日志文件的位置，当指定为空字符串时，为标准输出，如果 redis 已守护进程模式运行，那么日志将会输出到 /dev/null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syslog-enabled no</span><br></pre></td></tr></table></figure><p>要想把日志记录到系统日志，就把它改成 yes，也可以可选择性的更新其他的 syslog 参数以达到你的要求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syslog-ident redis</span><br></pre></td></tr></table></figure><p>设置系统日志的 ID</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syslog-facility local0</span><br></pre></td></tr></table></figure><p>指定系统日志设置，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure><p>设置数据库的数目。默认的数据库是 DB 0 ，可以在每个连接上使用 select<dbid>命令选择一个不同的数据库，dbid 是一个介于 0 到 databases - 1 之间的数值。</dbid></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>存 DB 到磁盘：<br>格式：save &lt;间隔时间（秒）&gt; &lt; 写入次数 &gt;<br>根据给定的时间间隔和写入次数将数据保存到磁盘<br>下面的例子的意思是：<br>900 秒内如果至少有 1 个 key 的值变化，则保存<br>300 秒内如果至少有 10 个 key 的值变化，则保存<br>60 秒内如果至少有 10000 个 key 的值变化，则保存<br>　<br>注意：你可以注释掉所有的 save 行来停用保存功能。<br>也可以直接一个空字符串来实现停用：<br>save “”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop-writes-on-bgsave-error yes</span><br></pre></td></tr></table></figure><p>如果用户开启了 RDB 快照功能，那么在 redis 持久化数据到磁盘时如果出现失败，默认情况下，redis 会停止接受所有的写请求。<br>这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。<br>如果 redis 不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。<br>如果下一次 RDB 持久化成功，redis 会自动恢复接受写请求。<br>如果不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，可以关闭这个功能，<br>以便在快照写入失败时，也能确保 redis 继续接受新的写请求。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。<br>如果是的话，redis 会采用 LZF 算法进行压缩。如果你不想消耗 CPU 来进行压缩的话，<br>可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><p>在存储快照后，我们还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，<br>如果希望获取到最大的性能提升，可以关闭此功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure><p>设置快照的文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /var/redis/6379</span><br></pre></td></tr></table></figure><p>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>主从复制，使用 slaveof 来让一个 redis 实例成为另一个 reids 实例的副本，默认关闭<br>注意这个只需要在 slave 上配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure><p>如果 master 需要密码认证，就在这里设置，默认不设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-serve-stale-data yes</span><br></pre></td></tr></table></figure><p>当一个 slave 与 master 失去联系，或者复制正在进行的时候，<br>slave 可能会有两种表现：<br>\1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，<br>或者数据可能是空的在第一次同步的时候<br>\2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，<br>slave 都将返回一个 “SYNC with master in progress” 的错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure><p>你可以配置一个 slave 实体是否接受写入操作。<br>通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，<br>因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。<br>但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。<br>从 redis 2.6 版起，默认 slaves 都是只读的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync no</span><br></pre></td></tr></table></figure><p>主从数据复制是否使用无硬盘复制功能。<br>新的从站和重连后不能继续备份的从站，需要做所谓的 “完全备份”，即将一个 RDB 文件从主站传送到从站。<br>这个传送有以下两种方式：<br>1）硬盘备份：redis 主站创建一个新的进程，用于把 RDB 文件写到硬盘上。过一会儿，其父进程递增地将文件传送给从站。<br>2）无硬盘备份：redis 主站创建一个新的进程，子进程直接把 RDB 文件写到从站的套接字，不需要用到硬盘。<br>在硬盘备份的情况下，主站的子进程生成 RDB 文件。一旦生成，多个从站可以立即排成队列使用主站的 RDB 文件。<br>在无硬盘备份的情况下，一次 RDB 传送开始，新的从站到达后，需要等待现在的传送结束，才能开启新的传送。<br>如果使用无硬盘备份，主站会在开始传送之间等待一段时间（可配置，以秒为单位），希望等待多个子站到达后并行传送。<br>在硬盘低速而网络高速（高带宽）情况下，无硬盘备份更好。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure><p>当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送 RDB 文件，这个等待时间是可配置的。<br>这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次 RDB 传送。因此服务器等待一段<br>时间以期更多的从站到达。<br>延迟时间以秒为单位，默认为 5 秒。要关掉这一功能，只需将它设置为 0 秒，传送会立即启动。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-ping-slave-period 10</span><br></pre></td></tr></table></figure><p>从 redis 会周期性的向主 redis 发出 PING 包，你可以通过 repl_ping_slave_period 指令来控制其周期，默认是 10 秒。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-timeout 60</span><br></pre></td></tr></table></figure><p>接下来的选项为以下内容设置备份的超时时间：<br>1）从从站的角度，同步期间的批量传输的 I/O<br>2）从站角度认为的主站超时（数据，ping）<br>3）主站角度认为的从站超时（REPLCONF ACK pings)<br>确认这些值比定义的 repl-ping-slave-period 要大，否则每次主站和从站之间通信低速时都会被检测为超时。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-disable-tcp-nodelay no</span><br></pre></td></tr></table></figure><p>同步之后是否禁用从站上的 TCP_NODELAY<br>如果你选择 yes，redis 会使用较少量的 TCP 包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。<br>Linux 内核默认配置情况下最多 40 毫秒的延时。<br>如果选择 no，从站的数据延时不会那么多，但备份需要的带宽相对较多。<br>默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为 yes 是个好主意。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure><p>设置备份的工作储备大小。工作储备是一个缓冲区，当从站断开一段时间的情况时，它替从站接收存储数据，<br>因此当从站重连时，通常不需要完全备份，只需要一个部分同步就可以，即把从站断开时错过的一部分数据接收。<br>工作储备越大，从站可以断开并稍后执行部分同步的断开时间就越长。<br>只要有一个从站连接，就会立刻分配一个工作储备。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-backlog-ttl 3600</span><br></pre></td></tr></table></figure><p>主站有一段时间没有与从站连接，对应的工作储备就会自动释放。<br>这个选项用于配置释放前等待的秒数，秒数从断开的那一刻开始计算，值为 0 表示不释放。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-priority 100</span><br></pre></td></tr></table></figure><p>从站优先级是可以从 redis 的 INFO 命令输出中查到的一个整数。当主站不能正常工作时<br>redis sentinel 使用它来选择一个从站并将它提升为主站。<br>低优先级的从站被认为更适合于提升，因此如果有三个从站优先级分别是 10，<br>100，25，sentinel 会选择优先级为 10 的从站，因为它的优先级最低。<br>然而优先级值为 0 的从站不能执行主站的角色，因此优先级为 0 的从站永远不会被 redis sentinel 提升。<br>默认优先级是 100</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>主站可以停止接受写请求，当与它连接的从站少于 N 个，滞后少于 M 秒，N 个从站必须是在线状态。<br>延迟的秒数必须 &lt;= 所定义的值，延迟秒数是从最后一次收到的来自从站的 ping 开始计算。ping 通常是每秒一次。<br>这一选项并不保证 N 个备份都会接受写请求，但是会限制在指定秒数内由于从站数量不够导致的写操作丢失的情况。<br>如果想要至少 3 个从站且延迟少于 10 秒，如上配置即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-announce-ip 5.5.5.5</span><br><span class="line">slave-announce-port 1234</span><br></pre></td></tr></table></figure><p>Redis master 能够以不同的方式列出所连接 slave 的地址和端口。<br>例如，“INFO replication” 部分提供此信息，除了其他工具之外，Redis Sentinel 还使用该信息来发现 slave 实例。<br>此信息可用的另一个地方在 masterser 的 “ROLE” 命令的输出中。<br>通常由 slave 报告的列出的 IP 和地址，通过以下方式获得：<br>IP：通过检查 slave 与 master 连接使用的套接字的对等体地址自动检测地址。<br>端口：端口在复制握手期间由 slavet 通信，并且通常是 slave 正在使用列出连接的端口。<br>然而，当使用端口转发或网络地址转换（NAT）时，slave 实际上可以通过 (不同的 IP 和端口对) 来到达。 slave 可以使用以下两个选项，以便向 master 报告一组特定的 IP 和端口，<br>以便 INFO 和 ROLE 将报告这些值。<br>如果你需要仅覆盖端口或 IP 地址，则没必要使用这两个选项。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requirepass foobared</span><br></pre></td></tr></table></figure><p>设置 redis 连接密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename-command CONFIG &quot;&quot;</span><br></pre></td></tr></table></figure><p>将命令重命名，为了安全考虑，可以将某些重要的、危险的命令重命名。<br>当你把某个命令重命名成空字符串的时候就等于取消了这个命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxclients 10000</span><br></pre></td></tr></table></figure><p>设置客户端最大并发连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件<br>描述符数 - 32（redis server 自身会使用一些），如果设置 maxclients 为 0<br>表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure><p>指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key<br>当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，<br>会把 Key 存放内存，Value 会存放在 swap 区，格式：maxmemory<bytes></bytes></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory-policy noeviction</span><br></pre></td></tr></table></figure><p>当内存使用达到最大值时，redis 使用的清楚策略。有以下几种可以选择：<br>1）volatile-lru 利用 LRU 算法移除设置过过期时间的 key (LRU: 最近使用 Least Recently Used)<br>2）allkeys-lru 利用 LRU 算法移除任何 key<br>3）volatile-random 移除设置过过期时间的随机 key<br>4）allkeys-random 移除随机 ke<br>5）volatile-ttl 移除即将过期的 key (minor TTL)<br>6）noeviction noeviction 不移除任何 key，只是返回一个写错误 ，默认选项</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure><p>LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法 (为了节省内存)<br>随意你可以选择样本大小进行检，redis 默认选择 3 个样本进行检测，你可以通过 maxmemory-samples 进行设置样本数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure><p>默认 redis 使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了。但是 redis 如果中途宕机，<br>会导致可能有几分钟的数据丢失，根据 save 来策略进行持久化，Append Only File 是另一种持久化方式，<br>可以提供更好的持久化特性。Redis 会把每次写入的数据在接收后都写入 appendonly.aof 文件，<br>每次启动时 Redis 都会先把这个文件的数据读入内存里，先忽略 RDB 文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><p>aof 文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p>aof 持久化策略的配置<br>no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快。<br>always 表示每次写入都执行 fsync，以保证数据同步到磁盘。<br>everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no-appendfsync-on-rewrite no</span><br></pre></td></tr></table></figure><p>在 aof 重写或者写入 rdb 文件的时候，会执行大量 IO，此时对于 everysec 和 always 的 aof 模式来说，<br>执行 fsync 会造成阻塞过长时间，no-appendfsync-on-rewrite 字段设置为默认设置为 no。<br>如果对延迟要求很高的应用，这个字段可以设置为 yes，否则还是设置为 no，这样对持久化特性来说这是更安全的选择。<br>设置为 yes 表示 rewrite 期间对新写操作不 fsync, 暂时存在内存中，等 rewrite 完成后再写入，默认为 no，建议 yes。<br>Linux 的默认 fsync 策略是 30 秒。可能丢失 30 秒数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure><p>aof 自动重写配置，当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写，<br>即当 aof 文件增长到一定大小的时候，Redis 能够调用 bgrewriteaof 对日志文件进行重写。<br>当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍（设置为 100）时，自动启动新的日志重写过程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>设置允许重写的最小 aof 文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure><p>aof 文件可能在尾部是不完整的，当 redis 启动的时候，aof 文件的数据被载入内存。<br>重启可能发生在 redis 所在的主机操作系统宕机后，尤其在 ext4 文件系统没有加上 data=ordered 选项，出现这种现象<br>redis 宕机或者异常终止不会造成尾部不完整现象，可以选择让 redis 退出，或者导入尽可能多的数据。<br>如果选择的是 yes，当截断的 aof 文件被导入的时候，会自动发布一个 log 给客户端然后 load。<br>如果是 no，用户必须手动 redis-check-aof 修复 AOF 文件才可以。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua-time-limit 5000</span><br></pre></td></tr></table></figure><p>如果达到最大时间限制（毫秒），redis 会记个 log，然后返回 error。当一个脚本超过了最大时限。<br>只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 可以用。第一个可以杀没有调 write 命令的东西。<br>要是已经调用了 write，只能用第二个命令杀</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure><p>集群开关，默认是不开启集群模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-config-file nodes-6379.conf</span><br></pre></td></tr></table></figure><p>集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。<br>这个文件并不需要手动配置，这个配置文件有 Redis 生成并更新，每个 Redis 集群节点需要一个单独的配置文件<br>请确保与实例运行的系统中配置文件名称不冲突</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure><p>节点互连超时的阀值，集群节点超时毫秒数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-slave-validity-factor 10</span><br></pre></td></tr></table></figure><p>在进行故障转移的时候，全部 slave 都会请求申请为 master，但是有些 slave 可能与 master 断开连接一段时间了，<br>导致数据过于陈旧，这样的 slave 不应该被提升为 master。该参数就是用来判断 slave 节点与 master 断线的时间是否过长。<br>判断方法是：<br>比较 slave 断开连接的时间和 (node-timeout * slave-validity-factor) + repl-ping-slave-period<br>如果节点超时时间为三十秒，并且 slave-validity-factor 为 10,<br>假设默认的 repl-ping-slave-period 是 10 秒，即如果超过 310 秒 slave 将不会尝试进行故障转移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-migration-barrier 1</span><br></pre></td></tr></table></figure><p>master 的 slave 数量大于该值，slave 才能迁移到其他孤立 master 上，如这个参数若被设为 2，<br>那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure><p>默认情况下，集群全部的 slot 有节点负责，集群状态才为 ok，才能提供服务。<br>设置为 no，可以在 slot 没有全部分配的时候提供服务。<br>不建议打开该配置，这样会造成分区的时候，小分区的 master 一直在接受写请求，而造成很长时间数据不一致</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slowlog-log-slower-than 10000</span><br></pre></td></tr></table></figure><p>slog log 是用来记录 redis 运行中执行比较慢的命令耗时。<br>当命令的执行超过了指定时间，就记录在 slow log 中，slog log 保存在内存中，所以没有 IO 操作。<br>执行时间比 slowlog-log-slower-than 大的请求记录到 slowlog 里面，单位是微秒，所以 1000000 就是 1 秒。<br>注意，负数时间会禁用慢查询日志，而 0 则会强制记录所有命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure><p>慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉，这个长度没有限制。<br>只要有足够的内存就行，你可以通过 SLOWLOG RESET 来释放内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">latency-monitor-threshold 0</span><br></pre></td></tr></table></figure><p>延迟监控功能是用来监控 redis 中执行比较缓慢的一些操作，用 LATENCY 打印 redis 实例在跑命令时的耗时图表。<br>只记录大于等于下边设置的值的操作，0 的话，就是关闭监视。<br>默认延迟监控功能是关闭的，如果你需要打开，也可以通过 CONFIG SET 命令动态设置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">notify-keyspace-events &quot;&quot;</span><br></pre></td></tr></table></figure><p>键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。<br>notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：<br>K 键空间通知，所有通知以 <strong>keyspace@</strong> 为前缀<br>E 键事件通知，所有通知以 <strong>keyevent@</strong> 为前缀<br>g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知<br>$ 字符串命令的通知<br>l 列表命令的通知<br>s 集合命令的通知<br>h 哈希命令的通知<br>z 有序集合命令的通知<br>x 过期事件：每当有过期键被删除时发送<br>e 驱逐 (evict) 事件：每当有键因为 maxmemory 政策而被删除时发送<br>A 参数 g$lshzxe 的别名<br>输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br></pre></td></tr></table></figure><p>hash 类型的数据结构在编码上可以使用 ziplist 和 hashtable。<br>ziplist 的特点就是文件存储 (以及内存存储) 所需的空间较小，在内容较小时，性能和 hashtable 几乎一样。<br>因此 redis 对 hash 类型默认采取 ziplist。如果 hash 中条目的条目个数或者 value 长度达到阀值，将会被重构为 hashtable。<br>这个参数指的是 ziplist 中允许存储的最大条目个数，，默认为 512，建议为 128</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure><p>ziplist 中允许条目 value 值最大字节数，默认为 64，建议为 1024</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list-max-ziplist-size -2</span><br></pre></td></tr></table></figure><p>当取正值的时候，表示按照数据项个数来限定每个 quicklist 节点上的 ziplist 长度。比如，当这个参数配置成 5 的时候，表示每个 quicklist 节点的 ziplist 最多包含 5 个数据项。<br>当取负值的时候，表示按照占用字节数来限定每个 quicklist 节点上的 ziplist 长度。这时，它只能取 - 1 到 - 5 这五个值，每个值含义如下：<br>-5: 每个 quicklist 节点上的 ziplist 大小不能超过 64 Kb。（注：1kb =&gt; 1024 bytes）<br>-4: 每个 quicklist 节点上的 ziplist 大小不能超过 32 Kb。<br>-3: 每个 quicklist 节点上的 ziplist 大小不能超过 16 Kb。<br>-2: 每个 quicklist 节点上的 ziplist 大小不能超过 8 Kb。（-2 是 Redis 给出的默认值）<br>-1: 每个 quicklist 节点上的 ziplist 大小不能超过 4 Kb。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list-compress-depth 0</span><br></pre></td></tr></table></figure><p>这个参数表示一个 quicklist 两端不被压缩的节点个数。<br>注：这里的节点个数是指 quicklist 双向链表的节点个数，而不是指 ziplist 里面的数据项个数。<br>实际上，一个 quicklist 节点上的 ziplist，如果被压缩，就是整体被压缩的。<br>参数 list-compress-depth 的取值含义如下：<br>0: 是个特殊值，表示都不压缩。这是 Redis 的默认值。<br>1: 表示 quicklist 两端各有 1 个节点不压缩，中间的节点压缩。<br>2: 表示 quicklist 两端各有 2 个节点不压缩，中间的节点压缩。<br>3: 表示 quicklist 两端各有 3 个节点不压缩，中间的节点压缩。<br>依此类推…<br>由于 0 是个特殊值，很容易看出 quicklist 的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-max-intset-entries 512</span><br></pre></td></tr></table></figure><p>数据量小于等于 set-max-intset-entries 用 intset，大于 set-max-intset-entries 用 set</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br></pre></td></tr></table></figure><p>数据量小于等于 zset-max-ziplist-entries 用 ziplist，大于 zset-max-ziplist-entries 用 zset</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hll-sparse-max-bytes 3000</span><br></pre></td></tr></table></figure><p>value 大小小于等于 hll-sparse-max-bytes 使用稀疏数据结构（sparse）<br>大于 hll-sparse-max-bytes 使用稠密的数据结构（dense），一个比 16000 大的 value 是几乎没用的，<br>建议的 value 大概为 3000。如果对 CPU 要求不高，对空间要求较高的，建议设置到 10000 左右</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure><p>Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用。<br>当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no。<br>如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit normal 0 0 0</span><br></pre></td></tr></table></figure><p>对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。<br>对于 normal client，第一个 0 表示取消 hard limit，第二个 0 和第三个 0 表示取消 soft limit，normal client 默认取消限制，因为如果没有寻问，他们是不会接收数据的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br></pre></td></tr></table></figure><p>对于 slave client 和 MONITER client，如果 client-output-buffer 一旦超过 256mb，又或者超过 64mb 持续 60 秒，那么服务器就会立即断开客户端连接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure><p>对于 pubsub client，如果 client-output-buffer 一旦超过 32mb，又或者超过 8mb 持续 60 秒，那么服务器就会立即断开客户端连接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hz 10</span><br></pre></td></tr></table></figure><p>redis 执行任务的频率为 1s 除以 hz</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>在 aof 重写的时候，如果打开了 aof-rewrite-incremental-fsync 开关，系统会每 32MB 执行一次 fsync。<br>这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">YiMing</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://prehitting.gitee.io/2022/05/19/Redis/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/">https://prehitting.gitee.io/2022/05/19/Redis/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">YiMing</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/2022/05/20/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB/"><div class="card-image"><img src="/medias/featureimages/16.jpg" class="responsive-img" alt="Redis持久化_RDB"> <span class="card-title">Redis持久化_RDB</span></div></a><div class="card-content article-content"><div class="summary block-with-text"># 持久化操作之 RDB（Redis DataBase） redis 是内存数据库，如果不将内存中的数据保存到磁盘，那么一旦服务器进程退出，服务器中的数据状态也会消失，所以 redis 提供了持久化的功能 原理是 redis 会单独创建（f</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2022-05-20 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis/" class="post-category">Redis</a></span></div></div><div class="card-action article-tags"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/2022/05/18/SLF4J/Errors/Error01/"><div class="card-image"><img src="/medias/featureimages/1.jpg" class="responsive-img" alt="Error01"> <span class="card-title">Error01</span></div></a><div class="card-content article-content"><div class="summary block-with-text"># 错误明细 SLF4J: No SLF4J providers were found.SLF4J: Defaulting to no-operation (NOP) logger implementation # 背景 在项目中引入 lo</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2022-05-18 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/SLF4J/" class="post-category">SLF4J </a><a href="/categories/SLF4J/Errors/" class="post-category">Errors</a></span></div></div><div class="card-action article-tags"><a href="/tags/SLF4J/"><span class="chip bg-color">SLF4J</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2022</span> <a href="/about" target="_blank">YiMing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/prehitting" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:2480992876@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2480992876" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2480992876" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/libs/others/clicklove.js" async></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script></body></html>