{
    "version": "https://jsonfeed.org/version/1",
    "title": "不利索の鸣 • All posts by \"设计模式\" tag",
    "description": "欢迎来到鸣崽的空间，这里不仅有学习，还有生活",
    "home_page_url": "https://prehitting.gitee.io",
    "items": [
        {
            "id": "https://prehitting.gitee.io/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/",
            "url": "https://prehitting.gitee.io/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/",
            "title": "动态代理模式",
            "date_published": "2022-05-11T01:32:59.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述</h2>\n<ul>\n<li>动态代理和静态代理角色一样</li>\n<li>动态代理的代理类是动态生成的，不是我们直接写好的</li>\n<li>动态代理分为两大类，基于接口的动态代理，基于类的动态代理\n<ul>\n<li>基于接口–JDK 动态代理</li>\n<li>基于类：cglib</li>\n<li>java 字节码实现：JAVAsist</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"jdk动态代理\"><a class=\"markdownIt-Anchor\" href=\"#jdk动态代理\">#</a> JDK 动态代理</h2>\n<blockquote>\n<p>使用 java 反射包 (java.lang.reflect) 中的类和接口事项动态代理的功能</p>\n<p>里面有三个类：InvocationHandler，Method，Proxy</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IUserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">delete</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 业务层模拟</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IUserService</span>&#123;</span><br><span class=\"line\">    UserMapper userMapper;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;select方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;insert方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;update方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">delete</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;delete方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setTarget</span><span class=\"params\">(Object target)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target=target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getProxy</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(<span class=\"built_in\">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        log(method.getName());</span><br><span class=\"line\">        Object result=method.invoke(target,args);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(String methodName)</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行了&quot;</span>+methodName+<span class=\"string\">&quot;方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//真实对象</span></span><br><span class=\"line\">        UserServiceImpl userService=<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>();</span><br><span class=\"line\">        <span class=\"comment\">//代理对象的调用处理程序</span></span><br><span class=\"line\">        ProxyInvocationHandler proxyInvocationHandler=<span class=\"keyword\">new</span> <span class=\"title class_\">ProxyInvocationHandler</span>();</span><br><span class=\"line\">        proxyInvocationHandler.setTarget(userService); <span class=\"comment\">//设置要代理的对象</span></span><br><span class=\"line\">        IUserService proxy= (IUserService) proxyInvocationHandler.getProxy();<span class=\"comment\">//动态生成代理类</span></span><br><span class=\"line\">        proxy.delete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "设计模式",
                "动态代理模式"
            ]
        },
        {
            "id": "https://prehitting.gitee.io/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/",
            "url": "https://prehitting.gitee.io/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/",
            "title": "静态代理模式",
            "date_published": "2022-05-11T00:50:56.000Z",
            "content_html": "<p><img src=\"/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/image-20220511090735455-16522312578361.png\" alt=\"image-20220511090735455\"></p>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>​\t\t所谓静态也就是在程序运行前就已经存在代理类的<a href=\"https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&amp;spm=1001.2101.3001.7020\">字节码</a>文件，代理类和委托类的关系在运行前就确定了</p>\n<p>举例理解：以租房为例，房东只需要处理自己的房子交给中介即可，其余的都是由中介充当代理进行租客签协议，带租客看房子，等等。</p>\n<p><strong>静态代理需要满足三点</strong></p>\n<p>1、需要有真实角色<br>\n  2、需要有一个代理角色<br>\n  3、这两个角色之间必须实现相同的接口</p>\n<h2 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Rent</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">rent</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 房东</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Host</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Rent</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rent</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;房东出租房子&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 代理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Rent</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Host host;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        host.rent();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">seeHouse</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;房东带你看房&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fare</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;受中介费&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">contract</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;签合同&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Host host=<span class=\"keyword\">new</span> <span class=\"title class_\">Host</span>();</span><br><span class=\"line\">        <span class=\"comment\">//房东要出租房子</span></span><br><span class=\"line\">        Proxy proxy=<span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(host);</span><br><span class=\"line\">        <span class=\"comment\">//代理，中介帮房东出租，代理角色一般会有一些附属操作</span></span><br><span class=\"line\">        proxy.rent();</span><br><span class=\"line\">        <span class=\"comment\">//你不用面对房东，直接找中介租房即可</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点：</h2>\n<ul>\n<li>可以使真实角色操作更加纯粹，只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点</li>\n<li>公共业务交给了代理角色，实现了业务的分工</li>\n<li>公共业务发生扩展的时候，方便集中管理</li>\n</ul>\n<h2 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h2>\n<ul>\n<li>\n<p>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</p>\n</li>\n<li>\n<p>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p>\n</li>\n</ul>\n",
            "tags": [
                "设计模式",
                "静态代理模式"
            ]
        },
        {
            "id": "https://prehitting.gitee.io/2022/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/",
            "url": "https://prehitting.gitee.io/2022/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/",
            "title": "原型模式",
            "date_published": "2022-05-10T10:29:20.000Z",
            "content_html": "<h2 id=\"原型模式\"><a class=\"markdownIt-Anchor\" href=\"#原型模式\">#</a> 原型模式</h2>\n<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>\n<h2 id=\"介绍\"><a class=\"markdownIt-Anchor\" href=\"#介绍\">#</a> 介绍</h2>\n<p>** 意图：** 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>\n<p>** 主要解决：** 在运行期建立和删除原型。</p>\n<p><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p>\n<p>** 如何解决：** 利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>\n<p><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone ()，在 .NET 中可以使用 Object 类的 MemberwiseClone () 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些 &quot;易变类&quot; 拥有稳定的接口。</p>\n<p><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone () 方法。</p>\n<p><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。</p>\n<p><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p>\n<p><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>\n<p>** 注意事项：** 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>\n<h2 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Video</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Cloneable</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date createTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//深克隆</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">        Video video=(Video) obj;</span><br><span class=\"line\">        video.createTime= (Date) <span class=\"built_in\">this</span>.createTime.clone();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@EqualsAndHashCode</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Video</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Cloneable</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date createTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 浅拷贝</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 客户端实现克隆</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BilibiliServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> CloneNotSupportedException &#123;</span><br><span class=\"line\">        Date date=<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">        Video video=<span class=\"keyword\">new</span> <span class=\"title class_\">Video</span>(<span class=\"string\">&quot;my_video&quot;</span>,date);</span><br><span class=\"line\">        System.out.println(video.hashCode());</span><br><span class=\"line\">        Video v2= (Video) video.clone();</span><br><span class=\"line\">        System.out.println(v2.hashCode());</span><br><span class=\"line\">        <span class=\"comment\">//两个对象指向同一个date，为浅克隆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "设计模式",
                "原型模式"
            ]
        },
        {
            "id": "https://prehitting.gitee.io/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/",
            "url": "https://prehitting.gitee.io/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/",
            "title": "建造者模式",
            "date_published": "2022-05-09T01:39:18.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述</h2>\n<h3 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h3>\n<blockquote>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>\n</blockquote>\n<h3 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h3>\n<ol>\n<li>封装性好，构建和表示分离</li>\n<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦</li>\n<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险</li>\n</ol>\n<h3 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h3>\n<ol>\n<li>产品的组成部分必须相同，限制了其使用范围</li>\n<li>如果产品的内部变化复杂，若产品内部发生改变，则建造者也要同步修改，后期维护成本大</li>\n</ol>\n<p>建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重部件的创建过程，但两者可以结合使用</p>\n<h2 id=\"模式结构\"><a class=\"markdownIt-Anchor\" href=\"#模式结构\">#</a> 模式结构</h2>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>产品角色（Product）</td>\n<td>包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件</td>\n</tr>\n<tr>\n<td>抽象建造者（Builder）</td>\n<td>它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult ()</td>\n</tr>\n<tr>\n<td>具体建造者 (Concrete Builder）</td>\n<td>实现 Builder 接口，完成复杂产品的各个部件的具体创建方法</td>\n</tr>\n<tr>\n<td>指挥者（Director）</td>\n<td>调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20220509121913779-16520699567131.png\" alt=\"image-20220509121913779\"></p>\n<h2 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@EqualsAndHashCode</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String buildA;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String buildB;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String buildC;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String buildD;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildA</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildB</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildC</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildD</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> Product <span class=\"title function_\">getProduct</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Builder</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Product product;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.product = <span class=\"keyword\">new</span> <span class=\"title class_\">Product</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">buildA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构建部件A&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">buildB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构建部件B&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">buildC</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构建部件C&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">buildD</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构建部件D&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Product <span class=\"title function_\">getProduct</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> product;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Director</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//指挥Worker</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Product <span class=\"title function_\">build</span><span class=\"params\">(Builder builder)</span>&#123;</span><br><span class=\"line\">        builder.buildA();</span><br><span class=\"line\">        builder.buildB();</span><br><span class=\"line\">        builder.buildC();</span><br><span class=\"line\">        builder.buildD();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder.getProduct();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用场景\"><a class=\"markdownIt-Anchor\" href=\"#应用场景\">#</a> 应用场景</h2>\n<p>建造者模式唯一区别于工厂模式的是针对<strong>复杂对象</strong>的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。</p>\n<p>当需要创建的产品具备复杂创建过程时，可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。</p>\n<p>建造者模式主要适用于以下应用场景：</p>\n<ul>\n<li>相同的方法，不同的执行顺序，产生不同的结果。</li>\n<li>多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。</li>\n<li>产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。</li>\n<li>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。</li>\n</ul>\n<h2 id=\"建造者模式和工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#建造者模式和工厂模式\">#</a> 建造者模式和工厂模式</h2>\n<ul>\n<li>建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。</li>\n<li>创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样</li>\n<li>关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。</li>\n<li>建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。</li>\n</ul>\n",
            "tags": [
                "设计模式",
                "建造者模式"
            ]
        },
        {
            "id": "https://prehitting.gitee.io/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/",
            "url": "https://prehitting.gitee.io/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/",
            "title": "工厂模式",
            "date_published": "2022-05-08T02:41:45.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述</h2>\n<ul>\n<li>作用\n<ul>\n<li>实现了创建者和调用者的分离</li>\n<li>详细分类\n<ul>\n<li>简单工厂模式</li>\n<li>工厂方法模式</li>\n<li>抽象工厂模式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>OOP 满足\n<ul>\n<li>开闭原则</li>\n<li>依赖倒转</li>\n<li>迪米特</li>\n</ul>\n</li>\n<li>核心本质\n<ul>\n<li>实例化对象不使用 new，用工厂方法代替</li>\n<li>将选择实现类，创建对象统一管理和控制，从而将调用者跟实现类解耦</li>\n</ul>\n</li>\n<li>三种模式\n<ul>\n<li>简单（静态）工厂模式\n<ul>\n<li>用来生产同一等级结构中的任意产品（对于增加的新的产品，需要覆盖已有的代码）</li>\n</ul>\n</li>\n<li>工厂方法模式\n<ul>\n<li>用来生产同一等级结构中的固定产品（支持增加任意产品）</li>\n</ul>\n</li>\n<li>抽象工厂模式\n<ul>\n<li>围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"简单工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#简单工厂模式\">#</a> 简单工厂模式</h3>\n<p>代码背景：有一个 consumer 前来买车</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Car</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">name</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeSiLa</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Car</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">name</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;TeSiLa&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WuLing</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Car</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">name</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;WuLing&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CarFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Car <span class=\"title function_\">getCar</span><span class=\"params\">(String car)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (car.equals(<span class=\"string\">&quot;WuLing&quot;</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WuLing</span>();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (car.equals(<span class=\"string\">&quot;TeSiLa&quot;</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TeSiLa</span>();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Car</span> <span class=\"variable\">car</span> <span class=\"operator\">=</span> CarFactory.getCar(<span class=\"string\">&quot;WuLing&quot;</span>);</span><br><span class=\"line\">        car.name();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"模式组成\"><a class=\"markdownIt-Anchor\" href=\"#模式组成\">#</a> 模式组成</h4>\n<table>\n<thead>\n<tr>\n<th>组成（角色）</th>\n<th>关系</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>抽象产品</td>\n<td>具体产品的父类</td>\n<td>描述产品的公共接口</td>\n</tr>\n<tr>\n<td>具体产品</td>\n<td>抽象产品的子类；工厂类创建的目标类</td>\n<td>描述生产的具体产品</td>\n</tr>\n<tr>\n<td>工厂（Creator）</td>\n<td>被外界调用</td>\n<td>根据传入不同参数从而创建不同具体产品类的实例</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"uml类图\"><a class=\"markdownIt-Anchor\" href=\"#uml类图\">#</a> UML 类图</h4>\n<p><img src=\"/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20220508111631047.png\" alt=\"image-20220508111631047\"></p>\n<h4 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h4>\n<ul>\n<li>将创建实例的工作和使用实例的工作分开，使用者不必关心对象如何创建，实现解耦</li>\n<li>将初始化实例时的工作放到工厂进行，使代码更易于维护，更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程</li>\n</ul>\n<h4 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点：</h4>\n<p>​\t如果增加不同品牌的车，需要在工厂中修改或添加方法，不满足 OOP 开闭原则</p>\n<ul>\n<li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响</li>\n<li>违背 “开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂</li>\n<li>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构</li>\n</ul>\n<h4 id=\"应用场景\"><a class=\"markdownIt-Anchor\" href=\"#应用场景\">#</a> 应用场景</h4>\n<ul>\n<li>客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时</li>\n<li>当工厂类负责创建的对象（具体产品）比较少时</li>\n</ul>\n<h2 id=\"方法工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#方法工厂模式\">#</a> 方法工厂模式</h2>\n<p>概述：在简单工厂模式上改进，给每种车增加一个工厂类</p>\n<p>实现：</p>\n<p>Car 类，TeSiLa 类，WuLing 类同上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 工厂方法模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CarFactory</span> &#123;</span><br><span class=\"line\">    Car <span class=\"title function_\">getCar</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TeSiLaFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CarFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Car <span class=\"title function_\">getCar</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TeSiLa</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Car</span> <span class=\"variable\">car</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WuLingFactory</span>().getCar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模式组成-2\"><a class=\"markdownIt-Anchor\" href=\"#模式组成-2\">#</a> 模式组成</h3>\n<table>\n<thead>\n<tr>\n<th>主要角色</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>抽象工厂</td>\n<td>提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct () 来创建产品</td>\n</tr>\n<tr>\n<td>具体工厂</td>\n<td>主要是实现抽象工厂中的抽象方法，完成具体产品的创建</td>\n</tr>\n<tr>\n<td>抽象产品</td>\n<td>定义了产品的规范，描述了产品的主要特性和功能。</td>\n</tr>\n<tr>\n<td>具体产品</td>\n<td>实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"uml类图-2\"><a class=\"markdownIt-Anchor\" href=\"#uml类图-2\">#</a> UML 类图</h3>\n<p><img src=\"/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20220508113730740.png\" alt=\"image-20220508113730740\"></p>\n<blockquote>\n<p>简单工厂模式违背了开闭原则，而工厂方法模式是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则</p>\n</blockquote>\n<h3 id=\"优点-2\"><a class=\"markdownIt-Anchor\" href=\"#优点-2\">#</a> 优点</h3>\n<ul>\n<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>\n<li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li>\n<li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>\n</ul>\n<h3 id=\"缺点-2\"><a class=\"markdownIt-Anchor\" href=\"#缺点-2\">#</a> 缺点</h3>\n<ul>\n<li>类的个数容易过多，增加复杂度</li>\n<li>增加了系统的抽象性和理解难度</li>\n<li>抽象产品只能生产一种产品，此弊端可使用<a href=\"http://c.biancheng.net/view/1351.html\">抽象工厂模式</a>解决。</li>\n</ul>\n<h3 id=\"应用场景-2\"><a class=\"markdownIt-Anchor\" href=\"#应用场景-2\">#</a> 应用场景</h3>\n<ul>\n<li>客户只知道创建产品的工厂名，而不知道具体的产品名。</li>\n<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>\n<li>客户不关心创建产品的细节，只关心产品的品牌</li>\n</ul>\n<h2 id=\"抽象工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#抽象工厂模式\">#</a> 抽象工厂模式</h2>\n<p>代码背景：产品 Phone，Router 交由小米工厂生产</p>\n<p>首先定义产品接口以及小米产品实现类</p>\n<p>然后定义抽象工厂</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProductFactory</span> &#123;</span><br><span class=\"line\">    Phone <span class=\"title function_\">getPhoneProduct</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Router <span class=\"title function_\">getRouterProduct</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>小米工厂需要实现该抽象工厂</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XiaoMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ProductFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Phone <span class=\"title function_\">getPhoneProduct</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XiaoMiPhone</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Router <span class=\"title function_\">getRouterProduct</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XiaoMiRouter</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"概述-2\"><a class=\"markdownIt-Anchor\" href=\"#概述-2\">#</a> 概述</h3>\n<h4 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h4>\n<p>提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类</p>\n<h4 id=\"适用场景\"><a class=\"markdownIt-Anchor\" href=\"#适用场景\">#</a> 适用场景</h4>\n<ul>\n<li>\n<h3 id=\"客户端应用层不依赖于产品实例如何被创建实现等细节\"><a class=\"markdownIt-Anchor\" href=\"#客户端应用层不依赖于产品实例如何被创建实现等细节\">#</a> 客户端（应用层）不依赖于产品实例如何被创建，实现等细节</h3>\n</li>\n<li>\n<p>强调一系列产品相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码</p>\n</li>\n<li>\n<p>提供一个产品类的库，所有的产品以同样的接口出现，从而使客户不依赖于具体的实现</p>\n</li>\n</ul>\n<h4 id=\"优点缺点\"><a class=\"markdownIt-Anchor\" href=\"#优点缺点\">#</a> 优点 &amp; 缺点</h4>\n<ul>\n<li>\n<h4 id=\"优点-3\"><a class=\"markdownIt-Anchor\" href=\"#优点-3\">#</a> 优点</h4>\n<ul>\n<li>具体产品在应用层的代码隔离，无需关心创建的细节</li>\n<li>将一个系列的产品统一到一起创建</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难</li>\n<li>增加了系统的抽象性和理解难度</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "设计模式",
                "工厂模式"
            ]
        },
        {
            "id": "https://prehitting.gitee.io/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "url": "https://prehitting.gitee.io/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "title": "单例模式",
            "date_published": "2022-05-06T15:05:11.000Z",
            "content_html": "<h2 id=\"饿汉式单例模式\"><a class=\"markdownIt-Anchor\" href=\"#饿汉式单例模式\">#</a> 饿汉式单例模式</h2>\n<p>在程序开始时加载所有对象</p>\n<p>问题：可能只需要部分对象，造成空间浪费</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 饿汉式单例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HungryMan</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//提前加载对象</span></span><br><span class=\"line\">    <span class=\"comment\">//可能造成空间浪费</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] bytes0=<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] bytes1=<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] bytes2=<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] bytes3=<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">HungryMan</span> <span class=\"variable\">HUNGRY</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HungryMan</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HungryMan <span class=\"title function_\">getHungryMan</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HUNGRY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"懒汉式单例模式\"><a class=\"markdownIt-Anchor\" href=\"#懒汉式单例模式\">#</a> 懒汉式单例模式</h2>\n<h3 id=\"非并发下\"><a class=\"markdownIt-Anchor\" href=\"#非并发下\">#</a> 非并发下</h3>\n<p>在需要使用该对象时创建对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 懒汉式单例模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LazyMan</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LazyMan</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazyMan lazyMan;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//需要使用时创建</span></span><br><span class=\"line\">    <span class=\"comment\">//以下代码会在并发模式下出现问题，出现多个实例</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazyMan <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lazyMan==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            lazyMan=<span class=\"keyword\">new</span> <span class=\"title class_\">LazyMan</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lazyMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>存在问题</strong></p>\n<blockquote>\n<p>当 A，B 并发时，A,B 同时检测到  lazyMan 为 null，并分别创建对象</p>\n</blockquote>\n<h3 id=\"使用静态内部类\"><a class=\"markdownIt-Anchor\" href=\"#使用静态内部类\">#</a> 使用静态内部类</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Holder</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Holder</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Holder <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> InnerClass.HOLDER;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InnerClass</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Holder</span> <span class=\"variable\">HOLDER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Holder</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"双重检测锁模式处理并发问题\"><a class=\"markdownIt-Anchor\" href=\"#双重检测锁模式处理并发问题\">#</a> 双重检测锁模式处理并发问题</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 懒汉式单例模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LazyMan</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LazyMan</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> LazyMan lazyMan;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//双重检测锁模式，懒汉式单例，DCL懒汉式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazyMan <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lazyMan==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (LazyMan.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lazyMan==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    lazyMan=<span class=\"keyword\">new</span> <span class=\"title class_\">LazyMan</span>();<span class=\"comment\">//但这不是一个原子性操作</span></span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     * 1. 分配内存空间</span></span><br><span class=\"line\"><span class=\"comment\">                     * 2. 执行构造方法，初始化对象</span></span><br><span class=\"line\"><span class=\"comment\">                     * 3. 把对象指向这个空间</span></span><br><span class=\"line\"><span class=\"comment\">                     * 底层执行顺序会被打乱(指令重排)</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lazyMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用反射破坏单例模式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">LazyMan</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> LazyMan.getInstance();</span><br><span class=\"line\">        Constructor&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">LazyMan</span>&gt; declaredConstructor = instance.getClass().getDeclaredConstructor(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        declaredConstructor.setAccessible(<span class=\"literal\">true</span>);<span class=\"comment\">//无视私有构造器</span></span><br><span class=\"line\">        <span class=\"type\">LazyMan</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> declaredConstructor.newInstance();</span><br><span class=\"line\">        System.out.println(instance2);</span><br><span class=\"line\">        System.out.println(instance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>存在问题</strong></p>\n<ol>\n<li>lazyMan=new LazyMan (); 不是一个原子性操作\n<ul>\n<li>执行过程：\n<ol>\n<li>分配内存空间</li>\n<li>执行构造方法</li>\n<li>把对象指向这个空间</li>\n</ol>\n</li>\n<li>123 是正常执行流程，但底层执行时会出现指令重排（执行顺序被打乱）</li>\n</ul>\n</li>\n<li>可以通过反射破坏单例模式</li>\n</ol>\n<h3 id=\"优化\"><a class=\"markdownIt-Anchor\" href=\"#优化\">#</a> 优化</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span><span class=\"literal\">false</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LazyMan</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (LazyMan.class)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag == <span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">                flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;实例已被创建&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><font color=\"red\">但是！！！</font></p>\n<p>依然可以通过反射破坏 flag，从而破坏单例模式</p>\n<h2 id=\"枚举单例\"><a class=\"markdownIt-Anchor\" href=\"#枚举单例\">#</a> 枚举单例</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">EnumSingle</span> &#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    EnumSingle()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> EnumSingle <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        EnumSingle instance1=EnumSingle.INSTANCE;</span><br><span class=\"line\">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        declaredConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        EnumSingle instance2=declaredConstructor.newInstance();</span><br><span class=\"line\">        System.out.println(instance2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>枚举本身也是一个 Class</p>\n<p>枚举类没有空参构造器</p>\n<p>反射不能破坏枚举的单例模式</p>\n<p>通过 JAD 编译枚举类</p>\n<p><img src=\"https://s2.loli.net/2022/05/07/87tNqOGwml3sby1.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li>优点 ：\n<ul>\n<li>只生成一个实例减少系统性能开销</li>\n<li>可以在系统设置全局的访问点，优化共享资源访问</li>\n</ul>\n</li>\n<li>常见实现方式\n<ul>\n<li>饿汉式 （线程安全，调用效率高，不能延迟加载）</li>\n<li>懒汉式（线程安全，调用效率不高，可以延迟加载）</li>\n<li>DCL 懒汉式（由于 JVM 底层内部模型原因，偶尔会出现问题，不建议使用）</li>\n<li>饿汉式改进：静态内部类（线程安全，调用效率高，延迟加载）</li>\n<li>枚举单例（线程安全，调用效率高，不能延迟加载）</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "设计模式",
                "单例模式"
            ]
        },
        {
            "id": "https://prehitting.gitee.io/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/",
            "url": "https://prehitting.gitee.io/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/",
            "title": "OOP七大原则",
            "date_published": "2022-05-06T14:12:48.000Z",
            "content_html": "<blockquote>\n<p>PBP/OBP/OOP 的特征 PBP（基于过程）：函数、域与生命周期的概念、函数重载、函数模板、异常处理、范型算法。 OBP（基于对象）：类（接口）、类的生命周期、类模板。 OOP（面向对象）：继承、多态。 三个概念步步深入，后者包括前者。其目的是实现软件开发的可重用性，解决软件危机（软件工程思想未引入之前）。 OOP 不可避免设计原则的发展与设计模式的产生，这是 OOP 独具的特征决定的（正如前面所说，特征的产生是由其产生目的决定的）。</p>\n</blockquote>\n<blockquote>\n<p>OOP 的方法论：高内聚，低耦合，易复用</p>\n</blockquote>\n<h2 id=\"oop七大原则\"><a class=\"markdownIt-Anchor\" href=\"#oop七大原则\">#</a> OOP 七大原则</h2>\n<h3 id=\"开闭原则ocp\"><a class=\"markdownIt-Anchor\" href=\"#开闭原则ocp\">#</a> 开闭原则 (OCP)</h3>\n<blockquote>\n<p>对扩展开放，对修改关闭</p>\n</blockquote>\n<p>根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。</p>\n<p><strong>扩展开放</strong>：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。</p>\n<p><strong>修改关闭</strong>：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求模块是修改关闭的。</p>\n<h3 id=\"里氏替换原则lsp\"><a class=\"markdownIt-Anchor\" href=\"#里氏替换原则lsp\">#</a> 里氏替换原则 (LSP)</h3>\n<blockquote>\n<p>所有引用基类的地方必须能透明地使用其子类的对象</p>\n</blockquote>\n<blockquote>\n<p>里式替换原则的引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>\n</blockquote>\n<p>​\t也就是说，只有满足以下 2 个条件的 OO 设计才可被认为是满足了 LSP 原则：</p>\n<p>​\t1. 不应该在代码中出现 if/else 之类对派生类类型进行判断的条件。</p>\n<p>​\t2. 派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。</p>\n<h3 id=\"依赖倒置原则dip\"><a class=\"markdownIt-Anchor\" href=\"#依赖倒置原则dip\">#</a> 依赖倒置原则 (DIP)</h3>\n<blockquote>\n<p>高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>\n</blockquote>\n<p>面向接口编程，不要面向实现编程</p>\n<h3 id=\"单一职责原则\"><a class=\"markdownIt-Anchor\" href=\"#单一职责原则\">#</a> 单一职责原则</h3>\n<blockquote>\n<p>控制类的粒度大小，将对象解耦，提高其内聚性</p>\n</blockquote>\n<p>单一职责原则：<strong><em>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中</em>。</strong><br>\n单一职责原则的另一种定义方式：<strong><em>就一个类而言，应该仅有一个引起它变化的原因</em>。</strong></p>\n<h3 id=\"接口隔离原则isp\"><a class=\"markdownIt-Anchor\" href=\"#接口隔离原则isp\">#</a> 接口隔离原则（ISP）</h3>\n<blockquote>\n<p><strong>使用多个专门的接口，而不使用单一 的总接口，即客户端不应该依赖那些它不需要的接口。</strong></p>\n</blockquote>\n<p>​\t换句话说，使用多个专门的接口比使用单一的总接口总要好。</p>\n<p>它包含了 2 层意思：</p>\n<ol>\n<li>\n<p>接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。</p>\n</li>\n<li>\n<p>接口的依赖（继承）原则：如果一个接口 a 继承另一个接口 b，则接口 a 相当于继承了接口 b 的方法，那么继承了接口 b 后的接口 a 也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口 a 被 b 给污染了，应该重新设计它们的关系。</p>\n</li>\n</ol>\n<p>​\t根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接 口的客户端仅需知道与之相关的方法即可。</p>\n<h3 id=\"迪米特法则lod\"><a class=\"markdownIt-Anchor\" href=\"#迪米特法则lod\">#</a> 迪米特法则 (LoD)</h3>\n<p>也叫<font color=\"red\">最少知道原则</font></p>\n<blockquote>\n<p>只与直接的朋友交谈，不和 “陌生人 “说话</p>\n</blockquote>\n<p>​\t迪米特法则可以简单说成：talk only to your immediate friends。 对于 OOD 来说，又被解释为下面几种方式：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p>\n<p>​\t迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p>\n<p>​\t迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系 —— 这在一定程度上增加了系统的复杂度。</p>\n<p>​\t如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>\n<h4 id=\"lod法则缺点\"><a class=\"markdownIt-Anchor\" href=\"#lod法则缺点\">#</a> LoD 法则缺点</h4>\n<p>​\t在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。</p>\n<p>​\t遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。</p>\n<h3 id=\"合成复用原则carp\"><a class=\"markdownIt-Anchor\" href=\"#合成复用原则carp\">#</a> 合成复用原则 (CARP)</h3>\n<blockquote>\n<p>尽量先使用组合或者聚合等关联关系来实现，其次考虑使用继承关系来实现</p>\n</blockquote>\n",
            "tags": [
                "设计模式",
                "OOP"
            ]
        },
        {
            "id": "https://prehitting.gitee.io/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/",
            "url": "https://prehitting.gitee.io/2022/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/",
            "title": "设计模式概述",
            "date_published": "2022-05-06T14:02:20.000Z",
            "content_html": "<h2 id=\"本质优点\"><a class=\"markdownIt-Anchor\" href=\"#本质优点\">#</a> 本质 &amp; 优点</h2>\n<hr>\n<ul>\n<li>\n<p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性，继承性和多态性及类的关联关系和组合关系的充分理解</p>\n</li>\n<li>\n<p>正确使用设计模式的优点</p>\n<ul>\n<li>提高思维，编程和设计能力</li>\n<li>使程序设计标准化，代码编制更加工程化，提高软件开发效率，缩短开发周期</li>\n<li>代码可重用性高，可读性强，可靠性高，灵活性好，可维护性强</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"设计模式的基本要素\"><a class=\"markdownIt-Anchor\" href=\"#设计模式的基本要素\">#</a> 设计模式的基本要素</h2>\n<ul>\n<li>\n<p>模式名称</p>\n<ul>\n<li>GoF23\n<ul>\n<li>创建型模式：\n<ul>\n<li>单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式</li>\n</ul>\n</li>\n<li>结构性模式：\n<ul>\n<li>适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式</li>\n</ul>\n</li>\n<li>行为型模式：\n<ul>\n<li>模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>问题</p>\n</li>\n<li>\n<p>解决方案</p>\n</li>\n<li>\n<p>效果</p>\n</li>\n</ul>\n",
            "tags": [
                "设计模式"
            ]
        }
    ]
}