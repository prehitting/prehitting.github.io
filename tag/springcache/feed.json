{
    "version": "https://jsonfeed.org/version/1",
    "title": "不利索の鸣 • All posts by \"springcache\" tag",
    "description": "欢迎来到鸣崽的空间，这里不仅有学习，还有生活",
    "home_page_url": "https://prehitting.gitee.io",
    "items": [
        {
            "id": "https://prehitting.gitee.io/2022/06/24/SpringCache%E5%85%A5%E9%97%A8/",
            "url": "https://prehitting.gitee.io/2022/06/24/SpringCache%E5%85%A5%E9%97%A8/",
            "title": "SpringCache入门",
            "date_published": "2022-06-24T11:55:57.000Z",
            "content_html": "<h2 id=\"缓存的概念\"><a class=\"markdownIt-Anchor\" href=\"#缓存的概念\">#</a> 缓存的概念</h2>\n<p>我们可以将缓存定义为一种存储机制，它将数据保存在某个地方，并以一种更快的方式提供服务。</p>\n<p>要理解缓存，我们先了解下基本概念</p>\n<h3 id=\"缓存命中率\"><a class=\"markdownIt-Anchor\" href=\"#缓存命中率\">#</a> 缓存命中率</h3>\n<p>即从缓存中读取数据的次数与总读取次数的比率。 一般来讲，命中率越高也好。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">命中率 = 从缓存中读取的次数  / (总读取次数[从缓存中读取的次数+从慢速设备上读取的次数])</span><br></pre></td></tr></table></figure>\n<p>复制</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Miss</span>率 = 没从缓存中读取的次数/ (总读取次数[从缓存中读取的次数+从慢速设备上读取的次数])</span><br></pre></td></tr></table></figure>\n<p>复制</p>\n<p>这是一个非常重要的监控指标，如果要做缓存，就一定要监控这个指标，来看缓存是否工作良好。</p>\n<hr>\n<h3 id=\"过期策略\"><a class=\"markdownIt-Anchor\" href=\"#过期策略\">#</a> 过期策略</h3>\n<p>即如果缓存满了，从缓存中移除数据的策略，常见的有 LFU 、LRU、FIFO</p>\n<ul>\n<li>FIFO (First in First Out) <strong>先进先出策略</strong>，即先放入缓存的数据先被移除</li>\n<li>LRU (Least Recently Used) <strong>最久未使用策略</strong>， 即使用时间距离现在最久的那个数据被移除</li>\n<li>LFU (Leaset Frequently Used) <strong>最近最少使用策略</strong>，即一定时间内使用次数（频率）最少的那个数据被移除</li>\n<li>TTL（Time To Live）<strong>存活期</strong>，即从缓存中创建时间点开始至到期的一个时间段（不管在这个时间段内有没被访问过都将过期）</li>\n<li>TTI （Time To Idle）<strong>空闲期</strong>，即一个数据多久没有被访问就从缓存中移除的时间。</li>\n</ul>\n<p>至此，我们基本了解了缓存的一些基本知识。 在 Java 中一般会对调用方法进行缓存控制，比如 findUserById (Sting id),<strong> 先从缓存中查找有没有符合查询条件的数据，如果没有，则执行改方法从数据库中查找该用户，然后添加到缓存中，下次调用时将从缓存中获取。</strong></p>\n<p>从 Spring3.1 开始，提供了缓存注解，并且提供了 Cache 层的抽象。 此外，JSR-107 也从 Spring4.0 开始得到全面支持。</p>\n<p>Spring 提供可一种可以在方法级别进行缓存的缓存抽象。 通过使用 AOP 对方法机型织入，如果已经为特定方法入参执行过该方法，那么不必执行实际方法就可以返回被缓存的结果。</p>\n<p>为了启用 AOP 缓存功能，需要使用缓存注解对类中的相关方法进行标记，以便 Spring 为其生成具备缓存功能的代理类。 需要注意的是，Spring Cache 仅提供了一种抽象而未提供具体的实现。 我们以便会自己使用 AIP 来做一定程度的封装实现。</p>\n<h2 id=\"通用缓存springcache\"><a class=\"markdownIt-Anchor\" href=\"#通用缓存springcache\">#</a> 通用缓存 SpringCache</h2>\n<p>Spring Cache 是 Spring 提供的通用缓存框架。它利用了 AOP，实现了基于注解的缓存功能，使开发者不用关心底层使用了什么缓存框架，只需要简单地加一个注解，就能实现缓存功能了。用户使用 Spring Cache，可以快速开发一个很不错的缓存功能。</p>\n<h4 id=\"问题分析\"><a class=\"markdownIt-Anchor\" href=\"#问题分析\">#</a> 问题分析</h4>\n<p><img src=\"/2022/06/24/SpringCache%E5%85%A5%E9%97%A8/1279412-20220113152236129-2034256100.png\" alt=\"img\"></p>\n<p><img src=\"/2022/06/24/SpringCache%E5%85%A5%E9%97%A8/1279412-20220113152509989-1902173257.png\" alt=\"img\"></p>\n<h3 id=\"spring-cache的好处\"><a class=\"markdownIt-Anchor\" href=\"#spring-cache的好处\">#</a> Spring Cache 的好处</h3>\n<ul>\n<li>支持开箱即用（Out Of The Box），并提供基本的 Cache 抽象，方便切换各种底层 Cache</li>\n<li>通过 Cache 注解即可实现缓存逻辑透明化，让开发者关注业务逻辑</li>\n<li>当事务回滚时，缓存也会自动回滚</li>\n<li>支持比较复杂的缓存逻辑</li>\n<li>提供缓存编程的一致性抽象，方便代码维护。</li>\n</ul>\n<h3 id=\"spring-cache的缺点\"><a class=\"markdownIt-Anchor\" href=\"#spring-cache的缺点\">#</a> Spring Cache 的缺点</h3>\n<ul>\n<li>Spring Cache 并不针对多进程的应用环境进行专门的处理。</li>\n<li>另外 Spring Cache 抽象的操作中没有锁的概念，当多线程并发操作（更新或者删除）同一个缓存项时，有可能读取到过期的数据。</li>\n</ul>\n<h2 id=\"入门\"><a class=\"markdownIt-Anchor\" href=\"#入门\">#</a> 入门</h2>\n<h3 id=\"maven依赖\"><a class=\"markdownIt-Anchor\" href=\"#maven依赖\">#</a> maven 依赖</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"基于注解配置\"><a class=\"markdownIt-Anchor\" href=\"#基于注解配置\">#</a> 基于注解配置</h3>\n<ul>\n<li>@EnableCaching：开启缓存功能</li>\n<li>@Cacheable 主要针对注解配置，能够根据方法的请求参数对其进行缓存</li>\n<li>@CachePut：定义更新缓存，触发缓存更新</li>\n<li>@CacheEvict：定义清除缓存，触发缓存清除</li>\n<li>@Caching：组合定义多种缓存功能</li>\n<li>@CacheConfig：定义公共设置，位于 class 之上</li>\n</ul>\n<h4 id=\"enablecaching\"><a class=\"markdownIt-Anchor\" href=\"#enablecaching\">#</a> @EnableCaching</h4>\n<p>该注解主要用于开启基于注解的缓存功能，使用方式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheManager <span class=\"title function_\">cacheManager</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SimpleCacheManager</span> <span class=\"variable\">cacheManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleCacheManager</span>();</span><br><span class=\"line\">        cacheManager.setCaches(Arrays.asList(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentMapCache</span>(<span class=\"string\">&quot;default&quot;</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：在 SpringBoot 中使用 SpringCache 可以由自动配置功能来完成 CacheManager 的注册，SpringBoot 会自动发现项目中拥有的缓存系统，而注册对应的缓存管理器，当然我们也可以手动指定。</p>\n</blockquote>\n<p>使用该注解和如下 XML 配置具有一样的效果：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache:annotation-driven</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cacheManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.cache.support.SimpleCacheManager&gt;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">        &lt;property name=&quot;</span><span class=\"attr\">caches</span>&quot;&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&gt;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                    &lt;property name=&quot;</span><span class=\"attr\">name</span>&quot; <span class=\"attr\">value</span>=<span class=\"string\">&quot;default&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"cacheable\"><a class=\"markdownIt-Anchor\" href=\"#cacheable\">#</a> @Cacheable</h4>\n<p>该注解用于标注于方法之上用于标识该方法的返回结果需要被缓存起来，标注于类之上标识该类中所有方法均需要将结果缓存起来。</p>\n<p>该注解标注的方法每次被调用前都会触发缓存校验，校验指定参数的缓存是否已存在（已发生过相同参数的调用），若存在，直接返回缓存结果，否则执行方法内容，最后将方法执行结果保存到缓存中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable(value = &quot;user&quot;,key = &quot;#userId&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> UserInfo <span class=\"title function_\">queryById</span><span class=\"params\">(Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从数据库查询</span></span><br><span class=\"line\">    <span class=\"type\">UserInfo</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserInfo</span>();</span><br><span class=\"line\">    user.setId(userId);</span><br><span class=\"line\">    user.setNickname(<span class=\"string\">&quot;ceshi&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注解属性中，<mark>value</mark> 是必需的，它指定了你的缓存存放在哪块命名空间</p>\n<h4 id=\"cachevict\"><a class=\"markdownIt-Anchor\" href=\"#cachevict\">#</a> @CachEvict</h4>\n<p>该注解主要针对方法配置，能够根据一定的条件对缓存进行清空。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据id修改</span></span><br><span class=\"line\"><span class=\"meta\">@CacheEvict(value = &quot;user&quot;,key = &quot;#userId&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//修改用户</span></span><br><span class=\"line\">    <span class=\"type\">UserInfo</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserInfo</span>();</span><br><span class=\"line\">    user.setId(userId);</span><br><span class=\"line\">    user.setNickname(<span class=\"string\">&quot;itcast&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"cacheput\"><a class=\"markdownIt-Anchor\" href=\"#cacheput\">#</a> @CachePut</h4>\n<p>该注解用于更新缓存，无论结果是否已经缓存，都会在方法执行结束插入缓存，相当于更新缓存。一般用于更新方法之上。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Log4j2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AnimalService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AnimalRepository animalRepository;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"meta\">@CachePut(value = &quot;animalById&quot;, key = &quot;#animal.id&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseEntity&lt;Animal&gt; <span class=\"title function_\">updateAnimal</span><span class=\"params\">(<span class=\"keyword\">final</span> Animal animal)</span>&#123;</span><br><span class=\"line\">        Wrapper&lt;Animal&gt; animalWrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">UpdateWrapper</span>&lt;&gt;();</span><br><span class=\"line\">        ((UpdateWrapper&lt;Animal&gt;) animalWrapper).eq(<span class=\"string\">&quot;id&quot;</span>,animal.getId());</span><br><span class=\"line\">        animalRepository.update(animal, animalWrapper);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseEntity.ok(<span class=\"built_in\">this</span>.getAnimalById(animal.getId()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"caching\"><a class=\"markdownIt-Anchor\" href=\"#caching\">#</a> @Caching</h4>\n<p>这个注解用于组个多个缓存操作，包括针对不用缓存名称的相同操作等</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Log4j2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AnimalService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AnimalRepository animalRepository;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"meta\">@Caching(</span></span><br><span class=\"line\"><span class=\"meta\">        evict = &#123;</span></span><br><span class=\"line\"><span class=\"meta\">            @CacheEvict(value = &quot;animalById&quot;, key = &quot;#id&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            @CacheEvict(value = &quot;animals&quot;, allEntries = true, beforeInvocation = true)</span></span><br><span class=\"line\"><span class=\"meta\">        &#125;</span></span><br><span class=\"line\"><span class=\"meta\">    )</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseEntity&lt;Integer&gt; <span class=\"title function_\">deleteAnimalById</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"type\">int</span> id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseEntity.ok(animalRepository.deleteById(id));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Cacheable(&quot;animals&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseEntity&lt;Page&lt;Animal&gt;&gt; <span class=\"title function_\">getAnimalPage</span><span class=\"params\">(<span class=\"keyword\">final</span> Animal animal, <span class=\"keyword\">final</span> <span class=\"type\">int</span> pageId, <span class=\"keyword\">final</span> <span class=\"type\">int</span> pageSize)</span>&#123;</span><br><span class=\"line\">        Page&lt;Animal&gt; page = <span class=\"keyword\">new</span> <span class=\"title class_\">Page</span>&lt;&gt;();</span><br><span class=\"line\">        page.setCurrent(pageId);</span><br><span class=\"line\">        page.setSize(pageSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseEntity.ok((Page&lt;Animal&gt;) animalRepository.selectPage(page,packWrapper(animal, WrapperType.QUERY)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"cacheconfig\"><a class=\"markdownIt-Anchor\" href=\"#cacheconfig\">#</a> @CacheConfig</h4>\n<p>该注解标注于类之上，用于进行一些公共的缓存相关配置。</p>\n",
            "tags": [
                "SpringCache",
                "Redis"
            ]
        }
    ]
}