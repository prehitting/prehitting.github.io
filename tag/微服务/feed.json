{
    "version": "https://jsonfeed.org/version/1",
    "title": "不利索の鸣 • All posts by \"微服务\" tag",
    "description": "欢迎来到鸣崽的空间，这里不仅有学习，还有生活",
    "home_page_url": "https://prehitting.gitee.io",
    "items": [
        {
            "id": "https://prehitting.gitee.io/2022/06/28/rpc-kuang-jia/",
            "url": "https://prehitting.gitee.io/2022/06/28/rpc-kuang-jia/",
            "title": "RPC框架",
            "date_published": "2022-06-28T03:00:41.000Z",
            "content_html": "<h2 id=\"rpc\"><a class=\"markdownIt-Anchor\" href=\"#rpc\">#</a> RPC</h2>\n<h3 id=\"什么是rpc\"><a class=\"markdownIt-Anchor\" href=\"#什么是rpc\">#</a> 什么是 RPC</h3>\n<p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p>\n<p>比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>\n<p>那么我们至少从这样的描述中挖掘出几个要点：</p>\n<ul>\n<li>RPC 是协议：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的 RPC 实现包括：Dubbo、Thrift、GRPC、Hetty 等。</li>\n<li>网络协议和网络 IO 模型对其透明：既然 RPC 的客户端认为自己是在调用本地对象。那么传输层使用的是 TCP/UDP 还是 HTTP 协议，又或者是一些其他的网络协议它就不需要关心了。</li>\n<li>信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</li>\n<li>应该有跨语言能力：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</li>\n</ul>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640.png\" alt=\"图片\"></p>\n<h3 id=\"rpc主要组成\"><a class=\"markdownIt-Anchor\" href=\"#rpc主要组成\">#</a> RPC 主要组成</h3>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/70.png\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>\n<p>Client：RPC 协议的调用方。就像上文所描述的那样，最理想的情况是 RPC Client 在完全不知道有 RPC 框架存在的情况下发起对远程服务的调用。但实际情况来说 Client 或多或少的都需要指定 RPC 框架的一些细节。</p>\n</li>\n<li>\n<p>Server：在 RPC 规范中，这个 Server 并不是提供 RPC 服务器 IP、端口监听的模块。而是远程服务方法的具体实现（在 JAVA 中就是 RPC 服务接口的具体实现）。其中的代码是最普通的和业务相关的代码，甚至其接口实现类本身都不知道将被某一个 RPC 远程客户端调用。</p>\n</li>\n<li>\n<p>Stub/Proxy：RPC 代理存在于客户端，因为要实现客户端对 RPC 框架 “透明” 调用，那么客户端不可能自行去管理消息格式、不可能自己去管理网络传输协议，也不可能自己去判断调用过程是否有异常。这一切工作在客户端都是交给 RPC 框架中的 “代理” 层来处理的。</p>\n</li>\n<li>\n<p>Message Protocol：在上文我们已经说到，一次完整的 client-server 的交互肯定是携带某种两端都能识别的，共同约定的消息格式。RPC 的消息管理层专门对网络传输所承载的消息信息进行编码和解码操作。目前流行的技术趋势是不同的 RPC 实现，为了加强自身框架的效率都有一套（或者几套）私有的消息格式。</p>\n</li>\n<li>\n<p>Transfer/Network Protocol：传输协议层负责管理 RPC 框架所使用的网络协议、网络 IO 模型。例如 Hessian 的传输协议基于 HTTP（应用层协议）；而 Thrift 的传输协议基于 TCP（传输层协议）。传输层还需要统一 RPC 客户端和 RPC 服务端所使用的 IO 模型；</p>\n</li>\n<li>\n<p>Selector/Processor：存在于 RPC 服务端，用于服务器端某一个 RPC 接口的实现的特性（它并不知道自己是一个将要被 RPC 提供给第三方系统调用的服务）。所以在 RPC 框架中应该有一种 “负责执行 RPC 接口实现” 的角色。包括：管理 RPC 接口的注册、判断客户端的请求权限、控制接口实现类的执行在内的各种工作。</p>\n</li>\n<li>\n<p>IDL：实际上 IDL（接口定义语言）并不是 RPC 实现中所必须的。但是需要跨语言的 RPC 框架一定会有 IDL 部分的存在。这是因为要找到一个各种语言能够理解的消息结构、接口定义的描述形式。如果您的 RPC 实现没有考虑跨语言性，那么 IDL 部分就不需要包括，例如 JAVA RMI 因为就是为了在 JAVA 语言间进行使用，所以 JAVA RMI 就没有相应的 IDL。</p>\n</li>\n</ul>\n<p>一定要说明一点，不同的 RPC 框架实现都有一定设计差异。例如生成 Stub 的方式不一样，IDL 描述语言不一样、服务注册的管理方式不一样、运行服务实现的方式不一样、采用的消息格式封装不一样、采用的网络协议不一样。但是基本的思路都是一样的，上图中的所列出的要素也都是具有的。</p>\n<h3 id=\"为什么要用rpc\"><a class=\"markdownIt-Anchor\" href=\"#为什么要用rpc\">#</a> 为什么要用 RPC</h3>\n<p>其实这是应用开发到一定的阶段的强烈需求驱动的。如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着。当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要 RPC，因为应用之间是互不关联的。</p>\n<p>当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务 Service 应用 。而原有的、新增的应用都可以与那些独立的 Service 应用 交互，以此来完成完整的业务功能。</p>\n<p>所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，所以你看，RPC 大显身手的时候来了！</p>\n<p>其实描述的场景也是服务化 、微服务和分布式系统架构的基础场景。即 RPC 框架就是实现以上结构的有力方式。</p>\n<h3 id=\"常用的rpc框架\"><a class=\"markdownIt-Anchor\" href=\"#常用的rpc框架\">#</a> 常用的 RPC 框架</h3>\n<ul>\n<li>Thrift：thrift 是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</li>\n<li>gRPC：一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用 (RPC) 系统。</li>\n<li>Dubbo：Dubbo 是一个分布式服务框架，以及 SOA 治理方案。其功能主要包括：高性能 NIO 通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。Dubbo 是阿里巴巴内部的 SOA 服务化治理方案的核心框架，Dubbo 自 2011 年开源后，已被许多非阿里系公司使用。</li>\n<li>Spring Cloud：Spring Cloud 由众多子项目组成，如 Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性 token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud 基于 Spring Boot, 使得开发部署极其简单。</li>\n</ul>\n<h3 id=\"rpc原理\"><a class=\"markdownIt-Anchor\" href=\"#rpc原理\">#</a> RPC 原理</h3>\n<h4 id=\"rpc调用流程\"><a class=\"markdownIt-Anchor\" href=\"#rpc调用流程\">#</a> RPC 调用流程</h4>\n<p>要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个 RPC 调用的流程涉及到哪些通信细节：<img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478511.png\" alt=\"图片\"></p>\n<ol>\n<li>服务消费方（client）调用以本地调用方式调用服务；</li>\n<li>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>\n<li>client stub 找到服务地址，并将消息发送到服务端；</li>\n<li>server stub 收到消息后进行解码；</li>\n<li>server stub 根据解码结果调用本地的服务；</li>\n<li>本地服务执行并将结果返回给 server stub；</li>\n<li>server stub 将返回结果打包成消息并发送至消费方；</li>\n<li>client stub 接收到消息，并进行解码；</li>\n<li>服务消费方得到最终结果。</li>\n</ol>\n<p>RPC 的目标就是要 2~8 这些步骤都封装起来，让用户对这些细节透明。</p>\n<p>下面是网上的另外一幅图，感觉一目了然：</p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478512.png\" alt=\"图片\"></p>\n<p>如何做到透明化远程服务调用</p>\n<p>怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对 java 来说就是使用代理！java 代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现 RPC 框架时还是选择动态代理方式。</p>\n<p>下面简单介绍下动态代理怎么实现我们的需求。我们需要实现 RPCProxyClient 代理类，代理类的 invoke 方法中封装了与远端服务通信的细节，消费方首先从 RPCProxyClient 获得服务提供方的接口，当执行 helloWorldService.sayHello (“test”) 方法时就会调用 invoke 方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RPCProxyClient</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span>InvocationHandler</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RPCProxyClient</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>obj<span class=\"token operator\">=</span>obj<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">/**\n     * 得到被代理对象;\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">getProxy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span>Proxy</span><span class=\"token punctuation\">.</span><span class=\"token function\">newProxyInstance</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                obj<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInterfaces</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RPCProxyClient</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">/**\n     * 调用此方法执行\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> proxy<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Throwable</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//结果参数;</span>\n        <span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// ...执行通信相关逻辑</span>\n        <span class=\"token comment\">// ...</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>         \n     <span class=\"token class-name\">HelloWorldService</span> helloWorldService <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloWorldService</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">RPCProxyClient</span><span class=\"token punctuation\">.</span><span class=\"token function\">getProxy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloWorldService</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     helloWorldService<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>其实就是通过动态代理模式，在执行该方法的前后对数据进行封装和解码等，让用于感觉就像是直接调用该方法一样，殊不知，我们对方法前后都经过了复杂的处理。</p>\n</blockquote>\n<h4 id=\"如何对消息进行编码和解码\"><a class=\"markdownIt-Anchor\" href=\"#如何对消息进行编码和解码\">#</a> 如何对消息进行编码和解码</h4>\n<h5 id=\"确定消息数据结构\"><a class=\"markdownIt-Anchor\" href=\"#确定消息数据结构\">#</a> 确定消息数据结构</h5>\n<p>客户端的请求消息结构一般需要包括以下内容：</p>\n<ul>\n<li>接口名称：在我们的例子里接口名是 “HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</li>\n<li>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</li>\n<li>参数类型 &amp; 参数值：参数类型有很多，比如有 bool、int、long、double、string、map、list，甚至如 struct 等，以及相应的参数值；</li>\n<li>超时时间 + requestID（标识唯一请求 id）</li>\n</ul>\n<p>服务端返回的消息结构一般包括以下内容：</p>\n<ul>\n<li>状态 code + 返回值</li>\n<li>requestID</li>\n</ul>\n<h5 id=\"序列化\"><a class=\"markdownIt-Anchor\" href=\"#序列化\">#</a> 序列化</h5>\n<p>一旦确定了消息的数据结构后，下一步就是要考虑序列化与反序列化了。</p>\n<p>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。</p>\n<p>什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p>\n<p>为什么需要序列化？转换为二进制串后才好进行网络传输嘛！</p>\n<p>为什么需要反序列化？将二进制转换为对象才好进行后续处理！</p>\n<p>现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从 RPC 的角度上看，主要看三点：</p>\n<ul>\n<li>通用性：比如是否能支持 Map 等复杂的数据结构；</li>\n<li>性能：包括时间复杂度和空间复杂度，由于 RPC 框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；</li>\n<li>可扩展性：对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</li>\n</ul>\n<p>目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案来搭建 RPC 框架，这些都是久经考验的解决方案。</p>\n<blockquote>\n<p>消息里为什么要有 requestID？这个问题很简单，就不说明了，你能回答出来么？</p>\n</blockquote>\n<h4 id=\"如何发布自己的服务\"><a class=\"markdownIt-Anchor\" href=\"#如何发布自己的服务\">#</a> 如何发布自己的服务</h4>\n<p>这个我前面的很多文章都提到过，Java 常用 zookeeper，Go 常用 ETCD，服务端进行注册和心跳，客户端获取机器列表，没啥高深的，比如 zookeeper：</p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478523.png\" alt=\"图片\"></p>\n<h2 id=\"grpc-thrift\"><a class=\"markdownIt-Anchor\" href=\"#grpc-thrift\">#</a> gRPC &amp; Thrift</h2>\n<h3 id=\"grpc\"><a class=\"markdownIt-Anchor\" href=\"#grpc\">#</a> gRPC</h3>\n<h4 id=\"grpc-简介\"><a class=\"markdownIt-Anchor\" href=\"#grpc-简介\">#</a> gRPC 简介</h4>\n<p>gRPC 是一个高性能、通用的开源 RPC 框架，其由 Google 2015 年主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf 序列化协议开发，且支持众多开发语言。</p>\n<p>由于是开源框架，通信的双方可以进行二次开发，所以客户端和服务器端之间的通信会更加专注于业务层面的内容，减少了对由 gRPC 框架实现的底层通信的关注。</p>\n<p>如下图，DATA 部分即业务层面内容，下面所有的信息都由 gRPC 进行封装。</p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478524.png\" alt=\"图片\"></p>\n<h4 id=\"grpc-特点\"><a class=\"markdownIt-Anchor\" href=\"#grpc-特点\">#</a> gRPC 特点</h4>\n<ul>\n<li>语言中立，支持多种语言；</li>\n<li>基于 IDL 文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub；</li>\n<li>通信协议基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量；</li>\n<li>序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能序列化框架，基于 HTTP/2 + PB, 保障了 RPC 调用的高性能。</li>\n</ul>\n<h4 id=\"grpc-交互过程\"><a class=\"markdownIt-Anchor\" href=\"#grpc-交互过程\">#</a> gRPC 交互过程</h4>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478525.png\" alt=\"图片\"></p>\n<ul>\n<li>交换机在开启 gRPC 功能后充当 gRPC 客户端的角色，采集服务器充当 gRPC 服务器角色；</li>\n<li>交换机会根据订阅的事件构建对应数据的格式（GPB/JSON），通过 Protocol Buffers 进行编写 proto 文件，交换机与服务器建立 gRPC 通道，通过 gRPC 协议向服务器发送请求消息；</li>\n<li>服务器收到请求消息后，服务器会通过 Protocol Buffers 解译 proto 文件，还原出最先定义好格式的数据结构，进行业务处理；</li>\n<li>数据处理完后，服务器需要使用 Protocol Buffers 重编译应答数据，通过 gRPC 协议向交换机发送应答消息；</li>\n<li>交换机收到应答消息后，结束本次的 gRPC 交互。</li>\n</ul>\n<blockquote>\n<p>简单地说，gRPC 就是在客户端和服务器端开启 gRPC 功能后建立连接，将设备上配置的订阅数据推送给服务器端。我们可以看到整个过程是需要用到 Protocol Buffers 将所需要处理数据的结构化数据在 proto 文件中进行定义。</p>\n</blockquote>\n<h4 id=\"什么是protocol-buffers\"><a class=\"markdownIt-Anchor\" href=\"#什么是protocol-buffers\">#</a> 什么是 Protocol Buffers?</h4>\n<p>你可以理解 ProtoBuf 是一种更加灵活、高效的数据格式，与 XML、JSON 类似，在一些高性能且对响应速度有要求的数据传输场景非常适用。ProtoBuf 在 gRPC 的框架中主要有三个作用：</p>\n<ul>\n<li>定义数据结构</li>\n<li>定义服务接口</li>\n<li>通过序列化和反序列化，提升传输效率</li>\n</ul>\n<p>为什么 ProtoBuf 会提高传输效率呢？</p>\n<p>我们知道使用 XML、JSON 进行数据编译时，数据文本格式更容易阅读，但进行数据交换时，设备就需要耗费大量的 CPU 在 I/O 动作上，自然会影响整个传输速率。Protocol Buffers 不像前者，它会将字符串进行序列化后再进行传输，即二进制数据。</p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478526.png\" alt=\"图片\"></p>\n<p>可以看到其实两者内容相差不大，并且内容非常直观，但是 Protocol Buffers 编码的内容只是提供给操作者阅读的，实际上传输的并不会以这种文本形式，而是序列化后的二进制数据。字节数会比 JSON、XML 的字节数少很多，速率更快。</p>\n<p>如何支撑跨平台，多语言呢？</p>\n<p>Protocol Buffers 自带一个编译器也是一个优势点。前面提到的 proto 文件就是通过编译器进行编译的，proto 文件需要编译生成一个类似库文件，基于库文件才能真正开发数据应用。具体用什么编程语言编译生成这个库文件呢？由于现网中负责网络设备和服务器设备的运维人员往往不是同一组人，运维人员可能会习惯使用不同的编程语言进行运维开发，那么 Protocol Buffers 其中一个优势就能发挥出来 —— 跨语言。</p>\n<p>从上面的介绍，我们得出在编码方面 Protocol Buffers 对比 JSON、XML 的优点：</p>\n<ul>\n<li>简单，体积小，数据描述文件大小只有 1/10 至 1/3；</li>\n<li>传输和解析的速率快，相比 XML 等，解析速度提升 20 倍甚至更高；</li>\n<li>可编译性强。</li>\n</ul>\n<h4 id=\"基于http-20标准设计\"><a class=\"markdownIt-Anchor\" href=\"#基于http-20标准设计\">#</a> 基于 HTTP 2.0 标准设计</h4>\n<p>除了 Protocol Buffers 之外，从交互图中和分层框架可以看到， gRPC 还有另外一个优势 —— 它是基于 HTTP 2.0 协议的。</p>\n<p>由于 gRPC 基于 HTTP 2.0 标准设计，带来了更多强大功能，如多路复用、二进制帧、头部压缩、推送机制。这些功能给设备带来重大益处，如节省带宽、降低 TCP 连接次数、节省 CPU 使用等。gRPC 既能够在客户端应用，也能够在服务器端应用，从而以透明的方式实现两端的通信和简化通信系统的构建。</p>\n<p>HTTP 版本分为 HTTP 1.X、 HTTP 2.0，其中 HTTP 1.X 是当前使用最广泛的 HTTP 协议，HTTP 2.0 称为超文本传输协议第二代。HTTP 1.X 定义了四种与服务器交互的方式，分别为：GET、POST、PUT、DELETE，这些在 HTTP 2.0 中均保留。HTTP 2.0 的新特性：</p>\n<ul>\n<li>双向流、多路复用</li>\n<li>二进制帧</li>\n<li>头部压缩</li>\n</ul>\n<h3 id=\"thrift\"><a class=\"markdownIt-Anchor\" href=\"#thrift\">#</a> Thrift</h3>\n<h4 id=\"thrift-简介\"><a class=\"markdownIt-Anchor\" href=\"#thrift-简介\">#</a> Thrift 简介</h4>\n<p>thrift 是一种可伸缩的跨语言服务的 RPC 软件框架。它结合了功能强大的软件堆栈的代码生成引擎，以建设服务，高效、无缝地在多种语言间结合使用。2007 年由 facebook 贡献到 apache 基金，是 apache 下的顶级项目，具备如下特点：</p>\n<ul>\n<li>支持多语言：C、C++ 、C# 、D 、Delphi 、Erlang 、Go 、Haxe 、Haskell 、Java 、JavaScript、node.js 、OCaml 、Perl 、PHP 、Python 、Ruby 、SmallTalk</li>\n<li>消息定义文件支持注释，数据结构与传输表现的分离，支持多种消息格式</li>\n<li>包含完整的客户端 / 服务端堆栈，可快速实现 RPC，支持同步和异步通信</li>\n</ul>\n<h4 id=\"thrift框架结构\"><a class=\"markdownIt-Anchor\" href=\"#thrift框架结构\">#</a> Thrift 框架结构</h4>\n<p>Thrift 是一套包含序列化功能和支持服务通信的 RPC（远程服务调用）框架，也是一种微服务框架。其主要特点是可以跨语言使用，这也是这个框架最吸引人的地方。</p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478537.png\" alt=\"图片\"></p>\n<p>图中 code 是用户实现的业务逻辑，接下来的 Service.Client 和 write ()/read () 是 thrift 根据 IDL 生成的客户端和服务端的代码，对应于 RPC 中 Client stub 和 Server stub。TProtocol 用来对数据进行序列化与反序列化，具体方法包括二进制，JSON 或者 Apache Thrift 定义的格式。TTransport 提供数据传输功能，使用 Apache Thrift 可以方便地定义一个服务并选择不同的传输协议。</p>\n<h4 id=\"thrift网络栈结构\"><a class=\"markdownIt-Anchor\" href=\"#thrift网络栈结构\">#</a> Thrift 网络栈结构</h4>\n<p>thirft 使用 socket 进行数据传输，数据以特定的格式发送，接收方进行解析。我们定义好 thrift 的 IDL 文件后，就可以使用 thrift 的编译器来生成双方语言的接口、model，在生成的 model 以及接口代码中会有解码编码的代码。thrift 网络栈结构如下：</p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478538.png\" alt=\"图片\"></p>\n<h5 id=\"transport层\"><a class=\"markdownIt-Anchor\" href=\"#transport层\">#</a> Transport 层</h5>\n<p>代表 Thrift 的数据传输方式，Thrift 定义了如下几种常用数据传输方式：</p>\n<ul>\n<li>TSocket: 阻塞式 socket；</li>\n<li>TFramedTransport: 以 frame 为单位进行传输，非阻塞式服务中使用；</li>\n<li>TFileTransport: 以文件形式进行传输。</li>\n</ul>\n<h5 id=\"tprotocol层\"><a class=\"markdownIt-Anchor\" href=\"#tprotocol层\">#</a> TProtocol 层</h5>\n<p>代表 thrift 客户端和服务端之间传输数据的协议，通俗来讲就是客户端和服务端之间传输数据的格式 (例如 json 等)，thrift 定义了如下几种常见的格式：</p>\n<ul>\n<li>TBinaryProtocol: 二进制格式；</li>\n<li>TCompactProtocol: 压缩格式；</li>\n<li>TJSONProtocol: JSON 格式；</li>\n<li>TSimpleJSONProtocol: 提供只写的 JSON 协议。</li>\n</ul>\n<h4 id=\"server模型\"><a class=\"markdownIt-Anchor\" href=\"#server模型\">#</a> Server 模型</h4>\n<ul>\n<li>\n<h5 id=\"tsimpleserver-简单的单线程服务模型常用于测试\"><a class=\"markdownIt-Anchor\" href=\"#tsimpleserver-简单的单线程服务模型常用于测试\">#</a> TSimpleServer: 简单的单线程服务模型，常用于测试；</h5>\n</li>\n<li>\n<p>TThreadPoolServer: 多线程服务模型，使用标准的阻塞式 IO；</p>\n</li>\n<li>\n<p>TNonBlockingServer: 多线程服务模型，使用非阻塞式 IO (需要使用 TFramedTransport 数据传输方式);</p>\n</li>\n<li>\n<p>THsHaServer: THsHa 引入了线程池去处理，其模型读写任务放到线程池去处理，Half-sync/Half-async 处理模式，Half-async 是在处理 IO 事件上 (accept/read/write io)，Half-sync 用于 handler 对 rpc 的同步处理；</p>\n</li>\n</ul>\n<h3 id=\"grpc-vs-thrift\"><a class=\"markdownIt-Anchor\" href=\"#grpc-vs-thrift\">#</a> gRPC VS Thrift</h3>\n<h4 id=\"功能比较\"><a class=\"markdownIt-Anchor\" href=\"#功能比较\">#</a> 功能比较</h4>\n<p>直接贴上网上的两幅截图：</p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-16563853478539.png\" alt=\"图片\"></p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-165638534785310.png\" alt=\"图片\"></p>\n<h4 id=\"性能比较\"><a class=\"markdownIt-Anchor\" href=\"#性能比较\">#</a> 性能比较</h4>\n<p>也是基于网上测试的结果，仅供参考：</p>\n<ul>\n<li>整体上看，长连接性能优于短连接，性能差距在两倍以上；</li>\n<li>对比 Go 语言的两个 RPC 框架，Thrift 性能明显优于 gRPC，性能差距也在两倍以上；</li>\n<li>对比 Thrift 框架下的的两种语言，长连接下 Go 与 C<ins> 的 RPC 性能基本在同一个量级，在短连接下，Go 性能大概是 C</ins> 的二倍；</li>\n<li>对比 Thrift&amp;C++ 下的 TSimpleServer 与 TNonblockingServer，在单进程客户端长连接的场景下，TNonblockingServer 因为存在线程管理开销，性能较 TSimpleServer 差一些；但在短连接时，主要开销在连接建立上，线程池管理开销可忽略；</li>\n<li>两套 RPC 框架，以及两大语言运行都非常稳定，5w 次请求耗时约是 1w 次的 5 倍；</li>\n</ul>\n<h4 id=\"如何选型\"><a class=\"markdownIt-Anchor\" href=\"#如何选型\">#</a> 如何选型</h4>\n<p>什么时候应该选择 gRPC 而不是 Thrift：</p>\n<ul>\n<li>需要良好的文档、示例</li>\n<li>喜欢、习惯 HTTP/2、ProtoBuf</li>\n<li>对网络传输带宽敏感</li>\n</ul>\n<p>什么时候应该选择 Thrift 而不是 gRPC：</p>\n<ul>\n<li>需要在非常多的语言间进行数据交换</li>\n<li>对 CPU 敏感</li>\n<li>协议层、传输层有多种控制要求</li>\n<li>需要稳定的版本</li>\n<li>不需要良好的文档和示例</li>\n</ul>\n<h3 id=\"小节\"><a class=\"markdownIt-Anchor\" href=\"#小节\">#</a> 小节</h3>\n<p>上面详细介绍 gRPC 和 Thrift 的特点和区别，小节如下：</p>\n<ul>\n<li>GRPC 主要就是搞了个 ProtoBuf，然后采用 HTTP 协议，所以协议部分没有重复造轮子，重点就在 ProtoBuf 上。</li>\n<li>Thrift 的数据格式是用的现成的，没有单独搞一套，但是它在传输层和服务端全部是自己造轮子，所以可以对协议层、传输层有多种控制要求。</li>\n</ul>\n<h2 id=\"grpc示例\"><a class=\"markdownIt-Anchor\" href=\"#grpc示例\">#</a> gRPC 示例</h2>\n<p>除了理论，我们还需注重实践，gPRC 的使用姿势看这篇文章 <a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;mid=2247485097&amp;idx=1&amp;sn=59a7a21f47cbec1532de839e49cb9abf&amp;chksm=cf03444bf874cd5d3ecd724f779d5ee2fc3a2e23d6a1541ac219e72f25dd8cdb9ac5928e2a9a&amp;token=1404035328&amp;lang=zh_CN&amp;scene=21#wechat_redirect\">【RPC 基础系列 3】gRPC 简单示例</a></p>\n<h2 id=\"dubbo-spring-cloud\"><a class=\"markdownIt-Anchor\" href=\"#dubbo-spring-cloud\">#</a> Dubbo &amp; Spring Cloud</h2>\n<h3 id=\"dubbo\"><a class=\"markdownIt-Anchor\" href=\"#dubbo\">#</a> Dubbo</h3>\n<p>Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。简单的说，Dubbo 就是个服务框架，说白了就是个远程服务调用的分布式框架。</p>\n<p>Dubbo 总体架构：</p>\n<img src=\"/2022/06/28/rpc-kuang-jia/image-20220626163327014.png\" alt=\"image-20220626163327014\" style=\"zoom:80%;\">\n<p>Dubbo 特点：</p>\n<ul>\n<li>远程通讯：提供对多种基于长连接的 NIO 框架抽象封装（非阻塞 I/O 的通信方式，Mina/Netty/Grizzly），包括多种线程模型，序列化（Hessian2/ProtoBuf），以及 “请求 - 响应” 模式的信息交换方式。</li>\n<li>集群容错：提供基于接口方法的透明远程过程调用（RPC），包括多协议支持（自定义 RPC 协议），以及软负载均衡（Random/RoundRobin），失败容错（Failover/Failback），地址路由，动态配置等集群支持。</li>\n<li>自动发现：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>\n</ul>\n<h3 id=\"spring-cloud\"><a class=\"markdownIt-Anchor\" href=\"#spring-cloud\">#</a> Spring Cloud</h3>\n<p>Spring Cloud 基于 Spring Boot，为微服务体系开发中的架构问题，提供了一整套的解决方案 —— 服务注册与发现，服务消费，服务保护与熔断，网关，分布式调用追踪，分布式配置管理等。</p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-165638534785312.png\" alt=\"图片\"></p>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-165638534785313.png\" alt=\"图片\"></p>\n<h3 id=\"dubbo-vs-spring-cloud\"><a class=\"markdownIt-Anchor\" href=\"#dubbo-vs-spring-cloud\">#</a> Dubbo vs Spring Cloud</h3>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/640-165638534785314.png\" alt=\"图片\"></p>\n<p>使用 Dubbo 构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而 Spring Cloud 就像品牌机，在 Spring Source 的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。</p>\n<p>关于 Dubbo 和 Spring Cloud 的相关概念和对比，我个人比较倾向于 Spring Cloud，原因就是真正的微服务框架、提供整套的组件支持、使用简单方便、强大的社区支持等等，另外，因为考虑到 .NET/.NET Core 的兼容处理，RPC 并不能很好的实现跨语言（需要借助跨语言库，比如 gRPC、Thrift，但因为 Dubbo 本身就是 “gRPC”，在 Dubbo 之上再包一层 gRPC，有点重复封装了），而 HTTP REST 本身就是支持跨语言实现，所以，Spring Cloud 这一点还是非常好的（Dubbox 也支持，但性能相比要差一些）。</p>\n<p>但凡事无绝对，每件事物有好的地方也有不好的地方，总的来说，Dubbo 和 Spring Cloud 的主要不同体现在两个方面：服务调用方式不同和专注点不同（生态不同）。</p>\n<h2 id=\"影响rpc框架性能的因素\"><a class=\"markdownIt-Anchor\" href=\"#影响rpc框架性能的因素\">#</a> 影响 RPC 框架性能的因素</h2>\n<p><img src=\"/2022/06/28/rpc-kuang-jia/70-16563864189122.png\" alt=\"这里写图片描述\"></p>\n<p>在物理服务器性能相同的情况下，以下几个因素会对一款 RPC 框架的性能产生直接影响：</p>\n<ul>\n<li>\n<p>使用的网络 IO 模型：RPC 服务器可以只支持传统的阻塞式同步 IO，也可以做一些改进让 RPC 服务器支持非阻塞式同步 IO，或者在服务器上实现对多路 IO 模型的支持。这样的 RPC 服务器的性能在高并发状态下，会有很大的差别。特别是单位处理性能下对内存、CPU 资源的使用率。</p>\n</li>\n<li>\n<p>基于的网络协议：一般来说您可以选择让您的 RPC 使用应用层协议，例如 HTTP 或者 HTTP/2 协议，或者使用 TCP 协议，让您的 RPC 框架工作在传输层。工作在哪一层网络上会对 RPC 框架的工作性能产生一定的影响，但是对 RPC 最终的性能影响并不大。但是至少从各种主流的 RPC 实现来看，没有采用 UDP 协议做为主要的传输协议的。</p>\n</li>\n<li>\n<p>消息封装格式：选择或者定义一种消息格式的封装，要考虑的问题包括：消息的易读性、描述单位内容时的消息体大小、编码难度、解码难度、解决半包 / 粘包问题的难易度。当然如果您只是想定义一种 RPC 专用的消息格式，那么消息的易读性可能不是最需要考虑的。消息封装格式的设计是目前各种 RPC 框架性能差异的最重要原因，这就是为什么几乎所有主流的 RPC 框架都会设计私有的消息封装格式的原因。dubbo 中消息体数据包含 dubbo 版本号、接口名称、接口版本、方法名称、参数类型列表、参数、附加信息</p>\n</li>\n<li>\n<p>Schema 和序列化（Schema &amp; Data Serialization）：序列化和反序列化，是对象到二进制数据的转换，程序是可以理解对象的，对象一般含有 schema 或者结构，基于这些语义来做特定的业务逻辑处理。考察一个序列化框架一般会关注以下几点：<br>\nEncoding format 。是 human readable（是否能直观看懂 json） 还是 binary (二进制)。<br>\nSchema declaration 。也叫作契约声明，基于 IDL，比如 Protocol Buffers/Thrift，还是自描述的，比如 JSON、XML。另外还需要看是否是强类型的。<br>\n语言平台的中立性 。比如 Java 的 Native Serialization 就只能自己玩，而 Protocol Buffers 可以跨各种语言和平台。<br>\n新老契约的兼容性 。比如 IDL 加了一个字段，老数据是否还可以反序列化成功。<br>\n和压缩算法的契合度 。跑 benchmark (基准) 和实际应用都会结合各种压缩算法，例如 gzip、snappy。<br>\n性能 。这是最重要的，序列化、反序列化的时间，序列化后数据的字节大小是考察重点。<br>\n序列化方式非常多，常见的有 Protocol Buffers， Avro，Thrift，XML，JSON，MessagePack，Kyro，Hessian，Protostuff，Java Native Serialize，FST 。</p>\n</li>\n<li>\n<p>实现的服务处理管理方式：在高并发请求下，如何管理注册的服务也是一个性能影响点。您可以让 RPC 的 Selector/Processor 使用单个线程运行服务的具体实现（这意味着上一个客户端的请求没有处理完，下一个客户端的请求就需要等待）、您也可以为每一个 RPC 具体服务的实现开启一个独立的线程运行（可以一次处理多个请求，但是操作系统对于 “可运行的最大线程数” 是有限制的）、您也可以线程池来运行 RPC 具体的服务实现（目前看来，在单个服务节点的情况下，这种方式是比较好的）、您还可以通过注册代理的方式让多个服务节点来运行具体的 RPC 服务实现。</p>\n</li>\n</ul>\n",
            "tags": [
                "RPC",
                "微服务"
            ]
        }
    ]
}