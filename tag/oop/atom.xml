<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://prehitting.gitee.io</id>
    <title>不利索の鸣 • Posts by &#34;oop&#34; tag</title>
    <link href="https://prehitting.gitee.io" />
    <updated>2022-05-06T14:12:48.000Z</updated>
    <category term="MybatisPlus" />
    <category term="SpringBoot" />
    <category term="拦截器" />
    <category term="SpringCache" />
    <category term="Redis" />
    <category term="Spring" />
    <category term="Swagger" />
    <category term="Springmvc" />
    <category term="mybatisPlus" />
    <category term="IDEA" />
    <category term="Linux" />
    <category term="设计模式" />
    <category term="OOP" />
    <category term="动态代理模式" />
    <category term="单例模式" />
    <category term="原型模式" />
    <category term="工厂模式" />
    <category term="建造者模式" />
    <category term="静态代理模式" />
    <category term="SLF4J" />
    <category term="Redis命令" />
    <category term="过滤器" />
    <category term="瑞吉外卖" />
    <category term="SpringMVC" />
    <category term="Vim" />
    <category term="Jedis" />
    <entry>
        <id>https://prehitting.gitee.io/2022/05/06/she-ji-mo-shi/oop-qi-da-yuan-ze/</id>
        <title>OOP七大原则</title>
        <link rel="alternate" href="https://prehitting.gitee.io/2022/05/06/she-ji-mo-shi/oop-qi-da-yuan-ze/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;PBP/OBP/OOP 的特征 PBP（基于过程）：函数、域与生命周期的概念、函数重载、函数模板、异常处理、范型算法。 OBP（基于对象）：类（接口）、类的生命周期、类模板。 OOP（面向对象）：继承、多态。 三个概念步步深入，后者包括前者。其目的是实现软件开发的可重用性，解决软件危机（软件工程思想未引入之前）。 OOP 不可避免设计原则的发展与设计模式的产生，这是 OOP 独具的特征决定的（正如前面所说，特征的产生是由其产生目的决定的）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;OOP 的方法论：高内聚，低耦合，易复用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;oop七大原则&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#oop七大原则&#34;&gt;#&lt;/a&gt; OOP 七大原则&lt;/h2&gt;
&lt;h3 id=&#34;开闭原则ocp&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#开闭原则ocp&#34;&gt;#&lt;/a&gt; 开闭原则 (OCP)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对扩展开放，对修改关闭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展开放&lt;/strong&gt;：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改关闭&lt;/strong&gt;：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求模块是修改关闭的。&lt;/p&gt;
&lt;h3 id=&#34;里氏替换原则lsp&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#里氏替换原则lsp&#34;&gt;#&lt;/a&gt; 里氏替换原则 (LSP)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;所有引用基类的地方必须能透明地使用其子类的对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;里式替换原则的引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​	也就是说，只有满足以下 2 个条件的 OO 设计才可被认为是满足了 LSP 原则：&lt;/p&gt;
&lt;p&gt;​	1. 不应该在代码中出现 if/else 之类对派生类类型进行判断的条件。&lt;/p&gt;
&lt;p&gt;​	2. 派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。&lt;/p&gt;
&lt;h3 id=&#34;依赖倒置原则dip&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#依赖倒置原则dip&#34;&gt;#&lt;/a&gt; 依赖倒置原则 (DIP)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面向接口编程，不要面向实现编程&lt;/p&gt;
&lt;h3 id=&#34;单一职责原则&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#单一职责原则&#34;&gt;#&lt;/a&gt; 单一职责原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;控制类的粒度大小，将对象解耦，提高其内聚性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单一职责原则：&lt;strong&gt;&lt;em&gt;一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中&lt;/em&gt;。&lt;/strong&gt;&lt;br&gt;
单一职责原则的另一种定义方式：&lt;strong&gt;&lt;em&gt;就一个类而言，应该仅有一个引起它变化的原因&lt;/em&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;接口隔离原则isp&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#接口隔离原则isp&#34;&gt;#&lt;/a&gt; 接口隔离原则（ISP）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用多个专门的接口，而不使用单一 的总接口，即客户端不应该依赖那些它不需要的接口。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​	换句话说，使用多个专门的接口比使用单一的总接口总要好。&lt;/p&gt;
&lt;p&gt;它包含了 2 层意思：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口的依赖（继承）原则：如果一个接口 a 继承另一个接口 b，则接口 a 相当于继承了接口 b 的方法，那么继承了接口 b 后的接口 a 也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口 a 被 b 给污染了，应该重新设计它们的关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接 口的客户端仅需知道与之相关的方法即可。&lt;/p&gt;
&lt;h3 id=&#34;迪米特法则lod&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#迪米特法则lod&#34;&gt;#&lt;/a&gt; 迪米特法则 (LoD)&lt;/h3&gt;
&lt;p&gt;也叫&lt;font color=&#34;red&#34;&gt;最少知道原则&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只与直接的朋友交谈，不和 “陌生人 “说话&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​	迪米特法则可以简单说成：talk only to your immediate friends。 对于 OOD 来说，又被解释为下面几种方式：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。&lt;/p&gt;
&lt;p&gt;​	迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。&lt;/p&gt;
&lt;p&gt;​	迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系 —— 这在一定程度上增加了系统的复杂度。&lt;/p&gt;
&lt;p&gt;​	如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。&lt;/p&gt;
&lt;h4 id=&#34;lod法则缺点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#lod法则缺点&#34;&gt;#&lt;/a&gt; LoD 法则缺点&lt;/h4&gt;
&lt;p&gt;​	在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。&lt;/p&gt;
&lt;p&gt;​	遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。&lt;/p&gt;
&lt;h3 id=&#34;合成复用原则carp&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#合成复用原则carp&#34;&gt;#&lt;/a&gt; 合成复用原则 (CARP)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;尽量先使用组合或者聚合等关联关系来实现，其次考虑使用继承关系来实现&lt;/p&gt;
&lt;/blockquote&gt;
</content>
        <category term="设计模式" />
        <category term="OOP" />
        <updated>2022-05-06T14:12:48.000Z</updated>
    </entry>
</feed>
