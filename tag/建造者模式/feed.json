{
    "version": "https://jsonfeed.org/version/1",
    "title": "不利索の鸣 • All posts by \"建造者模式\" tag",
    "description": "欢迎来到鸣崽的空间，这里不仅有学习，还有生活",
    "home_page_url": "https://prehitting.gitee.io",
    "items": [
        {
            "id": "https://prehitting.gitee.io/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/",
            "url": "https://prehitting.gitee.io/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/",
            "title": "建造者模式",
            "date_published": "2022-05-09T01:39:18.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述</h2>\n<h3 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h3>\n<blockquote>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>\n</blockquote>\n<h3 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h3>\n<ol>\n<li>封装性好，构建和表示分离</li>\n<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦</li>\n<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险</li>\n</ol>\n<h3 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h3>\n<ol>\n<li>产品的组成部分必须相同，限制了其使用范围</li>\n<li>如果产品的内部变化复杂，若产品内部发生改变，则建造者也要同步修改，后期维护成本大</li>\n</ol>\n<p>建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重部件的创建过程，但两者可以结合使用</p>\n<h2 id=\"模式结构\"><a class=\"markdownIt-Anchor\" href=\"#模式结构\">#</a> 模式结构</h2>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>产品角色（Product）</td>\n<td>包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件</td>\n</tr>\n<tr>\n<td>抽象建造者（Builder）</td>\n<td>它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult ()</td>\n</tr>\n<tr>\n<td>具体建造者 (Concrete Builder）</td>\n<td>实现 Builder 接口，完成复杂产品的各个部件的具体创建方法</td>\n</tr>\n<tr>\n<td>指挥者（Director）</td>\n<td>调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/2022/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20220509121913779-16520699567131.png\" alt=\"image-20220509121913779\"></p>\n<h2 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@EqualsAndHashCode</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String buildA;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String buildB;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String buildC;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String buildD;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Builder</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildA</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildB</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildC</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildD</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> Product <span class=\"title function_\">getProduct</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Builder</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Product product;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.product = <span class=\"keyword\">new</span> <span class=\"title class_\">Product</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">buildA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构建部件A&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">buildB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构建部件B&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">buildC</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构建部件C&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">buildD</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构建部件D&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Product <span class=\"title function_\">getProduct</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> product;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Director</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//指挥Worker</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Product <span class=\"title function_\">build</span><span class=\"params\">(Builder builder)</span>&#123;</span><br><span class=\"line\">        builder.buildA();</span><br><span class=\"line\">        builder.buildB();</span><br><span class=\"line\">        builder.buildC();</span><br><span class=\"line\">        builder.buildD();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder.getProduct();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用场景\"><a class=\"markdownIt-Anchor\" href=\"#应用场景\">#</a> 应用场景</h2>\n<p>建造者模式唯一区别于工厂模式的是针对<strong>复杂对象</strong>的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。</p>\n<p>当需要创建的产品具备复杂创建过程时，可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。</p>\n<p>建造者模式主要适用于以下应用场景：</p>\n<ul>\n<li>相同的方法，不同的执行顺序，产生不同的结果。</li>\n<li>多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。</li>\n<li>产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。</li>\n<li>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。</li>\n</ul>\n<h2 id=\"建造者模式和工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#建造者模式和工厂模式\">#</a> 建造者模式和工厂模式</h2>\n<ul>\n<li>建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。</li>\n<li>创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样</li>\n<li>关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。</li>\n<li>建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。</li>\n</ul>\n",
            "tags": [
                "设计模式",
                "建造者模式"
            ]
        }
    ]
}